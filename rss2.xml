<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>南北橘子</title>
    <link>https://HoldusTogether.github.io/</link>
    
    <atom:link href="https://holdustogether.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>不要停止成为更好的自己</description>
    <pubDate>Mon, 22 Aug 2022 04:25:49 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>JVM 垃圾回收</title>
      <link>https://holdustogether.github.io/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
      <guid>https://holdustogether.github.io/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
      <pubDate>Mon, 22 Aug 2022 02:41:13 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;1-如何判断对象可以回收&quot;&gt;&lt;a href=&quot;#1-如何判断对象可以回收&quot; class=&quot;headerlink&quot; title=&quot;1. 如何判断对象可以回收&quot;&gt;&lt;/a&gt;1. 如何判断对象可以回收&lt;/h2&gt;&lt;h3 id=&quot;1-1-引用计数法&quot;&gt;&lt;a href=&quot;#1-</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1. 如何判断对象可以回收"></a>1. 如何判断对象可以回收</h2><h3 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h3><hr><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.assets/image-20220822104352038.png" alt="image-20220822104352038"></p><p>只要对象被引用，计数就+1。不再引用就-1。 为0被回收</p><p>循环引用问题。</p><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><hr><ul><li>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li><li>扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以 回收</li><li>哪些对象可以作为 GC Root ?<ul><li>MAT（memory analyzer）工具</li><li>栈引用的对象，被加锁的对象还有糸统核心的类对象 堆中的</li></ul></li></ul><h3 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h3><hr><ol><li>强引用</li></ol><ul><li>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li></ul><ol start="2"><li>软引用（SoftReference）</li></ol><ul><li>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用 对象</li><li>可以配合引用队列来释放软引用自身</li></ul><ol start="3"><li>弱引用（WeakReference）</li></ol><ul><li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li><li>可以配合引用队列来释放弱引用自身</li></ul><ol start="4"><li>虚引用（PhantomReference）</li></ol><ul><li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队， 由 Reference Handler 线程调用虚引用相关方法释放直接内存</li></ul><ol start="5"><li>终结器引用（FinalReference）</li></ol><ul><li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象 暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象</li></ul><h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2. 垃圾回收算法"></a>2. 垃圾回收算法</h2><h3 id="2-1-标记清除"><a href="#2-1-标记清除" class="headerlink" title="2.1 标记清除"></a>2.1 标记清除</h3><hr><p>定义： Mark Sweep</p><ul><li><p>速度较快</p></li><li><p>会造成内存碎片</p><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.assets/image-20220822105654824.png" alt="image-20220822105654824"></p></li></ul><h3 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理"></a>2.2 标记整理</h3><hr><p>定义：Mark Compact</p><ul><li><p>速度慢</p></li><li><p>没有内存碎片</p><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.assets/image-20220822105727568.png" alt="image-20220822105727568"></p></li></ul><h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h3><hr><p>定义：Copy</p><ul><li>不会有内存碎片</li><li>需要占用双倍内存空间</li></ul><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.assets/image-20220822105908299.png" alt="image-20220822105908299"></p><h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3. 分代垃圾回收"></a>3. 分代垃圾回收</h2><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.assets/image-20220822105931557.png" alt="image-20220822105931557"></p><ul><li>对象首先分配在伊甸园区域</li><li>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的 对象年龄加 1并且交换 from to</li><li>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li><li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</li><li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时 间更长</li><li>新生代存放朝生夕死的对象，老年代存放用的频繁的</li></ul><h3 id="3-1-相关-VM-参数"><a href="#3-1-相关-VM-参数" class="headerlink" title="3.1 相关 VM 参数"></a>3.1 相关 VM 参数</h3><hr><table><thead><tr><th>含义</th><th>参数</th></tr></thead><tbody><tr><td>堆初始大小</td><td>-Xms</td></tr><tr><td>堆最大大小</td><td>-Xmx 或 -XX:MaxHeapSize&#x3D;size</td></tr><tr><td>新生代大小</td><td>-Xmn 或 (-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size )</td></tr><tr><td>幸存区比例（动态）</td><td>-XX:InitialSurvivorRatio&#x3D;ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td>幸存区比例</td><td>-XX:SurvivorRatio&#x3D;ratio</td></tr><tr><td>晋升阈值</td><td>-XX:MaxTenuringThreshold&#x3D;threshold</td></tr><tr><td>晋升详情</td><td>-XX:+PrintTenuringDistribution</td></tr><tr><td>GC详情</td><td>-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td>FullGC 前 MinorGC</td><td>-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4. 垃圾回收器"></a>4. 垃圾回收器</h2><ol><li>串行<ul><li>单线程</li><li>堆内存较小，适合个人电脑</li></ul></li><li>吞吐量优先</li></ol><ul><li>多线程</li><li>堆内存较大，多核 cpu</li><li>让单位时间内，STW 的时间最短 0.2 0.2 &#x3D; 0.4，垃圾回收时间占比最低，这样就称吞吐量高</li></ul><ol start="3"><li>响应时间优先</li></ol><ul><li>多线程</li><li>堆内存较大，多核 cpu</li><li>尽可能让单次 STW 的时间最短 0.1 0.1 0.1 0.1 0.1 &#x3D; 0.5</li></ul><h3 id="4-1-串行"><a href="#4-1-串行" class="headerlink" title="4.1 串行"></a>4.1 串行</h3><hr><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.assets/image-20220822111327376.png" alt="image-20220822111327376"></p><p>复制算法 + 标记整理</p><p>新生代 + 老年代</p><h3 id="4-2-吞吐量优先-ASP"><a href="#4-2-吞吐量优先-ASP" class="headerlink" title="4.2 吞吐量优先 ASP"></a>4.2 吞吐量优先 ASP</h3><hr><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.assets/image-20220822111531389.png" alt="image-20220822111531389"></p><h3 id="4-3-响应时间优先-CMS"><a href="#4-3-响应时间优先-CMS" class="headerlink" title="4.3 响应时间优先 CMS"></a>4.3 响应时间优先 CMS</h3><hr><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.assets/image-20220822111550191.png" alt="image-20220822111550191"></p><h3 id="4-4-G1"><a href="#4-4-G1" class="headerlink" title="4.4 G1"></a>4.4 G1</h3><hr><p>定义：Garbage First</p><ul><li>2017 JDK 9 默认</li></ul><p>适用场景</p><ul><li>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms</li><li>超大堆内存，会将堆划分为多个大小相等的 Region</li><li>整体上是 标记+整理 算法，两个区域之间是 复制 算法</li></ul><p>相关 JVM 参数</p><p>-XX:+UseG1GC</p><p>-XX:G1HeapRegionSize&#x3D;size </p><p>-XX:MaxGCPauseMillis&#x3D;time</p><p><strong>因为堆内存大，所以回收速度会变慢，涉及到标记复制等。化整为零，方便进行优化，标记。加快速度。每个区都有完整的新生代老年代</strong>。</p><h4 id="1-G1-垃圾回收阶段"><a href="#1-G1-垃圾回收阶段" class="headerlink" title="1) G1 垃圾回收阶段"></a>1) G1 垃圾回收阶段</h4><img src="/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220822112654594.png" alt="image-20220822112654594" style="zoom: 50%;"><h4 id="2-Young-Collection"><a href="#2-Young-Collection" class="headerlink" title="2) Young Collection"></a>2) Young Collection</h4><ul><li>会STW</li></ul><img src="/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220822113339234.png" alt="image-20220822113339234" style="zoom:33%;"><h4 id="3-Young-Collection-CM"><a href="#3-Young-Collection-CM" class="headerlink" title="3) Young Collection + CM"></a>3) Young Collection + CM</h4><ul><li>在 Young GC 时会进行 GC Root 的初始标记</li><li>老年代占用堆空间比例达到阈值时，进行并发标记（不会 STW），由下面的 JVM 参数决定</li></ul><p>老年代占用堆空间比例达到阈值时，进行并发标记（不会 STW），由下面的 JVM 参数决定</p><img src="/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220822113438244.png" alt="image-20220822113438244" style="zoom:33%;"><h4 id="4-Mixed-Collection"><a href="#4-Mixed-Collection" class="headerlink" title="4) Mixed Collection"></a>4) Mixed Collection</h4><p>会对 E、S、O 进行全面垃圾回收</p><ul><li>最终标记（Remark）会 STW</li><li>拷贝存活（Evacuation）会 STW</li></ul><p>-XX:MaxGCPauseMillis&#x3D;ms 暂停时间，为了达到这个暂停时间，去优秀标记有价值的</p><img src="/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220822114130477.png" alt="image-20220822114130477" style="zoom:33%;"><h4 id="5-Full-GC"><a href="#5-Full-GC" class="headerlink" title="5) Full GC"></a>5) Full GC</h4><ul><li><p>SerialGC 串行</p><ul><li>新生代内存不足发生的垃圾收集 - minor gc</li><li>老年代内存不足发生的垃圾收集 - full gc</li></ul></li><li><p>ParallelGC 并行</p><ul><li>新生代内存不足发生的垃圾收集 - minor gc</li><li>老年代内存不足发生的垃圾收集 - full gc</li></ul></li><li><p>CMS 并发</p><ul><li>新生代内存不足发生的垃圾收集 - minor gc</li><li>老年代内存不足</li></ul></li><li><p>G1 并发</p><ul><li>新生代内存不足发生的垃圾收集 - minor gc</li><li>老年代内存不足 有个阈值，老年代内存占比堆内存达到百分之45，就会触发并发标记和混合收集。如果回收速度大于新产生速度，还不是FullGC，当小于速度的时候，并发就失败了，就会退回串行，并FullGC</li></ul></li></ul><h4 id="6-Young-Collection-跨代引用"><a href="#6-Young-Collection-跨代引用" class="headerlink" title="6) Young Collection 跨代引用"></a>6) Young Collection 跨代引用</h4><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><img src="/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220822115242586.png" alt="image-20220822115242586" style="zoom:33%;"><p>新生代回收需要找到根对象，然后可达算法找到幸存的，有些根对象在老年代中</p><ul><li>卡表与 Remembered Set</li><li>在引用变更时通过 post-write barrier + dirty card queue</li><li>concurrent refinement threads 更新 Remembered Set</li></ul><img src="/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220822115450644.png" alt="image-20220822115450644" style="zoom:33%;"><h4 id="7-Remark"><a href="#7-Remark" class="headerlink" title="7) Remark"></a>7) Remark</h4><p>pre-write barrier + satb_mark_queue 在对象引用前加入一个队列，完了再检查队列中的元素</p><img src="/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220822120017301.png" alt="image-20220822120017301" style="zoom:33%;"><h4 id="8-JDK-8u20-字符串去重"><a href="#8-JDK-8u20-字符串去重" class="headerlink" title="8) JDK 8u20 字符串去重"></a>8) JDK 8u20 字符串去重</h4><ul><li>优点：节省大量内存</li><li>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加</li></ul><p>-XX:+UseStringDeduplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>将所有新分配的字符串放入一个队列</li><li>当新生代回收时，G1并发检查是否有字符串重复</li><li>如果它们值一样，让它们引用同一个 char[]</li><li>注意，与 String.intern() 不一样<ul><li>String.intern() 关注的是字符串对象</li><li>而字符串去重关注的是 char[]</li><li>在 JVM 内部，使用了不同的字符串表</li></ul></li></ul><h4 id="9-JDK-8u40-并发标记类卸载"><a href="#9-JDK-8u40-并发标记类卸载" class="headerlink" title="9) JDK 8u40 并发标记类卸载"></a>9) JDK 8u40 并发标记类卸载</h4><p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸 载它所加载的所有类</p><p>-XX:+ClassUnloadingWithConcurrentMark 默认启用</p><h4 id="10-JDK-8u60-回收巨型对象"><a href="#10-JDK-8u60-回收巨型对象" class="headerlink" title="10) JDK 8u60 回收巨型对象"></a>10) JDK 8u60 回收巨型对象</h4><ul><li>一个对象大于 region 的一半时，称之为巨型对象</li><li>G1 不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生 代垃圾回收时处理掉</li></ul><h4 id="11-JDK-9-并发标记起始时间的调整"><a href="#11-JDK-9-并发标记起始时间的调整" class="headerlink" title="11) JDK 9 并发标记起始时间的调整"></a>11) JDK 9 并发标记起始时间的调整</h4><ul><li>并发标记必须在堆空间占满前完成，否则退化为 FullGC</li><li>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent</li><li>JDK 9 可以动态调整<ul><li>JDK 9 可以动态调整</li><li>进行数据采样并动态调整</li><li>总会添加一个安全的空档空间</li></ul></li></ul><h4 id="12-JDK-9-更高效的回收"><a href="#12-JDK-9-更高效的回收" class="headerlink" title="12) JDK 9 更高效的回收"></a>12) JDK 9 更高效的回收</h4><ul><li>250+增强</li><li>180+bug修复</li></ul><h2 id="5-垃圾回收调优"><a href="#5-垃圾回收调优" class="headerlink" title="5. 垃圾回收调优"></a>5. 垃圾回收调优</h2><p>预备知识</p><ul><li>掌握 GC 相关的 VM 参数，会基本的空间调整</li><li>掌握相关工具</li><li>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</li></ul><h3 id="5-1-调优领域"><a href="#5-1-调优领域" class="headerlink" title="5.1 调优领域"></a>5.1 调优领域</h3><hr><ul><li>内存</li><li>锁竞争</li><li>cpu 占用</li><li>io</li></ul><h3 id="5-2-确定目标"><a href="#5-2-确定目标" class="headerlink" title="5.2 确定目标"></a>5.2 确定目标</h3><hr><ul><li>【低延迟】还是【高吞吐量】，选择合适的回收器</li><li>CMS，G1，ZGC</li><li>ParallelGC</li><li>Zing</li></ul><h3 id="5-3-最快的-GC"><a href="#5-3-最快的-GC" class="headerlink" title="5.3 最快的 GC"></a>5.3 最快的 GC</h3><hr><p>答案是不发生 GC</p><ul><li>查看 FullGC 前后的内存占用，考虑下面几个问题<ul><li><p>数据是不是太多？</p><ul><li>resultSet &#x3D; statement.executeQuery(“select * from 大表 limit n”)</li></ul></li><li><p>数据表示是否太臃肿？</p><ul><li>对象图</li><li>对象大小 16 Integer 24 int 4  对象瘦身</li></ul></li><li><p>是否存在内存泄漏？</p><ul><li>static Map map &#x3D;  长期存在的对象 一直往里加会造成溢出， 通过下面的三个方法</li><li>软</li><li>弱</li><li>第三方缓存实现</li></ul></li></ul></li></ul><h3 id="5-4-新生代调优"><a href="#5-4-新生代调优" class="headerlink" title="5.4 新生代调优"></a>5.4 新生代调优</h3><hr><ul><li><p>新生代的特点（内存调优从新生代开始）</p><ul><li><p>所有的 new 操作的内存分配非常廉价</p><ul><li>TLAB thread-local allocation buffer  每个线程局部的私有的区域 进行伊甸园分配，线程安全</li></ul></li><li><p>死亡对象的回收代价是零  （新生代所有的垃圾回收器都是用的复制算法）</p></li><li><p>大部分对象用过即死 新生代中的</p></li><li><p>Minor GC 的时间远远低于 Full GC</p></li></ul></li></ul><p>策略：</p><ul><li>新生代调优加大容量 越大越好吗？</li></ul><p>-Xmn Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC is performed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</p><p>新生代小了会频繁mGC 引发暂停   太大了 老年代的空间就少了，空间少的触发垃圾回收FullGC就多了</p><ul><li>新生代能容纳所有【并发量 * (请求-响应)】的数据</li><li>幸存区大到能保留【当前活跃对象+需要晋升对象】</li><li>晋升阈值配置得当，让长时间存活对象尽快晋升</li></ul><p>晋升阈值配置得当，让长时间存活对象尽快晋升</p><p>-XX:MaxTenuringThreshold&#x3D;threshold</p><p>-XX:+PrintTenuringDistribution</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Desired survivor size <span class="number">48286924</span> bytes, <span class="keyword">new</span> <span class="title class_">threshold</span> <span class="number">10</span> (max <span class="number">10</span>)</span><br><span class="line">- age <span class="number">1</span>: <span class="number">28992024</span> bytes, <span class="number">28992024</span> total</span><br><span class="line">- age <span class="number">2</span>: <span class="number">1366864</span> bytes, <span class="number">30358888</span> total</span><br><span class="line">- age <span class="number">3</span>: <span class="number">1425912</span> bytes, <span class="number">31784800</span> total</span><br><span class="line">..</span><br></pre></td></tr></table></figure><h3 id="5-5-老年代调优"><a href="#5-5-老年代调优" class="headerlink" title="5.5 老年代调优"></a>5.5 老年代调优</h3><hr><p>以 CMS 为例</p><ul><li>以 CMS 为例</li><li>先尝试不做调优，如果没有 Full GC 那么已经…，否则先尝试调优新生代</li><li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1&#x2F;4 ~ 1&#x2F;3<ul><li>-XX:CMSInitiatingOccupancyFraction&#x3D;percent</li></ul></li></ul><h3 id="5-6-案例"><a href="#5-6-案例" class="headerlink" title="5.6 案例"></a>5.6 案例</h3><hr><ul><li>案例1 Full GC 和 Minor GC频繁</li><li>案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）</li><li>案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）</li></ul>]]></content:encoded>
      
      
      <category domain="https://HoldusTogether.github.io/categories/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/categories/Java/JVM/">JVM</category>
      
      
      <category domain="https://HoldusTogether.github.io/tags/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/tags/JVM/">JVM</category>
      
      
      <comments>https://holdustogether.github.io/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JVM内存结构</title>
      <link>https://holdustogether.github.io/2022/08/22/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</link>
      <guid>https://holdustogether.github.io/2022/08/22/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</guid>
      <pubDate>Mon, 22 Aug 2022 01:09:55 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-202208</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822091326221.png" alt="image-20220822091326221"></p><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h2><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822091419608.png" alt="image-20220822091419608"></p><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a><strong>1.1 定义</strong></h3><hr><p>Program Counter Register 程序计数器（寄存器）</p><ul><li>作用——是记住下一条jvm指令的执行地址</li><li>特点<ul><li>线程私有</li><li>不会存在内存溢出</li></ul></li></ul><h3 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h3><hr><p>记录下一跳在哪</p><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822091643388.png" alt="image-20220822091643388"></p><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h2><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822091746461.png" alt="image-20220822091746461"></p><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><hr><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><ul><li>每个线程运行时所需要的内存，称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><p>问题辨析：</p><ol><li><p>垃圾回收是否涉及栈内存？</p><p>不涉及，垃圾回收只是在堆内存</p></li><li><p>栈内存分配越大越好吗？</p><p>栈内存变大，会让线程数变少，因为物理内存大小一定</p></li><li><p>方法内的局部变量是否线程安全？</p><ul><li>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的。<strong>只被该方法改变</strong></li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li></ul></li></ol><h3 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h3><hr><ul><li>栈帧过多导致栈内存溢出</li><li>栈帧过大导致栈内存溢出</li></ul><h3 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h3><hr><p>案例1： cpu 占用过多</p><p>定位：</p><ul><li>用top定位哪个进程对cpu的占用过高</li><li>ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高）</li><li>jstack 进程id<ul><li>可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号</li></ul></li></ul><p>案例2：程序运行很长时间没有结果</p><ul><li>可能发生了线程死锁</li></ul><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h2><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822094040781.png" alt="image-20220822094040781"></p><p>一些底层的别的语言c语言等编写的方法</p><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h2><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822094149113.png" alt="image-20220822094149113"></p><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><hr><p>Heap 堆</p><ul><li>通过 new 关键字，创建对象都会使用堆内存</li></ul><p>特点</p><ul><li>它是线程共享的，堆中对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul><h3 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2 堆内存溢出"></a>4.2 堆内存溢出</h3><hr><p>OutOfMemoryError： Java heap space</p><h3 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3 堆内存诊断"></a>4.3 堆内存诊断</h3><hr><ol><li><p>jps 工具</p><ul><li>查看当前系统中有哪些 java 进程</li></ul></li><li><p>jmap 工具</p><ul><li>查看堆内存占用情况 jmap - heap 进程id</li></ul></li><li><p>jconsole 工具</p></li></ol><ul><li>图形界面的，多功能的监测工具，可以连续监测</li></ul><p>案例：</p><ul><li>垃圾回收后，内存占用仍然很高<ul><li>强引用</li></ul></li></ul><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822095410619.png" alt="image-20220822095410619"></p><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><hr><p> Java虚拟机中有一个被所有jvm线程共享的方法区。方法区有点类似于传统编程语言中的编译代码块或者操作系统层面的代码段。它存储着每个类的构造信息，譬如运行时的常量池，字段，方法数据，以及方法和构造方法的代码，包括一些在类和实例初始化和接口初始化时候使用的特殊方法。</p><p>方法区在jvm启动时候被创建。虽然方法区在逻辑层面上是堆的一部分，但是就简单实现来说既不会被回收也不会被压缩。这个规范并不强制指定方法区存放的位置也不会对编译过的代码有管理策略的限制。方法区可能有一个固定的大小或者也可以通过计算大小去扩展也可以在不需要的时候被压缩。方法区的内存也不需要是连续的。</p><p>Jvm虚拟机实现可以提供给编程人员或者用户初始化方法区的大小，同时在方法区可变大小的情况下，控制这个方法区的最大值和最小值。</p><p>如果方法区满足不了构造所需要的内存，jvm就会抛出OutOfMemoryError。</p><h3 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成"></a>5.2 组成</h3><hr><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822095752859.png" alt="image-20220822095752859"></p><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822095801877.png" alt="image-20220822095801877"></p><h3 id="5-3-方法区内存溢出"><a href="#5-3-方法区内存溢出" class="headerlink" title="5.3 方法区内存溢出"></a>5.3 方法区内存溢出</h3><hr><ul><li><p>1.8 以前会导致永久代内存溢出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 演示永久代内存溢出 java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">* -XX:MaxPermSize=8m</span><br></pre></td></tr></table></figure></li><li><p>1.8 之后会导致元空间内存溢出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">* -XX:MaxMetaspaceSize=8m</span><br></pre></td></tr></table></figure></li></ul><p>场景：</p><ul><li>spring</li><li>mybatis</li></ul><h3 id="5-4-运行时常量池"><a href="#5-4-运行时常量池" class="headerlink" title="5.4 运行时常量池"></a>5.4 运行时常量池</h3><hr><ul><li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量 等信息</li><li>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量 池，并把里面的符号地址变为真实地址</li></ul><h3 id="5-5-StringTable"><a href="#5-5-StringTable" class="headerlink" title="5.5 StringTable"></a>5.5 StringTable</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s4.intern();</span><br><span class="line"><span class="comment">// 问</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s5); <span class="comment">// true</span></span><br><span class="line">System.out.println(s3 == s6); <span class="comment">// true</span></span><br><span class="line"><span class="type">String</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">x2.intern();</span><br><span class="line"><span class="comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢</span></span><br><span class="line">System.out.println(x1 == x2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="5-5-StringTable-特性"><a href="#5-5-StringTable-特性" class="headerlink" title="5.5 StringTable 特性"></a>5.5 StringTable 特性</h3><hr><ul><li>常量池中的字符串仅是符号，第一次用到时才变为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是 StringBuilder （1.8）</li><li>字符串常量拼接的原理是编译期优化</li><li>可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池<ul><li>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串 池中的对象返回</li><li>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串 池中的对象返回</li></ul></li></ul><h3 id="5-6-StringTable-位置"><a href="#5-6-StringTable-位置" class="headerlink" title="5.6 StringTable 位置"></a>5.6 StringTable 位置</h3><hr><p>1.6在永久代 常量池里</p><p>1.7 1.8 在堆内存中</p><ul><li>为什么转移？<ul><li>永久代内存回收效率很低，需要Full GC的时候才会回收 也就是等到老年代空间不足的时候才会触发-间接导致串池回收效率不高-因为串池使用非常频繁，如果回收效率不高就占用大量永久代内存容易产生永久代内存不足。</li><li>到堆内存中后 只需要mGC就会触发回收，减轻了串池对内存的占用</li></ul></li></ul><h3 id="5-7-StringTable-垃圾回收"><a href="#5-7-StringTable-垃圾回收" class="headerlink" title="5.7 StringTable 垃圾回收"></a>5.7 StringTable 垃圾回收</h3><hr><ul><li>串池是用哈希表实现的。桶的个数决定效率</li><li>mGC</li></ul><h3 id="5-8-StringTable-性能调优"><a href="#5-8-StringTable-性能调优" class="headerlink" title="5.8 StringTable 性能调优"></a>5.8 StringTable 性能调优</h3><hr><ul><li>调整 -XX:StringTableSize&#x3D;桶个数</li><li>考虑将字符串对象是否入池</li></ul><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h2><h3 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h3><hr><p>Direct Memory</p><ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li></ul><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822103422838.png" alt="image-20220822103422838"></p><h3 id="6-2-分配和回收原理"><a href="#6-2-分配和回收原理" class="headerlink" title="6.2 分配和回收原理"></a>6.2 分配和回收原理</h3><hr><ul><li>使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法</li><li>ByteBuffer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuffer 对象，一旦 ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调 用 freeMemory 来释放直接内存</li></ul>]]></content:encoded>
      
      
      <category domain="https://HoldusTogether.github.io/categories/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/categories/Java/JVM/">JVM</category>
      
      
      <category domain="https://HoldusTogether.github.io/tags/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/tags/JVM/">JVM</category>
      
      
      <comments>https://holdustogether.github.io/2022/08/22/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我想和你虚度时光</title>
      <link>https://holdustogether.github.io/2022/08/22/%E9%9A%8F%E7%AC%94/</link>
      <guid>https://holdustogether.github.io/2022/08/22/%E9%9A%8F%E7%AC%94/</guid>
      <pubDate>Mon, 22 Aug 2022 00:56:59 GMT</pubDate>
      
      
      
      
      <category domain="https://HoldusTogether.github.io/categories/%E6%96%87%E5%AD%A6/">文学</category>
      
      <category domain="https://HoldusTogether.github.io/categories/%E6%96%87%E5%AD%A6/%E6%91%98%E5%BD%95/">摘录</category>
      
      
      <category domain="https://HoldusTogether.github.io/tags/%E6%96%87%E5%AD%A6/">文学</category>
      
      <category domain="https://HoldusTogether.github.io/tags/%E6%96%87%E5%AD%97/">文字</category>
      
      
      <comments>https://holdustogether.github.io/2022/08/22/%E9%9A%8F%E7%AC%94/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JVM概述</title>
      <link>https://holdustogether.github.io/2022/08/21/JVM%E6%A6%82%E8%BF%B0/</link>
      <guid>https://holdustogether.github.io/2022/08/21/JVM%E6%A6%82%E8%BF%B0/</guid>
      <pubDate>Sun, 21 Aug 2022 13:50:26 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;什么是-JVM&quot;&gt;&lt;a href=&quot;#什么是-JVM&quot; class=&quot;headerlink&quot; title=&quot;什么是 JVM ?&quot;&gt;&lt;/a&gt;什么是 JVM ?&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java Virtual</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM ?"></a>什么是 JVM ?</h2><p><strong>定义：</strong></p><ul><li>Java Virtual Machine - java 程序的运行环境（java 二进制字节码的运行环境）</li></ul><p><strong>好处：</strong></p><ul><li>一次编写，到处运行·</li><li>自动内存管理，垃圾回收功能</li><li>数组下标越界检查</li><li>多态</li></ul><p><strong>比较：</strong></p><ul><li>jvm与jre、jdk</li><li>jvm是最底层，其次被jre包含，jre被jdkbaoh</li></ul><h2 id="学习-JVM-有什么用"><a href="#学习-JVM-有什么用" class="headerlink" title="学习 JVM 有什么用 ?"></a>学习 JVM 有什么用 ?</h2><ul><li>面试</li><li>理解底层的实现原理</li><li>程序员进阶技能</li></ul><h2 id="常见的-JVM"><a href="#常见的-JVM" class="headerlink" title="常见的 JVM"></a>常见的 JVM</h2><p><img src="/2022/08/21/JVM%E6%A6%82%E8%BF%B0/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220821214940771.png" alt="image-20220821214940771"></p><h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p><img src="/2022/08/21/JVM%E6%A6%82%E8%BF%B0/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220821215002328.png" alt="image-20220821215002328"></p>]]></content:encoded>
      
      
      <category domain="https://HoldusTogether.github.io/categories/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/categories/Java/JVM/">JVM</category>
      
      
      <category domain="https://HoldusTogether.github.io/tags/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/tags/Jvm/">Jvm</category>
      
      
      <comments>https://holdustogether.github.io/2022/08/21/JVM%E6%A6%82%E8%BF%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://holdustogether.github.io/2022/08/20/hello-world/</link>
      <guid>https://holdustogether.github.io/2022/08/20/hello-world/</guid>
      <pubDate>Sat, 20 Aug 2022 02:50:06 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</description>
        
      
      
      
      <content:encoded><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content:encoded>
      
      
      
      
      <comments>https://holdustogether.github.io/2022/08/20/hello-world/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
