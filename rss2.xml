<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>南北橘子</title>
    <link>https://HoldusTogether.github.io/</link>
    
    <atom:link href="https://holdustogether.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>不要停止成为更好的自己</description>
    <pubDate>Tue, 20 Sep 2022 03:38:21 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>面试技巧</title>
      <link>https://holdustogether.github.io/2022/09/12/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/</link>
      <guid>https://holdustogether.github.io/2022/09/12/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/</guid>
      <pubDate>Mon, 12 Sep 2022 09:09:48 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;产品&quot;&gt;&lt;a href=&quot;#产品&quot; class=&quot;headerlink&quot; title=&quot;产品&quot;&gt;&lt;/a&gt;产品&lt;/h1&gt;&lt;h2 id=&quot;目标驱动&quot;&gt;&lt;a href=&quot;#目标驱动&quot; class=&quot;headerlink&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h1 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h1><h2 id="目标驱动"><a href="#目标驱动" class="headerlink" title="目标驱动"></a>目标驱动</h2><h2 id="不要被周围影响"><a href="#不要被周围影响" class="headerlink" title="不要被周围影响"></a>不要被周围影响</h2><h2 id="做好自己"><a href="#做好自己" class="headerlink" title="做好自己"></a>做好自己</h2><h2 id="鼓励"><a href="#鼓励" class="headerlink" title="鼓励"></a>鼓励</h2><h1 id="软开"><a href="#软开" class="headerlink" title="软开"></a>软开</h1><h2 id="项目里给面试官埋点"><a href="#项目里给面试官埋点" class="headerlink" title="项目里给面试官埋点"></a>项目里给面试官埋点</h2><h2 id="引导面试官"><a href="#引导面试官" class="headerlink" title="引导面试官"></a>引导面试官</h2><h2 id="小公司问项目框架"><a href="#小公司问项目框架" class="headerlink" title="小公司问项目框架"></a>小公司问项目框架</h2><h2 id="大公司问基础"><a href="#大公司问基础" class="headerlink" title="大公司问基础"></a>大公司问基础</h2><h2 id="Javase-jvm-juc-redis-mq-数据库"><a href="#Javase-jvm-juc-redis-mq-数据库" class="headerlink" title="Javase jvm juc redis mq 数据库"></a>Javase jvm juc redis mq 数据库</h2><h2 id="操作系统-计网背面经-牛客"><a href="#操作系统-计网背面经-牛客" class="headerlink" title="操作系统 计网背面经 牛客"></a>操作系统 计网背面经 牛客</h2><h2 id="offer不要据-薪资升级"><a href="#offer不要据-薪资升级" class="headerlink" title="offer不要据 薪资升级"></a>offer不要据 薪资升级</h2><h2 id="不怕忘-怕忘了不回顾"><a href="#不怕忘-怕忘了不回顾" class="headerlink" title="不怕忘 怕忘了不回顾"></a>不怕忘 怕忘了不回顾</h2><h1 id="9-16面试分享"><a href="#9-16面试分享" class="headerlink" title="9.16面试分享"></a>9.16面试分享</h1><h2 id="小厂"><a href="#小厂" class="headerlink" title="小厂"></a>小厂</h2><h3 id="HR面软问题是第一面"><a href="#HR面软问题是第一面" class="headerlink" title="HR面软问题是第一面"></a>HR面软问题是第一面</h3><h3 id="然后是技术面"><a href="#然后是技术面" class="headerlink" title="然后是技术面"></a>然后是技术面</h3><h2 id="中厂"><a href="#中厂" class="headerlink" title="中厂"></a>中厂</h2><h3 id="测评笔试面试2-3轮技术"><a href="#测评笔试面试2-3轮技术" class="headerlink" title="测评笔试面试2-3轮技术"></a>测评笔试面试2-3轮技术</h3><h2 id="大厂"><a href="#大厂" class="headerlink" title="大厂"></a>大厂</h2><h3 id="测评笔试面试4-5轮"><a href="#测评笔试面试4-5轮" class="headerlink" title="测评笔试面试4-5轮"></a>测评笔试面试4-5轮</h3><h2 id="介绍项目"><a href="#介绍项目" class="headerlink" title="介绍项目"></a>介绍项目</h2><h3 id="讲讲你的项目特色"><a href="#讲讲你的项目特色" class="headerlink" title="讲讲你的项目特色"></a>讲讲你的项目特色</h3><h3 id="提前准备项目的比较"><a href="#提前准备项目的比较" class="headerlink" title="提前准备项目的比较"></a>提前准备项目的比较</h3><h3 id="八股文-小浅大深"><a href="#八股文-小浅大深" class="headerlink" title="八股文 小浅大深"></a>八股文 小浅大深</h3><h3 id="介绍你熟的知识点-深挖你熟的知识点"><a href="#介绍你熟的知识点-深挖你熟的知识点" class="headerlink" title="介绍你熟的知识点 深挖你熟的知识点"></a>介绍你熟的知识点 深挖你熟的知识点</h3><h3 id="全流程的解读-小厂问机制-大厂问源码"><a href="#全流程的解读-小厂问机制-大厂问源码" class="headerlink" title="全流程的解读 小厂问机制 大厂问源码"></a>全流程的解读 小厂问机制 大厂问源码</h3><h3 id="算法手撕-或者口诉-用到的类与思想-递归的二叉树"><a href="#算法手撕-或者口诉-用到的类与思想-递归的二叉树" class="headerlink" title="算法手撕 或者口诉 用到的类与思想 递归的二叉树"></a>算法手撕 或者口诉 用到的类与思想 递归的二叉树</h3><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><h3 id="自我介绍-项目特点-90秒"><a href="#自我介绍-项目特点-90秒" class="headerlink" title="自我介绍 项目特点 90秒"></a>自我介绍 项目特点 90秒</h3><h3 id="介绍项目-感兴趣的点-会深入问-并发量-性能优化-缓存处理"><a href="#介绍项目-感兴趣的点-会深入问-并发量-性能优化-缓存处理" class="headerlink" title="介绍项目 感兴趣的点 会深入问 并发量 性能优化 缓存处理"></a>介绍项目 感兴趣的点 会深入问 并发量 性能优化 缓存处理</h3><h3 id="八股-全栈知识手册-小林coding-大黑书"><a href="#八股-全栈知识手册-小林coding-大黑书" class="headerlink" title="八股 全栈知识手册  小林coding 大黑书"></a>八股 全栈知识手册  小林coding 大黑书</h3><h3 id="算法牛客小题-代码随想录-牛客100-剑指offer"><a href="#算法牛客小题-代码随想录-牛客100-剑指offer" class="headerlink" title="算法牛客小题 代码随想录 牛客100 剑指offer"></a>算法牛客小题 代码随想录 牛客100 剑指offer</h3><h3 id="dp-动态规划-做慢一点-手撕的时候写测试用例-提交的时候不要出bug"><a href="#dp-动态规划-做慢一点-手撕的时候写测试用例-提交的时候不要出bug" class="headerlink" title="dp 动态规划 做慢一点 手撕的时候写测试用例 提交的时候不要出bug"></a>dp 动态规划 做慢一点 手撕的时候写测试用例 提交的时候不要出bug</h3><h3 id="摄像头抓拍-复盘笔试题"><a href="#摄像头抓拍-复盘笔试题" class="headerlink" title="摄像头抓拍 复盘笔试题"></a>摄像头抓拍 复盘笔试题</h3><h3 id="常用技术网站网址"><a href="#常用技术网站网址" class="headerlink" title="常用技术网站网址"></a>常用技术网站网址</h3><p><a href="https://xiaolincoding.com/">https://xiaolincoding.com/</a> 小林coding</p><p><a href="https://juejin.cn/">https://juejin.cn/</a> 掘金</p><h3 id="协程实现的区别-go和Java"><a href="#协程实现的区别-go和Java" class="headerlink" title="协程实现的区别 go和Java"></a>协程实现的区别 go和Java</h3><h3 id="零拷贝-IO多路复用-系统中断-用户态内核态的切换-pull-epull"><a href="#零拷贝-IO多路复用-系统中断-用户态内核态的切换-pull-epull" class="headerlink" title="零拷贝 IO多路复用 系统中断 用户态内核态的切换 pull epull"></a>零拷贝 IO多路复用 系统中断 用户态内核态的切换 pull epull</h3><h3 id="项目拓展-redis做缓存-消息异步处理-并发"><a href="#项目拓展-redis做缓存-消息异步处理-并发" class="headerlink" title="项目拓展 redis做缓存 消息异步处理 并发"></a>项目拓展 redis做缓存 消息异步处理 并发</h3><h3 id="IOC-AOP-Spring-读取配置文件-源码-自动装配"><a href="#IOC-AOP-Spring-读取配置文件-源码-自动装配" class="headerlink" title="IOC AOP Spring 读取配置文件 源码 自动装配"></a>IOC AOP Spring 读取配置文件 源码 自动装配</h3><h3 id="Java基础-hashmap-1-71-8优化-深-为什么不直接用红黑树节点当链表节点"><a href="#Java基础-hashmap-1-71-8优化-深-为什么不直接用红黑树节点当链表节点" class="headerlink" title="Java基础 hashmap 1.71.8优化 深 为什么不直接用红黑树节点当链表节点"></a>Java基础 hashmap 1.71.8优化 深 为什么不直接用红黑树节点当链表节点</h3><h3 id="八股-线程池-参数-使用流程-索引优化-spring-Java三大特性-抽象类和接口的区别"><a href="#八股-线程池-参数-使用流程-索引优化-spring-Java三大特性-抽象类和接口的区别" class="headerlink" title="八股 线程池 参数 使用流程 索引优化 spring Java三大特性 抽象类和接口的区别"></a>八股 线程池 参数 使用流程 索引优化 spring Java三大特性 抽象类和接口的区别</h3><h3 id="去面经里看题单-看看不熟悉的"><a href="#去面经里看题单-看看不熟悉的" class="headerlink" title="去面经里看题单 看看不熟悉的"></a>去面经里看题单 看看不熟悉的</h3><h3 id="算法口述-二叉树深度-dfs-bfs为什么用队列-出队入队-递归终止的条件-递归的内容"><a href="#算法口述-二叉树深度-dfs-bfs为什么用队列-出队入队-递归终止的条件-递归的内容" class="headerlink" title="算法口述 二叉树深度 dfs bfs为什么用队列 出队入队 递归终止的条件 递归的内容"></a>算法口述 二叉树深度 dfs bfs为什么用队列 出队入队 递归终止的条件 递归的内容</h3><h3 id="极客时间-看看好文章"><a href="#极客时间-看看好文章" class="headerlink" title="极客时间 看看好文章"></a>极客时间 看看好文章</h3><h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><h3 id="海量数据"><a href="#海量数据" class="headerlink" title="海量数据"></a>海量数据</h3>]]></content:encoded>
      
      
      <category domain="https://HoldusTogether.github.io/categories/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/categories/Java/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/">面试技巧</category>
      
      
      <category domain="https://HoldusTogether.github.io/tags/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/tags/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/">面试技巧</category>
      
      
      <comments>https://holdustogether.github.io/2022/09/12/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring Cloud</title>
      <link>https://holdustogether.github.io/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
      <guid>https://holdustogether.github.io/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/</guid>
      <pubDate>Sun, 11 Sep 2022 02:36:21 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;常见面试题&quot;&gt;&lt;a href=&quot;#常见面试题&quot; class=&quot;headerlink&quot; title=&quot;常见面试题&quot;&gt;&lt;/a&gt;常见面试题&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是微服务？&quot;&gt;&lt;a href=&quot;#1-1-什</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="1-1-什么是微服务？"><a href="#1-1-什么是微服务？" class="headerlink" title="1.1 什么是微服务？"></a>1.1 什么是微服务？</h3><blockquote><p>对于微服务，业界并没有一个统一的，标准的定义。</p><p>微服务架构是一种架构模式，或者说是一种架构风格，将单一的应用程序划分成一组小的服务，每个服务运行在其独立的自己的进程内，服务之间采用轻量级的通信机制（HTTP）相互沟通，互相协调，为用户提供价值。</p><p>微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情。</p></blockquote><h3 id="2-2-微服务与微服务架构"><a href="#2-2-微服务与微服务架构" class="headerlink" title="2.2 微服务与微服务架构"></a>2.2 微服务与微服务架构</h3><blockquote><p>微服务</p><p>强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题&#x2F;提供落地对应服务的一个服务应用，狭义的看，可以看作是IDEA中的一个个微服务工程，或者Moudel。强调的是一个个的个体，每个个体完成一个具体的任务或者功能。</p><p>微服务架构</p><p>一种新的架构形式，Martin Fowler 于2014年提出。</p><p>微服务架构是一种架构模式，它体长将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。</p></blockquote><h3 id="2-3-微服务优缺点"><a href="#2-3-微服务优缺点" class="headerlink" title="2.3 微服务优缺点"></a>2.3 微服务优缺点</h3><blockquote><p>优点：</p><ul><li>单一职责</li><li>每个服务足够小，足够内聚，处理指定的业务功能</li><li>开发简单效率高</li><li>松耦合</li><li><strong>每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库；</strong></li></ul><p>缺点：</p><ul><li>开发人员要处理分布式系统的复杂性；</li><li>系统部署依赖问题；</li><li>服务间通信成本问题；</li><li>数据一致性问题；</li></ul></blockquote><h2 id="Eureka-Spring-Cloud服务注册与发现组件"><a href="#Eureka-Spring-Cloud服务注册与发现组件" class="headerlink" title="Eureka Spring Cloud服务注册与发现组件"></a>Eureka Spring Cloud服务注册与发现组件</h2><h3 id="1-Eureka-两大组件"><a href="#1-Eureka-两大组件" class="headerlink" title="1.Eureka 两大组件"></a>1.Eureka 两大组件</h3><p>​<strong>CS架构</strong></p><ul><li><strong>Eureka Server</strong>：Eureka 服务注册中心，主要用于提供服务注册功能。当微服务启动时，会将自己的服务注册到 Eureka Server。Eureka Server 维护了一个可用服务列表，存储了所有注册到 Eureka Server 的可用服务的信息，这些可用服务可以在 Eureka Server 的管理界面中直观看到。</li><li><strong>Eureka Client</strong>：Eureka 客户端，通常指的是微服务系统中各个微服务，主要用于和 Eureka Server 进行交互。在微服务应用启动后，Eureka Client 会向 Eureka Server 发送心跳（默认周期为 30 秒）。若 Eureka Server 在多个心跳周期内没有接收到某个 Eureka Client 的心跳，Eureka Server 将它从可用服务列表中移除（默认 90 秒）。 </li><li>![image-20220911120302056](Spring Cloud 微服务.assets&#x2F;image-20220911120302056.png)</li></ul><hr><ol><li><p>服务端导包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--为服务注册中心引入 Eureka Server 的依赖--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>服务端配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span>  <span class="comment">#该 Module 的端口号</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment">#eureka服务端的实例名称，</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#false表示不向注册中心注册自己。</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span> <span class="comment">#单机版服务注册中心</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>主类加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">//开启 Eureka server,接受其他微服务的注册</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudEureka7001Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudEureka7001Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><hr><ol><li><p>服务提供端导包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入 Eureka Client 的依赖，将服务注册到 Eureka Server--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>服务提供端配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span> <span class="comment">#服务端口号</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">microServiceCloudProviderDept</span>  <span class="comment">#微服务名称，对外暴漏的微服务名称，十分重要</span></span><br><span class="line"><span class="comment">################################################## JDBC 通用配置  ##########################################</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span>        <span class="comment">#数据库登陆用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span>        <span class="comment">#数据库登陆密码</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/bianchengbang_jdbc</span>       <span class="comment">#数据库url</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span>                  <span class="comment">#数据库驱动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################### 不检查 spring.config.import=configserver:##################</span></span><br><span class="line"><span class="comment">#  cloud:</span></span><br><span class="line"><span class="comment">#    config:</span></span><br><span class="line"><span class="comment">#      enabled: false</span></span><br><span class="line"><span class="comment">###################################### MyBatis 配置 ######################################</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment"># 指定 mapper.xml 的位置</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span></span><br><span class="line">  <span class="comment">#扫描实体类的位置,在此处指明扫描实体类的包，在 mapper.xml 中就可以不写实体类的全路径名</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">net.biancheng.c.entity</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#默认开启驼峰命名法，可以不用设置该属性</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">########################################### Spring cloud 自定义服务名称和 ip 地址###############################################</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#将客户端注册到 eureka 服务列表内</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span>  <span class="comment">#这个地址是 7001注册中心在 application.yml 中暴露出来额注册地址 （单机版）</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">spring-cloud-provider-8001</span> <span class="comment">#自定义服务名称信息</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>  <span class="comment">#显示访问路径的 ip 地址</span></span><br><span class="line"><span class="comment">########################################## spring cloud 使用 Spring Boot actuator 监控完善信息###################################</span></span><br><span class="line"><span class="comment"># Spring Boot 2.50对 actuator 监控屏蔽了大多数的节点，只暴露了 heath 节点，本段配置（*）就是为了开启所有的节点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span>   <span class="comment"># * 在yaml 文件属于关键字，所以需要加引号</span></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app.name:</span> <span class="string">micro-service-cloud-provider-dept</span></span><br><span class="line">  <span class="attr">company.name:</span> <span class="string">c.biancheng.net</span></span><br><span class="line">  <span class="attr">build.aetifactId:</span> <span class="string">@project.artifactId@</span></span><br><span class="line">  <span class="attr">build.version:</span> <span class="string">@project.version@</span></span><br></pre></td></tr></table></figure></li><li><p>服务端启动类注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">// Spring cloud Eureka 客户端，自动将本服务注册到 Eureka Server 注册中心中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudProviderDept8001Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudProviderDept8001Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="2-Eureka-Server-集群"><a href="#2-Eureka-Server-集群" class="headerlink" title="2.Eureka Server 集群"></a>2.Eureka Server 集群</h3><blockquote><p>在微服务架构中，一个系统往往由十几甚至几十个服务组成，若将这些服务全部注册到同一个 Eureka Server 中，就极有可能导致 Eureka Server 因不堪重负而崩溃，最终导致整个系统瘫痪。解决这个问题最直接的办法就是部署 Eureka Server 集群。 保证高可用</p><p>我们知道，在 Eureka 实现服务注册与发现时一共涉及了 3 个角色：服务注册中心、服务提供者以及服务消费者，这三个角色分工明确，各司其职。但是其实在 Eureka 中，所有服务都既是服务消费者也是服务提供者，服务注册中心 Eureka Server 也不例外。</p><p>举个例子，有两个 Eureka Server 分别为 A 和 B，虽然 A 不能将自己注册到 A 上，B 也不能将自己注册到 B 上，但 A 是可以作为一个服务把自己注册到 B 上的，同理 B 也可以将自己注册到 A 上。</p><p>这样就可以形成一组互相注册的 Eureka Server 集群，当服务提供者发送注册请求到 Eureka Server 时，Eureka Server 会将请求转发给集群中所有与之相连的 Eureka Server 上，以实现 Eureka Server 之间的服务同步。</p><p>通过服务同步，服务消费者可以在集群中的任意一台 Eureka Server 上获取服务提供者提供的服务。这样，即使集群中的某个服务注册中心发生故障，服务消费者仍然可以从集群中的其他 Eureka Server 中获取服务信息并调用，而不会导致系统的整体瘫痪，这就是 Eureka Server 集群的高可用性。</p></blockquote><hr><h3 id="3-Eureka-自我保护机制"><a href="#3-Eureka-自我保护机制" class="headerlink" title="3.Eureka 自我保护机制"></a>3.Eureka 自我保护机制</h3><blockquote><p>实际上，这个警告是触发了 Eureka 的自我保护机制而出现的。默认情况下，如果 Eureka Server 在一段时间内（默认为 90 秒）没有接收到某个服务提供者（Eureka Client）的心跳，就会将这个服务提供者提供的服务从服务注册表中移除。 这样服务消费者就再也无法从服务注册中心中获取到这个服务了，更无法调用该服务。</p><p>但在实际的分布式微服务系统中，健康的服务（Eureka Client）也有可能会由于网络故障（例如网络延迟、卡顿、拥挤等原因）而无法与 Eureka Server 正常通讯。若此时 Eureka Server 因为没有接收心跳而误将健康的服务从服务列表中移除，这显然是不合理的。而 Eureka 的自我保护机制就是来解决此问题的。</p><p>所谓 “Eureka 的自我保护机制”，其中心思想就是“好死不如赖活着”。如果 Eureka Server 在一段时间内没有接收到 Eureka Client 的心跳，那么 Eureka Server 就会开启自我保护模式，将所有的 Eureka Client 的注册信息保护起来，而不是直接从服务注册表中移除。一旦网络恢复，这些 Eureka Client 提供的服务还可以继续被服务消费者消费。</p><p>综上，Eureka 的自我保护机制是一种应对网络异常的安全保护措施。它的架构哲学是：宁可同时保留所有微服务（健康的服务和不健康的服务都会保留）也不盲目移除任何健康的服务。通过 Eureka 的自我保护机制，可以让 Eureka Server 集群更加的健壮、稳定。</p><p>Eureka 的自我保护机制也存在弊端。如果在 Eureka 自我保护机制触发期间，服务提供者提供的服务出现问题，那么服务消费者就很容易获取到已经不存在的服务进而出现调用失败的情况，此时，我们可以通过客户端的容错机制来解决此问题，详情请参考 <a href="http://c.biancheng.net/springcloud/ribbon.html">Spring Cloud Netflix Ribbon</a> 和 <a href="http://c.biancheng.net/springcloud/hystrix.html">Spring Cloud Netflix Hystrix</a>。</p></blockquote><h2 id="Ribbon：Spring-Cloud负载均衡与服务调用组件"><a href="#Ribbon：Spring-Cloud负载均衡与服务调用组件" class="headerlink" title="Ribbon：Spring Cloud负载均衡与服务调用组件"></a>Ribbon：Spring Cloud负载均衡与服务调用组件</h2><h3 id="1-什么是Ribbon"><a href="#1-什么是Ribbon" class="headerlink" title="1. 什么是Ribbon"></a>1. 什么是Ribbon</h3><pre><code>&gt; Ribbon 是 Spring Cloud Netflix 模块的子模块，它是 Spring Cloud 对 Netflix Ribbon 的二次封装。通过它，我们可以将面向服务的 REST 模板（RestTemplate）请求转换为客户端负载均衡的服务调用。&gt;&gt; Ribbon 是 Spring Cloud 体系中最核心、最重要的组件之一。它虽然只是一个工具类型的框架，并不像 Eureka Server（服务注册中心）那样需要独立部署，但它几乎存在于每一个使用 Spring Cloud 构建的微服务中。&gt;&gt; Spring Cloud 微服务之间的调用，API 网关的请求转发等内容，实际上都是通过 Spring Cloud Ribbon 来实现的，包括后续我们要介绍的 [OpenFeign](http://c.biancheng.net/springcloud/open-feign.html) 也是基于它实现的。</code></pre><h3 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2.负载均衡"></a>2.负载均衡</h3><blockquote><p>负载均衡（Load Balance） ，简单点说就是将用户的请求平摊分配到多个服务器上运行，以达到扩展服务器带宽、增强数据处理能力、增加吞吐量、提高网络的可用性和灵活性的目的。</p></blockquote><p>常见的负载均衡方式: (其实就是判断在客户端发送请求前负载均衡还是后负载均衡)</p><ul><li>服务端负载均衡(服务端负责均衡就是客户端发送请求后进行的)</li><li>客户端负载均衡(就是客户端发送请求前进行负载均衡)</li></ul><h4 id="服务端负载均衡"><a href="#服务端负载均衡" class="headerlink" title="服务端负载均衡"></a>服务端负载均衡</h4><p>![image-20220911160533799](Spring Cloud 微服务.assets&#x2F;image-20220911160533799.png)</p><p>服务端负载均衡是在客户端和服务端之间建立一个独立的负载均衡服务器，该服务器既可以是硬件设备（例如 F5），也可以是软件（例如 Nginx）。这个负载均衡服务器维护了一份可用服务端清单，然后通过心跳机制来删除故障的服务端节点，以保证清单中的所有服务节点都是可以正常访问的。</p><p>当客户端发送请求时，该请求不会直接发送到服务端进行处理，而是全部交给负载均衡服务器，由负载均衡服务器按照某种算法（例如轮询、随机等），从其维护的可用服务清单中选择一个服务端，然后进行转发。</p><p>服务端负载均衡具有以下特点：</p><ul><li>需要建立一个独立的负载均衡服务器。</li><li>负载均衡是在客户端发送请求后进行的，因此客户端并不知道到底是哪个服务端提供的服务。</li><li>可用服务端清单存储在负载均衡服务器上。</li></ul><h4 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h4><p>![image-20220911160747167](Spring Cloud 微服务.assets&#x2F;image-20220911160747167.png)</p><p>客户端负载均衡是将负载均衡逻辑以代码的形式封装到客户端上，即负载均衡器位于客户端。客户端通过服务注册中心（例如 Eureka Server）获取到一份服务端提供的可用服务清单。有了服务清单后，负载均衡器会在客户端发送请求前通过负载均衡算法选择一个服务端实例再进行访问，以达到负载均衡的目的；</p><p>客户端负载均衡也需要心跳机制去维护服务端清单的有效性，这个过程需要配合服务注册中心一起完成。</p><p>客户端负载均衡具有以下特点：</p><ul><li>负载均衡器位于客户端，不需要单独搭建一个负载均衡服务器。</li><li>负载均衡是在客户端发送请求前进行的，因此客户端清楚地知道是哪个服务端提供的服务。</li><li>客户端都维护了一份可用服务清单，而这份清单都是从服务注册中心获取的。</li></ul><p>Ribbon 就是一个基于 HTTP 和 TCP 的客户端负载均衡器，当我们将 Ribbon 和 Eureka 一起使用时，Ribbon 会从 Eureka Server（服务注册中心）中获取服务端列表，然后通过负载均衡策略将请求分摊给多个服务提供者，从而达到负载均衡的目的。</p><h4 id="服务端负载均衡-VS-客户端负载均衡"><a href="#服务端负载均衡-VS-客户端负载均衡" class="headerlink" title="服务端负载均衡 VS 客户端负载均衡"></a>服务端负载均衡 VS 客户端负载均衡</h4><table><thead><tr><th>不同点</th><th>服务端负载均衡</th><th>客户端负载均衡</th></tr></thead><tbody><tr><td>是否需要建立负载均衡服务器</td><td>需要在客户端和服务端之间建立一个独立的负载均衡服务器。</td><td>将负载均衡的逻辑以代码的形式封装到客户端上，因此不需要单独建立负载均衡服务器。</td></tr><tr><td>是否需要服务注册中心</td><td>不需要服务注册中心。</td><td>需要服务注册中心。  在客户端负载均衡中，所有的客户端和服务端都需要将其提供的服务注册到服务注册中心上。</td></tr><tr><td>可用服务清单存储的位置</td><td>可用服务清单存储在位于客户端与服务器之间的负载均衡服务器上。</td><td>所有的客户端都维护了一份可用服务清单，这些清单都是从服务注册中心获取的。</td></tr><tr><td>负载均衡的时机</td><td>先将请求发送到负载均衡服务器，然后由负载均衡服务器通过负载均衡算法，在多个服务端之间选择一个进行访问；即在服务器端再进行负载均衡算法分配。  简单点说就是，先发送请求，再进行负载均衡。</td><td>在发送请求前，由位于客户端的服务负载均衡器（例如 Ribbon）通过负载均衡算法选择一个服务器，然后进行访问。  简单点说就是，先进行负载均衡，再发送请求。</td></tr><tr><td>客户端是否了解服务提供方信息</td><td>由于负载均衡是在客户端发送请求后进行的，因此客户端并不知道到底是哪个服务端提供的服务。</td><td>负载均衡是在客户端发送请求前进行的，因此客户端清楚的知道是哪个服务端提供的服务。</td></tr></tbody></table><h3 id="3-Ribbon-实现服务调用"><a href="#3-Ribbon-实现服务调用" class="headerlink" title="3.Ribbon 实现服务调用"></a>3.Ribbon 实现服务调用</h3><p>Ribbon 可以与 RestTemplate（Rest 模板）配合使用，以实现微服务之间的调用。</p><p>RestTemplate 是 Spring 家族中的一个用于消费第三方 REST 服务的请求框架。RestTemplate 实现了对 HTTP 请求的封装，提供了一套模板化的服务调用方法。通过它，Spring 应用可以很方便地对各种类型的 HTTP 请求进行访问。</p><p>RestTemplate 针对各种类型的 HTTP 请求都提供了相应的方法进行处理，例如 HEAD、GET、POST、PUT、DELETE 等类型的 HTTP 请求，分别对应 RestTemplate 中的 headForHeaders()、getForObject()、postForObject()、put() 以及 delete() 方法。</p><ol><li><p>导包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring Cloud Eureka 客户端依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Spring Cloud Ribbon 依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line"><span class="comment">############################################# Spring Cloud Ribbon 负载均衡配置##########################</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#本微服务为服务消费者，不需要将自己注册到服务注册中心</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span>  <span class="comment">#本微服务为服务消费者，需要到服务注册中心搜索服务</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span> <span class="comment">#服务注册中心集群</span></span><br></pre></td></tr></table></figure></li><li><p>创建配置类,注入RestTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置类注解</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigBean</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//将 RestTemplate 注入到容器中</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">//在客户端使用 RestTemplate 请求服务端时，开启负载均衡（Ribbon）</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController_Consumer</span> &#123;</span><br><span class="line">    <span class="comment">//private static final String REST_URL_PROVIDER_PREFIX = &quot;http://localhost:8001/&quot;; 这种方式是直调用服务方的方法，根本没有用到 Spring Cloud</span></span><br><span class="line">    <span class="comment">//面向微服务编程，即通过微服务的名称来获取调用地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REST_URL_PROVIDER_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;http://MICROSERVICECLOUDPROVIDERDEPT&quot;</span>; <span class="comment">// 使用注册到 Spring Cloud Eureka 服务注册中心中的服务，即 application.name</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate; <span class="comment">//RestTemplate 是一种简单便捷的访问 restful 服务模板类，是 Spring 提供的用于访问 Rest 服务的客户端模板工具集，提供了多种便捷访问远程 HTTP 服务的方法</span></span><br><span class="line">    <span class="comment">//获取指定部门信息</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/consumer/dept/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(REST_URL_PROVIDER_PREFIX + <span class="string">&quot;/dept/get/&quot;</span> + id, Dept.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取部门列表</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/consumer/dept/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Dept&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(REST_URL_PROVIDER_PREFIX + <span class="string">&quot;/dept/list&quot;</span>, List.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主启动类上加注解  @EnableEurekaClient 注解来开启 Eureka 客户端功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudConsumerDept80Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudConsumerDept80Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Ribbon-实现负载均衡"><a href="#4-Ribbon-实现负载均衡" class="headerlink" title="4.Ribbon 实现负载均衡"></a>4.Ribbon 实现负载均衡</h3><p><strong>Ribbon 是一个客户端的负载均衡器，它可以与 Eureka 配合使用轻松地实现客户端的负载均衡。Ribbon 会先从 Eureka Server（服务注册中心）去获取服务端列表，然后通过负载均衡策略将请求分摊给多个服务端，从而达到负载均衡的目的。</strong></p><p>Spring Cloud Ribbon 提供了一个 <strong>IRule 接口</strong>，该接口主要用来定义负载均衡策略，它有 7 个默认实现类，每一个实现类都是一种负载均衡策略。</p><table><thead><tr><th>序号</th><th>实现类</th><th>负载均衡策略</th></tr></thead><tbody><tr><td>1</td><td>RoundRobinRule</td><td>按照线性轮询策略，即按照一定的顺序依次选取服务实例</td></tr><tr><td>2</td><td>RandomRule</td><td>随机选取一个服务实例</td></tr><tr><td>3</td><td>RetryRule</td><td>按照 RoundRobinRule（轮询）的策略来获取服务，如果获取的服务实例为 null 或已经失效，则在指定的时间之内不断地进行重试（重试时获取服务的策略还是 RoundRobinRule 中定义的策略），如果超过指定时间依然没获取到服务实例则返回 null 。</td></tr><tr><td>4</td><td>WeightedResponseTimeRule</td><td>WeightedResponseTimeRule 是 RoundRobinRule 的一个子类，它对 RoundRobinRule 的功能进行了扩展。  根据平均响应时间，来计算所有服务实例的权重，响应时间越短的服务实例权重越高，被选中的概率越大。刚启动时，如果统计信息不足，则使用线性轮询策略，等信息足够时，再切换到 WeightedResponseTimeRule。</td></tr><tr><td>5</td><td>BestAvailableRule</td><td>继承自 ClientConfigEnabledRoundRobinRule。先过滤点故障或失效的服务实例，然后再选择并发量最小的服务实例。</td></tr><tr><td>6</td><td>AvailabilityFilteringRule</td><td>先过滤掉故障或失效的服务实例，然后再选择并发量较小的服务实例。</td></tr><tr><td>7</td><td>ZoneAvoidanceRule</td><td>默认的负载均衡策略，综合判断服务所在区域（zone）的性能和服务（server）的可用性，来选择服务实例。在没有区域的环境下，该策略与轮询（RandomRule）策略类似。</td></tr></tbody></table><p>其实可以分为三大类:</p><ul><li><p>轮询类:</p><ul><li>RoundRobinRule 线性轮询<ul><li>RetryRule 重试轮询,对null或已失效规定时间内多次重试,最后失败返回null</li><li>WeightedResponseTimeRule 权重轮询 根据平均响应时间来建立权重,时间短的权重大,被选中的几率也大. 刚启动的时候如果信息不足就会先使用轮询,等到信息足够就切换到权重轮询</li><li>ZoneAvoidanceRule 没有区域的时候与轮询策略类似 默认的策略 会根据区域进行性能分析,服务可用性分析结果来调用</li></ul></li></ul></li><li><p>随机类:</p><ul><li>RandomRule 随机选一个服务</li></ul></li><li><p>过滤并发类:</p><ul><li>BestAvailableRule 先过滤掉故障或失效的服务实例，然后再选择并发量最小的服务实例。继承自ClientConfigEnabledRoundRobinRule。</li><li>AvailabilityFilteringRule 先过滤掉故障或失效的服务实例，然后再选择并发量较小的服务实例。</li></ul></li></ul><h3 id="5-切换负载均衡策略"><a href="#5-切换负载均衡策略" class="headerlink" title="5.切换负载均衡策略"></a>5.切换负载均衡策略</h3><p>Spring Cloud Ribbon 默认使用轮询策略选取服务实例，我们也可以根据自身的需求切换负载均衡策略。</p><p>切换负载均衡策略的方法很简单，我们只需要在服务消费者（客户端）的配置类中，将 IRule 的其他实现类注入到容器中即可。</p><p>配置类 ConfigBean 中添加以下代码，将负载均衡策略切换为 RandomRule（随机）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">myRule</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// RandomRule 为随机策略</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-定制负载均衡策略"><a href="#6-定制负载均衡策略" class="headerlink" title="6.定制负载均衡策略"></a>6.定制负载均衡策略</h3><p>1.创建负载均衡策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定制 Ribbon 负载均衡策略</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRandomRule</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalancerRule</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;            <span class="comment">// 总共被调用的次数，目前要求每台被调用5次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentIndex</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 当前提供服务的机器号</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lb == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取所有有效的服务实例列表</span></span><br><span class="line">            List&lt;Server&gt; upList = lb.getReachableServers();</span><br><span class="line">            <span class="comment">//获取所有的服务实例的列表</span></span><br><span class="line">            List&lt;Server&gt; allList = lb.getAllServers();</span><br><span class="line">            <span class="comment">//如果没有任何的服务实例则返回 null</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">serverCount</span> <span class="operator">=</span> allList.size();</span><br><span class="line">            <span class="keyword">if</span> (serverCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//与随机策略相似，但每个服务实例只有在调用 3 次之后，才会调用其他的服务实例</span></span><br><span class="line">            <span class="keyword">if</span> (total &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                server = upList.get(currentIndex);</span><br><span class="line">                total++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                total = <span class="number">0</span>;</span><br><span class="line">                currentIndex++;</span><br><span class="line">                <span class="keyword">if</span> (currentIndex &gt;= upList.size()) &#123;</span><br><span class="line">                    currentIndex = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (server.isAlive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> (server);</span><br><span class="line">            &#125;</span><br><span class="line">            server = <span class="literal">null</span>;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> choose(getLoadBalancer(), key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建一个名为 MySelfRibbonRuleConfig 的配置类，将我们定制的负载均衡策略实现类注入到容器中，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定制 Ribbon 负载均衡策略的配置类</span></span><br><span class="line"><span class="comment">* 该自定义 Ribbon 负载均衡策略配置类 不能在 net.biancheng.c 包及其子包下</span></span><br><span class="line"><span class="comment">* 否则所有的 Ribbon 客户端都会采用该策略，无法达到特殊化定制的目的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySelfRibbonRuleConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">myRule</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//自定义 Ribbon 负载均衡策略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyRandomRule</span>(); <span class="comment">//自定义，随机选择某一个微服务，执行五次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.主启动类上加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//自定义 Ribbon 负载均衡策略在主启动类上使用 RibbonClient 注解，在该微服务启动时，就能自动去加载我们自定义的 Ribbon 配置类，从而是配置生效</span></span><br><span class="line"><span class="comment">// name 为需要定制负载均衡策略的微服务名称（application name）</span></span><br><span class="line"><span class="comment">// configuration 为定制的负载均衡策略的配置类，</span></span><br><span class="line"><span class="comment">// 且官方文档中明确提出，该配置类不能在 ComponentScan 注解（SpringBootApplication 注解中包含了该注解）下的包或其子包中，即自定义负载均衡配置类不能在 net.biancheng.c 包及其子包下</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;MICROSERVICECLOUDPROVIDERDEPT&quot;, configuration = MySelfRibbonRuleConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudConsumerDept80Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudConsumerDept80Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OpenFeign：Spring-Cloud声明式服务调用组件"><a href="#OpenFeign：Spring-Cloud声明式服务调用组件" class="headerlink" title="OpenFeign：Spring Cloud声明式服务调用组件"></a>OpenFeign：Spring Cloud声明式服务调用组件</h2><h3 id="1-什么是OpenFeign"><a href="#1-什么是OpenFeign" class="headerlink" title="1.什么是OpenFeign"></a>1.什么是OpenFeign</h3><blockquote><p>Feign 对 <a href="http://c.biancheng.net/springcloud/ribbon.html">Ribbon</a> 进行了集成，利用 Ribbon 维护了一份可用服务清单，并通过 Ribbon 实现了客户端的负载均衡。</p><p>Feign 是一种声明式服务调用组件，它在 RestTemplate 的基础上做了进一步的封装。通过 Feign，我们只需要声明一个接口并通过注解进行简单的配置（类似于 Dao 接口上面的 Mapper 注解一样）即可实现对 HTTP 接口的绑定。</p><p>通过 Feign，我们可以像调用本地方法一样来调用远程服务，而完全感觉不到这是在进行远程调用。</p><p>Feign 支持多种注解，例如 Feign 自带的注解以及 JAX-RS 注解等，但遗憾的是 Feign 本身并不支持 Spring MVC 注解，这无疑会给广大 Spring 用户带来不便。</p><p>OpenFeign 全称 Spring Cloud OpenFeign，它是 Spring 官方推出的一种声明式服务调用与负载均衡组件，它的出现就是为了替代进入停更维护状态的 Feign。</p><p>OpenFeign 是 Spring Cloud 对 Feign 的二次封装，它具有 Feign 的所有功能，并在 Feign 的基础上增加了对 Spring MVC 注解的支持，例如 @RequestMapping、@GetMapping 和 @PostMapping 等。</p></blockquote><h3 id="2-OpenFeign-常用注解"><a href="#2-OpenFeign-常用注解" class="headerlink" title="2.OpenFeign 常用注解"></a>2.OpenFeign 常用注解</h3><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@FeignClient</td><td>该注解用于通知 OpenFeign 组件对 @RequestMapping 注解下的接口进行解析，并通过动态代理的方式产生实现类，实现负载均衡和服务调用。</td></tr><tr><td>@EnableFeignClients</td><td>该注解用于开启 OpenFeign 功能，当 Spring Cloud 应用启动时，OpenFeign 会扫描标有 @FeignClient 注解的接口，生成代理并注册到 Spring 容器中。</td></tr><tr><td>@RequestMapping</td><td>Spring MVC 注解，在 Spring MVC 中使用该注解映射请求，通过它来指定控制器（Controller）可以处理哪些 URL 请求，相当于 Servlet 中 web.xml 的配置。</td></tr><tr><td>@GetMapping</td><td>Spring MVC 注解，用来映射 GET 请求，它是一个组合注解，相当于 @RequestMapping(method &#x3D; RequestMethod.GET) 。</td></tr><tr><td>@PostMapping</td><td>Spring MVC 注解，用来映射 POST 请求，它是一个组合注解，相当于 @RequestMapping(method &#x3D; RequestMethod.POST) 。</td></tr></tbody></table><h3 id="3-Feign-VS-OpenFeign"><a href="#3-Feign-VS-OpenFeign" class="headerlink" title="3.Feign VS OpenFeign"></a>3.Feign VS OpenFeign</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>Feign 和 OpenFegin 具有以下相同点：</p><ul><li>Feign 和 OpenFeign 都是 Spring Cloud 下的远程调用和负载均衡组件。</li><li>Feign 和 OpenFeign 作用一样，都可以实现服务的远程调用和负载均衡。</li><li>Feign 和 OpenFeign 都对 Ribbon 进行了集成，都利用 Ribbon 维护了可用服务清单，并通过 Ribbon 实现了客户端的负载均衡。</li><li>Feign 和 OpenFeign 都是在服务消费者（客户端）定义服务绑定接口并通过注解的方式进行配置，以实现远程服务的调用。</li></ul><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>Feign 和 OpenFeign 具有以下不同：</p><ul><li>Feign 和 OpenFeign 的依赖项不同，Feign 的依赖为 spring-cloud-starter-feign，而 OpenFeign 的依赖为 spring-cloud-starter-openfeign。</li><li>Feign 和 OpenFeign 支持的注解不同，Feign 支持 Feign 注解和 JAX-RS 注解，但不支持 Spring MVC 注解；OpenFeign 除了支持 Feign 注解和 JAX-RS 注解外，还支持 Spring MVC 注解。</li></ul><h3 id="4-OpenFeign-实现远程服务调用"><a href="#4-OpenFeign-实现远程服务调用" class="headerlink" title="4.OpenFeign 实现远程服务调用"></a>4.OpenFeign 实现远程服务调用</h3><p>1.导包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Eureka Client 依赖--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Ribbon 依赖--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--添加 OpenFeign 依赖--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#服务消费者可以不向服务注册中心注册服务</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span>  <span class="comment">#服务消费者客户端需要去检索服务</span></span><br></pre></td></tr></table></figure><p>3.创建一个名为 DeptFeignService 的接口，并在该接口上使用 @FeignClient 注解实现对服务接口的绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加为容器内的一个组件</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 服务提供者提供的服务名称，即 application.name</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;MICROSERVICECLOUDPROVIDERDEPT&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptFeignService</span> &#123;</span><br><span class="line">    <span class="comment">//对应服务提供者（8001、8002、8003）Controller 中定义的方法</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/dept/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/dept/list&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Dept&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写服务绑定接口时，需要注意以下 2 点：</p><ul><li>在 @FeignClient 注解中，value 属性的取值为：服务提供者的服务名，即服务提供者配置文件（application.yml）中 spring.application.name 的取值。</li><li>接口中定义的每个方法都与服务提供者（即 micro-service-cloud-provider-dept-8001 等）中 Controller 定义的服务方法对应。</li></ul><p>4.在主启动类上添加 @EnableFeignClients 注解开启 OpenFeign 功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">//开启 OpenFeign 功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudConsumerDeptFeignApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudConsumerDeptFeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pring Cloud 应用在启动时，OpenFeign 会扫描标有 @FeignClient 注解的接口生成代理，并注人到 Spring 容器中。</p><h3 id="5-OpenFeign-超时控制"><a href="#5-OpenFeign-超时控制" class="headerlink" title="5.OpenFeign 超时控制"></a>5.OpenFeign 超时控制</h3><p>OpenFeign 客户端的默认超时时间为 1 秒钟，如果服务端处理请求的时间超过 1 秒就会报错。为了避免这样的情况，我们需要对 OpenFeign 客户端的超时时间进行控制。</p><p><strong>application.yml 中添加以下配置，将超时时间设置为 6 秒。</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">6000</span> <span class="comment">#建立连接所用的时间，适用于网络状况正常的情况下，两端两端连接所用的时间</span></span><br><span class="line">  <span class="attr">ConnectionTimeout:</span> <span class="number">6000</span> <span class="comment">#建立连接后，服务器读取到可用资源的时间</span></span><br></pre></td></tr></table></figure><blockquote><p>注：由于 OpenFeign 集成了 Ribbon ，其服务调用以及负载均衡在底层都是依靠 Ribbon 实现的，因此 OpenFeign 超时控制也是通过 Ribbon 来实现的。</p></blockquote><h3 id="6-OpenFeign-日志增强"><a href="#6-OpenFeign-日志增强" class="headerlink" title="6.OpenFeign 日志增强"></a>6.OpenFeign 日志增强</h3><p>OpenFeign 提供了日志打印功能，我们可以通过配置调整日志级别，来了解请求的细节。</p><p>Feign 为每一个 FeignClient 都提供了一个 feign.Logger 实例，通过它可以对 OpenFeign 服务绑定接口的调用情况进行监控。</p><p>application.yml 中配置以下内容。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment">#feign 日志以什么样的级别监控该接口</span></span><br><span class="line">    <span class="attr">net.biancheng.c.service.DeptFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>以上配置说明如下：</p><ul><li>net.biancheng.c.service.DeptFeignService 是开启 @FeignClient 注解的接口（即服务绑定接口）的完整类名。也可以只配置部分路径，表示监控该路径下的所有服务绑定接口</li><li>debug：表示监听该接口的日志级别。</li></ul><p>以上配置的含义就是，OpenFeign 以 debug 级别监控 net.biancheng.c.service.DeptFeignService 接口。</p><p>创建一个名为 ConfigBean 的配置类，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigBean</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * OpenFeign 日志增强</span></span><br><span class="line"><span class="comment">     * 配置 OpenFeign 记录哪些内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.Level <span class="title function_">feginLoggerLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该配置的作用是通过配置的 Logger.Level 对象告诉 OpenFeign 记录哪些日志内容。</p><p> Logger.Level 的具体级别如下：</p><ul><li>NONE：不记录任何信息。</li><li>BASIC：仅记录请求方法、URL 以及响应状态码和执行时间。</li><li>HEADERS：除了记录 BASIC 级别的信息外，还会记录请求和响应的头信息。</li><li>FULL：记录所有请求与响应的明细，包括头信息、请求体、元数据等等。</li></ul><h2 id="Hystrix：Spring-Cloud服务熔断与降级组件"><a href="#Hystrix：Spring-Cloud服务熔断与降级组件" class="headerlink" title="Hystrix：Spring Cloud服务熔断与降级组件"></a>Hystrix：Spring Cloud服务熔断与降级组件</h2><p>![image-20220912144222275](Spring Cloud 微服务.assets&#x2F;image-20220912144222275.png)</p><p>从以上过程可以看出，当微服务系统的一个服务出现故障时，故障会沿着服务的调用链路在系统中疯狂蔓延，最终导致整个微服务系统的瘫痪，这就是“雪崩效应”。为了防止此类事件的发生，微服务架构引入了“熔断器”的一系列服务容错和保护机制。</p><h3 id="1-熔断器"><a href="#1-熔断器" class="headerlink" title="1.熔断器"></a>1.熔断器</h3><p>熔断器（Circuit Breaker）一词来源物理学中的电路知识，它的作用是当线路出现故障时，迅速切断电源以保护电路的安全。</p><p>在微服务领域，熔断器最早是由 Martin Fowler 在他发表的 《<a href="https://martinfowler.com/bliki/CircuitBreaker.html">Circuit Breake</a>r》一文中提出。与物理学中的熔断器作用相似，<strong>微服务架构中的熔断器能够在某个服务发生故障后，向服务调用方返回一个符合预期的、可处理的降级响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常。</strong>这样就保证了服务调用方的线程不会被长时间、不必要地占用，避免故障在微服务系统中的蔓延，防止系统雪崩效应的发生。</p><h3 id="2-Spring-Cloud-Hystrix"><a href="#2-Spring-Cloud-Hystrix" class="headerlink" title="2.Spring Cloud Hystrix"></a>2.Spring Cloud Hystrix</h3><p>Spring Cloud Hystrix 是基于 Netflix 公司的开源组件 Hystrix 实现的，它提供了熔断器功能，能够有效地阻止分布式微服务系统中出现联动故障，以提高微服务系统的弹性。<strong>Spring Cloud Hystrix 具有服务降级、服务熔断、线程隔离、请求缓存、请求合并以及实时故障监控</strong>等强大功能。</p><blockquote><p>Hystrix [hɪst’rɪks]，中文含义是豪猪，豪猪的背上长满了棘刺，使它拥有了强大的自我保护能力。而 Spring Cloud Hystrix 作为一个服务容错与保护组件，也可以让服务拥有自我保护的能力，因此也有人将其戏称为“豪猪哥”。</p></blockquote><p>在微服务系统中，Hystrix 能够帮助我们实现以下目标：</p><ul><li><strong>保护线程资源</strong>：防止单个服务的故障耗尽系统中的所有线程资源。</li><li><strong>快速失败机制</strong>：当某个服务发生了故障，不让服务调用方一直等待，而是直接返回请求失败。</li><li><strong>提供降级（FallBack）方案</strong>：在请求失败后，提供一个设计好的降级方案，通常是一个兜底方法，当请求失败后即调用该方法。</li><li><strong>防止故障扩散</strong>：使用熔断机制，防止故障扩散到其他服务。</li><li><strong>监控功能</strong>：提供熔断器故障监控组件 Hystrix Dashboard，随时监控熔断器的状态。</li></ul><h3 id="3-Hystrix-服务降级"><a href="#3-Hystrix-服务降级" class="headerlink" title="3.Hystrix 服务降级"></a>3.Hystrix 服务降级</h3><p>服务降级的使用场景有以下 2 种：</p><ul><li>在服务器压力剧增时，根据实际业务情况及流量，对一些不重要、不紧急的服务进行有策略地不处理或简单处理，从而释放服务器资源以保证核心服务正常运作。</li><li>当某些服务不可用时，为了避免长时间等待造成服务卡顿或雪崩效应，而主动执行备用的降级逻辑立刻返回一个友好的提示，以保障主体业务不受影响。</li></ul><p>我们可以通过重写 HystrixCommand 的 getFallBack() 方法或 HystrixObservableCommand 的 resumeWithFallback() 方法，使服务支持服务降级。</p><p>Hystrix 服务降级 FallBack 既可以放在服务端进行，也可以放在客户端进行。</p><p>Hystrix 会在以下场景下进行服务降级处理：</p><ul><li>程序运行异常</li><li>服务超时</li><li>熔断器处于打开状态</li><li>线程池资源耗尽</li></ul><h4 id="3-1服务端服务降级"><a href="#3-1服务端服务降级" class="headerlink" title="3.1服务端服务降级"></a>3.1服务端服务降级</h4><p>1.导包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加 Spring Boot 的监控模块--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- eureka 客户端--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--hystrix 依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.配置文件 application.yml，配置内容如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">microServiceCloudProviderDeptHystrix</span>  <span class="comment">#微服务名称，对外暴漏的微服务名称，十分重要</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8004</span></span><br><span class="line"><span class="comment">########################################### Spring cloud 自定义服务名称和 ip 地址###############################################</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#将客户端注册到 eureka 服务列表内</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#defaultZone: http://eureka7001:7001/eureka  #这个地址是 7001注册中心在 application.yml 中暴露出来额注册地址 （单机版）</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span>  <span class="comment">#将服务注册到 Eureka 集群</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">spring-cloud-provider-8004</span> <span class="comment">#自定义服务名称信息</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>  <span class="comment">#显示访问路径的 ip 地址</span></span><br><span class="line"><span class="comment">#####################spring cloud 使用 Spring Boot actuator 监控完善信息###########################################</span></span><br><span class="line"><span class="comment"># Spring Boot 2.50对 actuator 监控屏蔽了大多数的节点，只暴露了 heath 节点，本段配置（*）就是为了开启所有的节点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span>   <span class="comment"># * 在yaml 文件属于关键字，所以需要加引号</span></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app.name:</span> <span class="string">micro-service-cloud-provider-dept-hystrix</span></span><br><span class="line">  <span class="attr">company.name:</span> <span class="string">c.biancheng.net</span></span><br><span class="line">  <span class="attr">build.aetifactId:</span> <span class="string">@project.artifactId@</span></span><br><span class="line">  <span class="attr">build.version:</span> <span class="string">@project.version@</span></span><br></pre></td></tr></table></figure><p>3.实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;deptService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DeptService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Ok</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;  deptInfo_Ok,id:   &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一旦该方法失败并抛出了异常信息后，会自动调用  @HystrixCommand 注解标注的 fallbackMethod 指定的方法</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;dept_TimeoutHandler&quot;,</span></span><br><span class="line"><span class="meta">            commandProperties =</span></span><br><span class="line"><span class="meta">                    //规定 5 秒钟以内就不报错，正常运行，超过 5 秒就报错，调用指定的方法</span></span><br><span class="line"><span class="meta">                    &#123;@HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;5000&quot;)&#125;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Timeout</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">outTime</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(outTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;  deptInfo_Timeout,id:   &quot;</span> + id + <span class="string">&quot;  耗时: &quot;</span> + outTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当服务出现故障后，调用该方法给出友好提示</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dept_TimeoutHandler</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span>  <span class="string">&quot;C语言中文网提醒您，系统繁忙请稍后再试！&quot;</span>+<span class="string">&quot;线程池：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;  deptInfo_Timeout,id:   &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到 deptInfo_Timeout() 方法上使用 @HystrixCommand 注解，该注解说明如下：</p><ul><li>参数 fallbackMethod 属性用于指定降级方法。</li><li>参数 execution.isolation.thread.timeoutInMilliseconds 用于设置自身调用超时时间的峰值，峰值内可以正常运行，否则执行降级方法</li></ul><p>4.启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">//开启 Eureka 客户端功能</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span> <span class="comment">//激活熔断器功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudProviderDeptHystrix8004Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudProviderDeptHystrix8004Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2客户端服务降级"><a href="#3-2客户端服务降级" class="headerlink" title="3.2客户端服务降级"></a>3.2客户端服务降级</h4><p>通常情况下，我们都会在客户端进行服务降级，当客户端调用的服务端的服务不可用时，客户端直接进行服务降级处理，避免其线程被长时间、不必要地占用。</p><p>1.依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--hystrix 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.application.yml 中添加以下配置，开启客户端的 Hystrix 功能。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启客户端 hystrix</span></span><br></pre></td></tr></table></figure><p>3.服务接口进行绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;MICROSERVICECLOUDPROVIDERDEPTHYSTRIX&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptHystrixService</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/dept/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Ok</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/dept/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Timeout</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.降级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixController_Consumer</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DeptHystrixService deptHystrixService;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/consumer/dept/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Ok</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deptHystrixService.deptInfo_Ok(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在客户端进行降级</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/consumer/dept/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;dept_TimeoutHandler&quot;)</span> <span class="comment">//为该请求指定专属的回退方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Timeout</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> deptHystrixService.deptInfo_Timeout(id);</span><br><span class="line">        log.info(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// deptInfo_Timeout方法的 专用 fallback 方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dept_TimeoutHandler</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;deptInfo_Timeout 出错，服务已被降级！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;C语言中文网提醒您：服务端系统繁忙，请稍后再试！（客户端 deptInfo_Timeout 专属的回退方法触发）&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.appliction.yml 中添加以下配置，在客户端配置请求超时的时间</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################### Ribbon 客户端超时控制 ###################################</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">6000</span> <span class="comment">#建立连接所用的时间，适用于网络状况正常的情况下，两端两端连接所用的时间</span></span><br><span class="line">  <span class="attr">ConnectionTimeout:</span> <span class="number">6000</span> <span class="comment">#建立连接后，服务器读取到可用资源的时间</span></span><br><span class="line"><span class="comment">######################配置请求超时时间##########################</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">7000</span></span><br><span class="line"><span class="comment">####################配置具体方法超时时间 为 3 秒########################</span></span><br><span class="line">    <span class="string">DeptHystrixService#deptInfo_Timeout(Integer):</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><p>1）Hystrix 可以来为所有请求（方法）设置超时时间（单位为毫秒），若请求超时则触发全局的回退方法进行处理。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=mmm</span></span><br></pre></td></tr></table></figure><p>2）Hystrix 还可以为某个特定的服务请求（方法）设置超时时间，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hystrix.command.xxx#yyy(zzz).execution.isolation.thread.timeoutInMilliseconds=mmm</span><br></pre></td></tr></table></figure><p>格式说明如下：</p><ul><li>xxx：为包含该服务方法的类的名称（通常为服务绑定接口的名称），例如 DeptHystrixService 接口。</li><li>yyy：服务方法名，例如 deptInfo_Timeout() 方法。</li><li>zzz：方法内的参数类型，例如 Integer、String 等等</li><li>mmm：要设置的超时时间，单位为毫秒（1 秒 &#x3D;1000 毫秒）</li></ul><p>6.启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">//开启 OpenFeign 功能</span></span><br><span class="line"><span class="meta">@EnableHystrix</span> <span class="comment">//启用 Hystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudConsumerDeptFeignApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudConsumerDeptFeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-全局降级方法"><a href="#4-全局降级方法" class="headerlink" title="4.全局降级方法"></a>4.全局降级方法</h3><p>通过上面的方式实现服务降级时，需要针对所有业务方法都配置降级方法，这极有可能会造成代码的急剧膨胀。为了解决该问题，我们还可以为所有业务方法指定一个全局的回退方法，具体步骤如下。</p><p>1.通过其 defaultFallback 属性指定一个全局的降级方法，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@DefaultProperties(defaultFallback = &quot;dept_Global_FallbackMethod&quot;)</span> <span class="comment">//全局的服务降级方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixController_Consumer</span> &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建一个名为 dept_Global_FallbackMethod 的全局回方法，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局的 fallback 方法，</span></span><br><span class="line"><span class="comment"> * 回退方法必须和 hystrix 的执行方法在相同类中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DefaultProperties</span>(defaultFallback = &quot;dept_Global_FallbackMethod&quot;) 类上注解，请求方法上使用 <span class="doctag">@HystrixCommand</span> 注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dept_Global_FallbackMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;C语言中文网提醒您，运行出错或服务端系统繁忙，请稍后再试！（客户端全局回退方法触发,）&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：降级（FallBack）方法必须与其对应的业务方法在同一个类中，否则无法生效。</p></blockquote><p>3.在所有的业务方法上都标注 @HystrixCommand 注解，这里我们将 deptInfo_Timeout() 方法上的 @HystrixCommand(fallbackMethod &#x3D; “dept_TimeoutHandler”) 修改为 @HystrixCommand 即可，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在客户端进行降级</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/consumer/dept/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deptInfo_Timeout</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> deptHystrixService.deptInfo_Timeout(id);</span><br><span class="line">    log.info(s);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：全局降级方法的优先级较低，只有业务方法没有指定其降级方法时，服务降级时才会触发全局回退方法。若业务方法指定它自己的回退方法，那么在服务降级时，就只会直接触发它自己的回退方法，而非全局回退方法。</p></blockquote><h3 id="5-解耦降级逻辑"><a href="#5-解耦降级逻辑" class="headerlink" title="5.解耦降级逻辑"></a>5.解耦降级逻辑</h3><p>不管是业务方法指定的降级方法还是全局降级方法，它们都必须和业务方法在同一个类中才能生效，业务逻辑与降级逻辑耦合度极高。</p><p>1.提供服务降级处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Hystrix 服务降级</span></span><br><span class="line"><span class="comment">* 解耦回退逻辑</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptHystrixFallBackService</span> <span class="keyword">implements</span> <span class="title class_">DeptHystrixService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Ok</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;--------------------C语言中文网提醒您，系统繁忙，请稍后重试！（解耦回退方法触发）-----------------------&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Timeout</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;--------------------C语言中文网提醒您，系统繁忙，请稍后重试！（解耦回退方法触发）-----------------------&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：该类必须以组件的形式添加 Spring 容器中才能生效，最常用的方式就是在类上标注 @Component 注解。</p></blockquote><p>2.在服务绑定接口 DeptHystrixService 标注的 @FeignClient 注解中添加 fallback 属性，属性值为 DeptHystrixFallBackService.class，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;MICROSERVICECLOUDPROVIDERDEPTHYSTRIX&quot;, fallback = DeptHystrixFallBackService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptHystrixService</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/dept/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Ok</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/dept/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Timeout</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Hystrix-服务熔断"><a href="#6-Hystrix-服务熔断" class="headerlink" title="6.Hystrix 服务熔断"></a>6.Hystrix 服务熔断</h3><p>熔断机制是为了应对雪崩效应而出现的一种微服务链路保护机制。</p><p>当微服务系统中的某个微服务不可用或响应时间太长时，为了保护系统的整体可用性，熔断器会暂时切断请求对该服务的调用，并快速返回一个友好的错误响应。这种熔断状态不是永久的，在经历了一定的时间后，熔断器会再次检测该微服务是否恢复正常，若服务恢复正常则恢复其调用链路。</p><h4 id="熔断状态"><a href="#熔断状态" class="headerlink" title="熔断状态"></a>熔断状态</h4><p>在熔断机制中涉及了三种熔断状态：</p><ul><li>熔断关闭状态（Closed）：当服务访问正常时，熔断器处于关闭状态，服务调用方可以正常地对服务进行调用。</li><li>熔断开启状态（Open）：默认情况下，在固定时间内接口调用出错比率达到一个阈值（例如 50%），熔断器会进入熔断开启状态。进入熔断状态后，后续对该服务的调用都会被切断，熔断器会执行本地的降级（FallBack）方法。</li><li>半熔断状态（Half-Open）： 在熔断开启一段时间之后，熔断器会进入半熔断状态。在半熔断状态下，熔断器会尝试恢复服务调用方对服务的调用，允许部分请求调用该服务，并监控其调用成功率。如果成功率达到预期，则说明服务已恢复正常，熔断器进入关闭状态；如果成功率仍旧很低，则重新进入熔断开启状态。</li></ul><p>![image-20220912153121380](Spring Cloud 微服务.assets&#x2F;image-20220912153121380.png)</p><h4 id="Hystrix-实现熔断机制"><a href="#Hystrix-实现熔断机制" class="headerlink" title="Hystrix 实现熔断机制"></a>Hystrix 实现熔断机制</h4><p>在 Spring Cloud 中，熔断机制是通过 Hystrix 实现的。Hystrix 会监控微服务间调用的状况，当失败调用到一定比例时（例如 5 秒内失败 20 次），就会启动熔断机制。</p><p>Hystrix 实现服务熔断的步骤如下：</p><ol><li>当服务的调用出错率达到或超过 Hystix 规定的比率（默认为 50%）后，熔断器进入熔断开启状态。</li><li>熔断器进入熔断开启状态后，Hystrix 会启动一个休眠时间窗，在这个时间窗内，该服务的降级逻辑会临时充当业务主逻辑，而原来的业务主逻辑不可用。</li><li>当有请求再次调用该服务时，会直接调用降级逻辑快速地返回失败响应，以避免系统雪崩。</li><li>当休眠时间窗到期后，Hystrix 会进入半熔断转态，允许部分请求对服务原来的主业务逻辑进行调用，并监控其调用成功率。</li><li>如果调用成功率达到预期，则说明服务已恢复正常，Hystrix 进入熔断关闭状态，服务原来的主业务逻辑恢复；否则 Hystrix 重新进入熔断开启状态，休眠时间窗口重新计时，继续重复第 2 到第 5 步。</li></ol><p>1.方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptService</span> &#123;</span><br><span class="line">    <span class="comment">// hystrix 熔断器示例 ok</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Ok</span><span class="params">(Integer id)</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//hystrix 熔断器超时案例</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Timeout</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="comment">// Hystrix 熔断机制案例</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptCircuitBreaker</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.实现及其回退</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hystrix 熔断案例</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;deptCircuitBreaker_fallback&quot;, commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        //以下参数在 HystrixCommandProperties 类中有默认配置</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;, value = &quot;true&quot;), //是否开启熔断器</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;metrics.rollingStats.timeInMilliseconds&quot;,value = &quot;1000&quot;), //统计时间窗</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;), //统计时间窗内请求次数</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value = &quot;10000&quot;), //休眠时间窗口期</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;60&quot;), //在统计时间窗口期以内，请求失败率达到 60% 时进入熔断状态</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deptCircuitBreaker</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//当传入的 id 为负数时，抛出异常，调用降级方法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;c语言中文网提醒您，id 不能是负数！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">serialNum</span> <span class="operator">=</span> IdUtil.simpleUUID();</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;调用成功，流水号为：&quot;</span> + serialNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deptCircuitBreaker 的降级方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deptCircuitBreaker_fallback</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，id 不能是负数,请稍后重试!\t id:&quot;</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>metrics.rollingStats.timeInMilliseconds</td><td>统计时间窗。</td></tr><tr><td>circuitBreaker.sleepWindowInMilliseconds</td><td>休眠时间窗，熔断开启状态持续一段时间后，熔断器会自动进入半熔断状态，这段时间就被称为休眠窗口期。</td></tr><tr><td>circuitBreaker.requestVolumeThreshold</td><td>请求总数阀值。  在统计时间窗内，请求总数必须到达一定的数量级，Hystrix 才可能会将熔断器打开进入熔断开启转态，而这个请求数量级就是 请求总数阀值。Hystrix 请求总数阈值默认为 20，这就意味着在统计时间窗内，如果服务调用次数不足 20 次，即使所有的请求都调用出错，熔断器也不会打开。</td></tr><tr><td>circuitBreaker.errorThresholdPercentage</td><td>错误百分比阈值。  当请求总数在统计时间窗内超过了请求总数阀值，且请求调用出错率超过一定的比例，熔断器才会打开进入熔断开启转态，而这个比例就是错误百分比阈值。错误百分比阈值设置为 50，就表示错误百分比为 50%，如果服务发生了 30 次调用，其中有 15 次发生了错误，即超过了 50% 的错误百分比，这时候将熔断器就会打开。</td></tr></tbody></table><h3 id="7-Hystrix-故障监控"><a href="#7-Hystrix-故障监控" class="headerlink" title="7.Hystrix 故障监控"></a>7.Hystrix 故障监控</h3><p>Hystrix 还提供了准实时的调用监控（Hystrix Dashboard）功能，Hystrix 会持续地记录所有通过 Hystrix 发起的请求的执行信息，并以统计报表的形式展示给用户，包括每秒执行请求的数量、成功请求的数量和失败请求的数量等。</p><p>1.依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring Boot 测试依赖--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--hystrix-dashboard 监控的依赖--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--添加 Spring Boot 的监控模块--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9002</span>  <span class="comment">#端口号</span></span><br><span class="line"><span class="comment">#http://eureka7001.com:9002/hystrix 熔断器监控页面</span></span><br><span class="line"><span class="comment"># localhost:8004//actuator/hystrix.stream 监控地址</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">dashboard:</span></span><br><span class="line">    <span class="attr">proxy-stream-allow-list:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;localhost&quot;</span></span><br></pre></td></tr></table></figure><p>3.主启动类上添加 @EnableHystrixDashboard 注解，开启 Hystrix 监控功能，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudConsumerDeptHystrixDashboard9002Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudConsumerDeptHystrixDashboard9002Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixDashboardConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Hystrix dashboard 监控界面必须配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean <span class="title function_">getServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HystrixMetricsStreamServlet</span> <span class="variable">streamServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixMetricsStreamServlet</span>();</span><br><span class="line">        <span class="type">ServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">&quot;/actuator/hystrix.stream&quot;</span>);<span class="comment">//访问路径</span></span><br><span class="line">        registrationBean.setName(<span class="string">&quot;hystrix.stream&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Gateway：Spring-Cloud-API网关组件"><a href="#Gateway：Spring-Cloud-API网关组件" class="headerlink" title="Gateway：Spring Cloud API网关组件"></a>Gateway：Spring Cloud API网关组件</h2><p>在微服务架构中，一个系统往往由多个微服务组成，而这些服务可能部署在不同机房、不同地区、不同域名下。这种情况下，客户端（例如浏览器、手机、软件工具等）想要直接请求这些服务，就需要知道它们具体的地址信息，例如 IP 地址、端口号等。</p><p>这种客户端直接请求服务的方式存在以下问题：</p><ul><li>当服务数量众多时，客户端需要维护大量的服务地址，这对于客户端来说，是非常繁琐复杂的。</li><li>在某些场景下可能会存在跨域请求的问题。</li><li>身份认证的难度大，每个微服务需要独立认证。</li></ul><h3 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h3><p>API 网关是一个搭建在客户端和微服务之间的服务，我们可以在 API 网关中处理一些非业务功能的逻辑，例如权限验证、监控、缓存、请求路由等。</p><p>![image-20220912172529634](Spring Cloud 微服务.assets&#x2F;image-20220912172529634.png)</p><p>对于服务数量众多、复杂度较高、规模比较大的系统来说，使用 API 网关具有以下好处：</p><ul><li>客户端通过 API 网关与微服务交互时，客户端只需要知道 API 网关地址即可，而不需要维护大量的服务地址，简化了客户端的开发。</li><li>客户端直接与 API 网关通信，能够减少客户端与各个服务的交互次数。</li><li>客户端与后端的服务耦合度降低。</li><li>节省流量，提高性能，提升用户体验。</li><li>API 网关还提供了安全、流控、过滤、缓存、计费以及监控等 API 管理功能。</li></ul><p>常见的 API 网关实现方案主要有以下 5 种：</p><ul><li><strong>Spring Cloud Gateway</strong></li><li><strong>Spring Cloud Netflix Zuul</strong></li><li>Kong</li><li>Nginx+Lua</li><li>Traefik</li></ul><h3 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h3><p>Spring Cloud Gateway 是 Spring Cloud 团队基于 Spring 5.0、Spring Boot 2.0 和 Project <strong>Reactor</strong> 等技术开发的<strong>高性能</strong> <strong>API</strong> <strong>网关组件</strong>。</p><p>Spring Cloud Gateway 旨在<strong>提供一种简单而有效的途径来发送 API</strong>，并为它们提供横切关注点，例如：安全性，监控&#x2F;指标和弹性。 </p><blockquote><p>Spring Cloud Gateway 是基于 WebFlux 框架实现的，而 WebFlux 框架底层则使用了高性能的 Reactor 模式通信框架 Netty。</p></blockquote><h4 id="Spring-Cloud-Gateway-核心概念"><a href="#Spring-Cloud-Gateway-核心概念" class="headerlink" title="Spring Cloud Gateway 核心概念"></a>Spring Cloud Gateway 核心概念</h4><p>Spring Cloud GateWay 最主要的功能就是路由转发，而在定义转发规则时主要涉及了以下三个核心概念，如下表。</p><table><thead><tr><th>核心概念</th><th>描述</th></tr></thead><tbody><tr><td>Route（路由）</td><td>网关最基本的模块。它由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成。</td></tr><tr><td>Predicate（断言）</td><td>路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。</td></tr><tr><td>Filter（过滤器）</td><td>过滤器，我们可以使用它对请求进行拦截和修改，还可以使用它对上文的响应进行再处理。</td></tr></tbody></table><blockquote><p>注意：其中 Route 和 Predicate 必须同时声明。</p></blockquote><h4 id="Spring-Cloud-Gateway-的特征"><a href="#Spring-Cloud-Gateway-的特征" class="headerlink" title="Spring Cloud Gateway 的特征"></a>Spring Cloud Gateway 的特征</h4><p>Spring Cloud Gateway 具有以下特性：</p><ul><li>基于 Spring Framework 5、Project Reactor 和 Spring Boot 2.0 构建。</li><li>能够在任意请求属性上匹配路由。</li><li>predicates（断言） 和 filters（过滤器）是特定于路由的。</li><li>集成了 Hystrix 熔断器。</li><li>集成了 Spring Cloud DiscoveryClient（服务发现客户端）。</li><li>易于编写断言和过滤器。</li><li>能够限制请求频率。</li><li>能够重写请求路径。</li></ul><h3 id="Gateway-的工作流程"><a href="#Gateway-的工作流程" class="headerlink" title="Gateway 的工作流程"></a>Gateway 的工作流程</h3><img src="/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220912173002658.png" alt="image-20220912173002658" style="zoom:50%;"><p>Spring Cloud Gateway 工作流程说明如下：</p><ol><li>客户端将请求发送到 Spring Cloud Gateway 上。</li><li>Spring Cloud Gateway 通过 Gateway Handler Mapping 找到与请求相匹配的路由，将其发送给 Gateway Web Handler。</li><li>Gateway Web Handler 通过指定的过滤器链（Filter Chain），将请求转发到实际的服务节点中，执行业务逻辑返回响应结果。</li><li>过滤器之间用虚线分开是因为过滤器可能会在转发请求之前（pre）或之后（post）执行业务逻辑。</li><li>过滤器（Filter）可以在请求被转发到服务端前，对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等。</li><li>过滤器可以在响应返回客户端之前，对响应进行拦截和再处理，例如修改响应内容或响应头、日志输出、流量监控等。</li><li>响应原路返回给客户端。</li></ol><p>总而言之，客户端发送到 Spring Cloud Gateway 的请求需要通过一定的匹配条件，才能定位到真正的服务节点。在将请求转发到服务进行处理的过程前后（pre 和 post），我们还可以对请求和响应进行一些精细化控制。</p><p>Predicate 就是路由的匹配条件，而 Filter 就是对请求和响应进行精细化控制的工具。有了这两个元素，再加上目标 URI，就可以实现一个具体的路由了。</p><h3 id="Predicate-断言"><a href="#Predicate-断言" class="headerlink" title="Predicate 断言"></a>Predicate 断言</h3><p>Spring Cloud Gateway 通过 Predicate 断言来实现 Route 路由的匹配规则。简单点说，<strong>Predicate 是路由转发的判断条件</strong>，请求只有满足了 Predicate 的条件，才会被转发到指定的服务上进行处理。</p><p>使用 Predicate 断言需要注意以下 3 点：</p><ul><li>Route 路由与 Predicate 断言的对应关系为“一对多”，<strong>一个路由可以包含多个不同断言</strong>。</li><li>一个请求想要转发到指定的路由上，<strong>就必须同时匹配路由上的所有断言</strong>。</li><li>当一个请求同时满足多个路由的断言条件时，请求只会被首个成功匹配的路由转发。</li></ul><img src="/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220912173236315.png" alt="image-20220912173236315" style="zoom:67%;"><table><thead><tr><th>Path</th><th>- Path&#x3D;&#x2F;dept&#x2F;list&#x2F;**</th><th>当请求路径与 &#x2F;dept&#x2F;list&#x2F;** 匹配时，该请求才能被转发到 <a href="http://localhost:8001/">http://localhost:8001</a> 上。</th></tr></thead><tbody><tr><td>Before</td><td>- Before&#x3D;2021-10-20T11:47:34.255+08:00[Asia&#x2F;Shanghai]</td><td>在 2021 年 10 月 20 日 11 时 47 分 34.255 秒之前的请求，才会被转发到 <a href="http://localhost:8001/">http://localhost:8001</a> 上。</td></tr><tr><td>After</td><td>- After&#x3D;2021-10-20T11:47:34.255+08:00[Asia&#x2F;Shanghai]</td><td>在 2021 年 10 月 20 日 11 时 47 分 34.255 秒之后的请求，才会被转发到 <a href="http://localhost:8001/">http://localhost:8001</a> 上。</td></tr><tr><td>Between</td><td>- Between&#x3D;2021-10-20T15:18:33.226+08:00[Asia&#x2F;Shanghai],2021-10-20T15:23:33.226+08:00[Asia&#x2F;Shanghai]</td><td>在 2021 年 10 月 20 日 15 时 18 分 33.226 秒 到 2021 年 10 月 20 日 15 时 23 分 33.226 秒之间的请求，才会被转发到 <a href="http://localhost:8001/">http://localhost:8001</a> 服务器上。</td></tr><tr><td>Cookie</td><td>- Cookie&#x3D;name,c.biancheng.net</td><td>携带 Cookie 且 Cookie 的内容为 name&#x3D;c.biancheng.net 的请求，才会被转发到 <a href="http://localhost:8001/">http://localhost:8001</a> 上。</td></tr><tr><td>Header</td><td>- Header&#x3D;X-Request-Id,\d+</td><td>请求头上携带属性 X-Request-Id 且属性值为整数的请求，才会被转发到 <a href="http://localhost:8001/">http://localhost:8001</a> 上。</td></tr><tr><td>Method</td><td>- Method&#x3D;GET</td><td>只有 GET 请求才会被转发到 <a href="http://localhost:8001/">http://localhost:8001</a> 上。</td></tr></tbody></table><p>1.导包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--特别注意：在 gateway 网关服务中不能引入 spring-boot-starter-web 的依赖，否则会报错--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Spring cloud gateway 网关依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Eureka 客户端--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.application.yml，配置内容如下。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span>  <span class="comment">#端口号</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">microServiceCloudGateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span> <span class="comment">#网关路由配置</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment">#将 micro-service-cloud-provider-dept-8001 提供的服务隐藏起来，不暴露给客户端，只给客户端暴露 API 网关的地址 9527</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">provider_dept_list_routh</span>   <span class="comment">#路由 id,没有固定规则，但唯一，建议与服务名对应</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span>          <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="comment">#以下是断言条件，必选全部符合条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/dept/list/**</span>               <span class="comment">#断言，路径匹配 注意：Path 中 P 为大写</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Method=GET</span> <span class="comment">#只能时 GET 请求时，才能访问</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">micro-service-cloud-gateway-9527</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">micro-service-cloud-gateway</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span></span><br></pre></td></tr></table></figure><p>以上配置中，我们在 spring.cloud.gateway.routes 下使用 predicates 属性，定义了以下两个断言条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- Path=/dept/list/**            </span><br><span class="line">- Method=GET </span><br></pre></td></tr></table></figure><p>3.主启动类上，使用 @EnableEurekaClient 注解开启 Eureka 客户端功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudGateway9527Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudGateway9527Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Cloud-Gateway-动态路由"><a href="#Spring-Cloud-Gateway-动态路由" class="headerlink" title="Spring Cloud Gateway 动态路由"></a>Spring Cloud Gateway 动态路由</h3><p>默认情况下，Spring Cloud Gateway 会根据服务注册中心（例如 Eureka Server）中维护的服务列表，以服务名（spring.application.name）作为路径创建动态路由进行转发，从而实现动态路由功能。</p><p>我们可以在配置文件中，将 Route 的 uri 地址修改为以下形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lb://service-name</span><br></pre></td></tr></table></figure><p>以上配置说明如下：</p><ul><li>lb：uri 的协议，表示开启 Spring Cloud Gateway 的负载均衡功能。</li><li>service-name：服务名，Spring Cloud Gateway 会根据它获取到具体的微服务地址。</li></ul><p>1.配置，使用注册中心中的微服务名创建动态路由进行转发</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span> <span class="comment">#端口号</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">microServiceCloudGateway</span>  <span class="comment">#服务注册中心注册的服务名</span></span><br><span class="line">   </span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span> <span class="comment">#网关路由配置</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#默认值为 true，即默认开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment">#将 micro-service-cloud-provider-dept-8001 提供的服务隐藏起来，不暴露给客户端，只给客户端暴露 API 网关的地址 9527</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">provider_dept_list_routh</span>   <span class="comment">#路由 id,没有固定规则，但唯一，建议与服务名对应</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://MICROSERVICECLOUDPROVIDERDEPT</span> <span class="comment">#动态路由，使用服务名代替上面的具体带端口   http://eureka7001.com:9527/dept/list</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="comment">#以下是断言条件，必选全部符合条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/dept/list/**</span>    <span class="comment">#断言，路径匹配 注意：Path 中 P 为大写</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Method=GET</span> <span class="comment">#只能时 GET 请求时，才能访问</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">micro-service-cloud-gateway-9527</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">micro-service-cloud-gateway</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span></span><br></pre></td></tr></table></figure><h3 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter 过滤器"></a>Filter 过滤器</h3><p>通常情况下，出于安全方面的考虑，服务端提供的服务往往都会有一定的校验逻辑，例如用户登陆状态校验、签名校验等。</p><p>在微服务架构中，系统由多个微服务组成，所有这些服务都需要这些校验逻辑，此时我们就可以将这些校验逻辑写到 Spring Cloud Gateway 的 Filter 过滤器中。</p><h4 id="Filter-的分类"><a href="#Filter-的分类" class="headerlink" title="Filter 的分类"></a>Filter 的分类</h4><p>Spring Cloud Gateway 提供了以下两种类型的过滤器，可以对请求和响应进行精细化控制。</p><table><thead><tr><th>过滤器类型</th><th>说明</th></tr></thead><tbody><tr><td>Pre 类型</td><td>这种过滤器在请求被转发到微服务之前可以对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等操作。</td></tr><tr><td>Post 类型</td><td>这种过滤器在微服务对请求做出响应后可以对响应进行拦截和再处理，例如修改响应内容或响应头、日志输出、流量监控等。</td></tr></tbody></table><p>按照作用范围划分，Spring Cloud gateway 的 Filter 可以分为 2 类：</p><ul><li>GatewayFilter：应用在单个路由或者一组路由上的过滤器。</li><li>GlobalFilter：应用在所有的路由上的过滤器。</li></ul><h4 id="GatewayFilter-网关过滤器"><a href="#GatewayFilter-网关过滤器" class="headerlink" title="GatewayFilter 网关过滤器"></a>GatewayFilter 网关过滤器</h4><p>GatewayFilter 是 Spring Cloud Gateway 网关中提供的一种应用在单个或一组路由上的过滤器。它可以对单个路由或者一组路由上传入的请求和传出响应进行拦截，并实现一些与业务无关的功能，比如登陆状态校验、签名校验、权限校验、日志输出、流量监控等。</p><p>1.配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span> </span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">xxxx</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">xxxx</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=xxxx</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestParameter=X-Request-Id,1024</span> <span class="comment">#过滤器工厂会在匹配的请求头加上一对请求头，名称为 X-Request-Id 值为 1024</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrefixPath=/dept</span> <span class="comment">#在请求路径前面加上 /dept</span></span><br><span class="line">            <span class="string">……</span></span><br></pre></td></tr></table></figure><p>Spring Cloud Gateway 内置了多达 31 种 GatewayFilter，下表中列举了几种常用的网关过滤器及其使用示例。</p><table><thead><tr><th>路由过滤器</th><th>描述</th><th>参数</th><th>使用示例</th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>拦截传入的请求，并在请求上添加一个指定的请求头参数。</td><td>name：需要添加的请求头参数的 key； value：需要添加的请求头参数的 value。</td><td>- AddRequestHeader&#x3D;my-request-header,1024</td></tr><tr><td>AddRequestParameter</td><td>拦截传入的请求，并在请求上添加一个指定的请求参数。</td><td>name：需要添加的请求参数的 key； value：需要添加的请求参数的 value。</td><td>- AddRequestParameter&#x3D;my-request-param,c.biancheng.net</td></tr><tr><td>AddResponseHeader</td><td>拦截响应，并在响应上添加一个指定的响应头参数。</td><td>name：需要添加的响应头的 key； value：需要添加的响应头的 value。</td><td>- AddResponseHeader&#x3D;my-response-header,c.biancheng.net</td></tr><tr><td>PrefixPath</td><td>拦截传入的请求，并在请求路径增加一个指定的前缀。</td><td>prefix：需要增加的路径前缀。</td><td>- PrefixPath&#x3D;&#x2F;consumer</td></tr><tr><td>PreserveHostHeader</td><td>转发请求时，保持客户端的 Host 信息不变，然后将它传递到提供具体服务的微服务中。</td><td>无</td><td>- PreserveHostHeader</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求头中指定的参数。</td><td>name：需要移除的请求头的 key。</td><td>- RemoveRequestHeader&#x3D;my-request-header</td></tr><tr><td>RemoveResponseHeader</td><td>移除响应头中指定的参数。</td><td>name：需要移除的响应头。</td><td>- RemoveResponseHeader&#x3D;my-response-header</td></tr><tr><td>RemoveRequestParameter</td><td>移除指定的请求参数。</td><td>name：需要移除的请求参数。</td><td>- RemoveRequestParameter&#x3D;my-request-param</td></tr><tr><td>RequestSize</td><td>配置请求体的大小，当请求体过大时，将会返回 413 Payload Too Large。</td><td>maxSize：请求体的大小。</td><td>- name: RequestSize   args:    maxSize: 5000000</td></tr></tbody></table><p>1.application.yml 中在添加一个动态路由，配置内容如下。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">provider_dept_get_routh</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://MICROSERVICECLOUDPROVIDERDEPT</span> <span class="comment">#使用服务名代替上面的具体带端口</span></span><br><span class="line">  <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/get/**</span></span><br><span class="line">  <span class="attr">filters:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PrefixPath=/dept</span> <span class="comment">#在请求路径上增加一个前缀 /dept</span></span><br></pre></td></tr></table></figure><h4 id="GlobalFilter-全局过滤器"><a href="#GlobalFilter-全局过滤器" class="headerlink" title="GlobalFilter 全局过滤器"></a>GlobalFilter 全局过滤器</h4><p>GlobalFilter 是一种作用于所有的路由上的全局过滤器，通过它，我们可以实现一些统一化的业务功能，例如权限认证、IP 访问限制等。当某个请求被路由匹配时，那么所有的 GlobalFilter 会和该路由自身配置的 GatewayFilter 组合成一个过滤器链。</p><p>Spring Cloud Gateway 为我们提供了多种默认的 GlobalFilter，例如与转发、路由、负载均衡等相关的全局过滤器。但在实际的项目开发中，通常我们都会自定义一些自己的 GlobalFilter 全局过滤器以满足我们自身的业务需求，而很少直接使用 Spring Cloud Config 提供这些默认的 GlobalFilter。</p><p>1.新建一个名为 MyGlobalFilter 全局过滤器配置类，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自定义全局网关过滤器（GlobalFilter）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;进入自定义的全局过滤器 MyGlobalFilter&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (uname == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;参数 uname 不能为 null！&quot;</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//过滤器的顺序，0 表示第一个</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sentinel：Spring-Cloud-Alibaba高可用流量控制组件"><a href="#Sentinel：Spring-Cloud-Alibaba高可用流量控制组件" class="headerlink" title="Sentinel：Spring Cloud Alibaba高可用流量控制组件"></a>Sentinel：Spring Cloud Alibaba高可用流量控制组件</h2><p>从功能上来说，Sentinel 与 Spring Cloud Netfilx Hystrix 类似，但 Sentinel 要比 Hystrix 更加强大，例如 Sentinel 提供了流量控制功能、比 Hystrix 更加完善的实时监控功能等等。</p><h3 id="Sentinel-的组成"><a href="#Sentinel-的组成" class="headerlink" title="Sentinel 的组成"></a>Sentinel 的组成</h3><p>Sentinel 主要由以下两个部分组成：</p><ul><li>Sentinel 核心库：Sentinel 的核心库不依赖任何框架或库，能够运行于 Java 8 及以上的版本的运行时环境中，同时对 Spring Cloud、Dubbo 等微服务框架提供了很好的支持。</li><li>Sentinel 控制台（Dashboard）：Sentinel 提供的一个轻量级的开源控制台，它为用户提供了机器自发现、簇点链路自发现、监控、规则配置等功能。</li></ul><p>Sentinel 核心库不依赖 Sentinel Dashboard，但两者结合使用可以有效的提高效率，让 Sentinel 发挥它最大的作用。</p><h3 id="Sentinel-的基本概念"><a href="#Sentinel-的基本概念" class="headerlink" title="Sentinel 的基本概念"></a>Sentinel 的基本概念</h3><table><thead><tr><th>基本概念</th><th>描述</th></tr></thead><tbody><tr><td>资源</td><td>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如由应用程序提供的服务或者是服务里的方法，甚至可以是一段代码。  我们可以通过 Sentinel 提供的 API 来定义一个资源，使其能够被 Sentinel 保护起来。通常情况下，我们可以使用方法名、URL 甚至是服务名来作为资源名来描述某个资源。</td></tr><tr><td>规则</td><td>围绕资源而设定的规则。Sentinel 支持流量控制、熔断降级、系统保护、来源访问控制和热点参数等多种规则，所有这些规则都可以动态实时调整。</td></tr></tbody></table><h3 id="SentinelResource-注解"><a href="#SentinelResource-注解" class="headerlink" title="@SentinelResource 注解"></a>@SentinelResource 注解</h3><table><thead><tr><th>value</th><th>用于指定资源的名称</th><th>必填</th><th>-</th></tr></thead><tbody><tr><td>entryType</td><td>entry 类型</td><td>可选项（默认为 EntryType.OUT）</td><td>-</td></tr><tr><td>blockHandler</td><td>服务限流后会抛出 BlockException 异常，而 blockHandler 则是用来指定一个函数来处理 BlockException 异常的。  简单点说，该属性用于指定服务限流后的后续处理逻辑。</td><td>可选项</td><td>blockHandler 函数访问范围需要是 public；返回类型需要与原方法相匹配；参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException；blockHandler 函数默认需要和原方法在同一个类中，若希望使用其他类的函数，则可以指定 blockHandler 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</td></tr><tr><td>blockHandlerClass</td><td>若 blockHandler 函数与原方法不在同一个类中，则需要使用该属性指定 blockHandler 函数所在的类。</td><td>可选项</td><td>不能单独使用，必须与 blockHandler 属性配合使用；该属性指定的类中的 blockHandler 函数必须为 static 函数，否则无法解析。</td></tr><tr><td>fallback</td><td>用于在抛出异常（包括 BlockException）时，提供 fallback 处理逻辑。  fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。</td><td>可选项</td><td>返回值类型必须与原函数返回值类型一致；方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常；fallback 函数默认需要和原方法在同一个类中，若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</td></tr><tr><td>fallbackClass</td><td>若 fallback 函数与原方法不在同一个类中，则需要使用该属性指定 blockHandler 函数所在的类。</td><td>可选项</td><td>不能单独使用，必须与 fallback 或 defaultFallback 属性配合使用；该属性指定的类中的 fallback 函数必须为 static 函数，否则无法解析。</td></tr><tr><td>defaultFallback</td><td>默认的 fallback 函数名称，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。  默认 fallback 函数可以针对所以类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。</td><td>可选项</td><td>返回值类型必须与原函数返回值类型一致；方法参数列表需要为空，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常；defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</td></tr><tr><td>exceptionsToIgnore</td><td>用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。</td><td>可选项</td><td></td></tr></tbody></table><h3 id="Sentinel-控制台"><a href="#Sentinel-控制台" class="headerlink" title="Sentinel 控制台"></a>Sentinel 控制台</h3><p>Sentinel 控制台提供的功能如下:</p><ul><li><strong>查看机器列表以及健康情况</strong>：Sentinel 控制台能够收集 Sentinel 客户端发送的心跳包，判断机器是否在线。</li><li><strong>监控（单机和集群聚合）</strong>：Sentinel 控制台通过 Sentinel 客户端暴露的监控 API，可以实现秒级的实时监控。</li><li><strong>规则管理和推送</strong>：通过 Sentinel 控制台，我们还能够针对资源定义和推送规则。</li><li><strong>鉴权</strong>：从 Sentinel 1.6.0 起，Sentinel 控制台引入基本的登录功能，默认用户名和密码都是 sentinel。</li></ul><h3 id="Sentinel-的开发流程"><a href="#Sentinel-的开发流程" class="headerlink" title="Sentinel 的开发流程"></a>Sentinel 的开发流程</h3><p>Sentinel 的开发流程如下：</p><ol><li><strong>引入 Sentinel 依赖</strong>：在项目中引入 Sentinel 的依赖，将 Sentinel 整合到项目中；</li><li><strong>定义资源</strong>：通过对主流框架提供适配或 Sentinel 提供的显式 API 和注解，可以定义需要保护的资源，此外 Sentinel 还提供了资源的实时统计和调用链路分析；</li><li><strong>定义规则</strong>：根据实时统计信息，对资源定义规则，例如流控规则、熔断规则、热点规则、系统规则以及授权规则等。</li><li><strong>检验规则是否在生效</strong>：运行程序，检验规则是否生效，查看效果。</li></ol><h3 id="引入-Sentinel-依赖"><a href="#引入-Sentinel-依赖" class="headerlink" title="引入 Sentinel 依赖"></a>引入 Sentinel 依赖</h3><p>以 Spring Cloud 为例，我们只需要引入 spring-cloud-starter-alibaba-sentinel 的依赖，就可以方便地将 Sentinel 整合到项目中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Nacos 服务发现依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Snetinel 依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span> <span class="comment">#端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sentinel-service</span> <span class="comment">#服务名</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#Nacos服务注册中心(集群)地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:1111</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment">#配置 Sentinel dashboard 地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment">#默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="定义资源"><a href="#定义资源" class="headerlink" title="定义资源"></a>定义资源</h3><p>资源是 Sentinel 中的核心概念之一。在项目开发时，我们只需要考虑这个服务、方法或代码是否需要保护，如果需要保护，就可以将它定义为一个资源。</p><p>Sentinel 为我们提供了多种定义资源的方式：</p><ul><li>适配主流框架自动定义资源</li><li>通过 SphU 手动定义资源</li><li>通过 SphO 手动定义资源</li><li>注解方式定义资源</li></ul><h4 id="适配主流框架自动定义资源"><a href="#适配主流框架自动定义资源" class="headerlink" title="适配主流框架自动定义资源"></a>适配主流框架自动定义资源</h4><p>Sentinel 对大部分的主流框架都进行了适配，我们只要引入相关的适配模块（例如 spring-cloud-starter-alibaba-sentinel），Snetinel 就会自动将项目中的服务（包括调用端和服务端）定义为资源，资源名就是服务的请求路径。此时，我们只要再定义一些规则，这些资源就可以享受到 Sentinel 的保护。</p><h4 id="通过-SphU-手动定义资源"><a href="#通过-SphU-手动定义资源" class="headerlink" title="通过 SphU 手动定义资源"></a>通过 SphU 手动定义资源</h4><p>Sentinel 提供了一个名为 SphU 的类，它包含的 try-catch 风格的 API ，可以帮助我们手动定义资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 SphU 手动定义资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testAbySphU</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            entry = SphU.entry(<span class="string">&quot;testAbySphU&quot;</span>);</span><br><span class="line">            <span class="comment">//您的业务逻辑 - 开始</span></span><br><span class="line">            log.info(<span class="string">&quot;c语言中文网提醒您，服务访问成功------testA：&quot;</span>+serverPort);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，服务访问成功------testA：&quot;</span>+serverPort;</span><br><span class="line">            <span class="comment">//您的业务逻辑 - 结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException e1) &#123;</span><br><span class="line">            <span class="comment">//流控逻辑处理 - 开始</span></span><br><span class="line">            log.info(<span class="string">&quot;c语言中文网提醒您，testA 服务被限流&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，testA 服务被限流&quot;</span>;</span><br><span class="line">            <span class="comment">//流控逻辑处理 - 结束</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                entry.exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="通过-SphO-手动定义资源"><a href="#通过-SphO-手动定义资源" class="headerlink" title="通过 SphO 手动定义资源"></a>通过 SphO 手动定义资源</h4><p>Sentinel 还提供了一个名为 SphO 的类，它包含了 if-else 风格的 API，能帮助我们手动定义资源。通过这种方式定义的资源，发生了限流之后会返回 false，此时我们可以根据返回值，进行限流之后的逻辑处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 SphO 手动定义资源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testBbySphO</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (SphO.entry(<span class="string">&quot;testBbySphO&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 务必保证finally会被执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;c语言中文网提醒您，服务访问成功------testB：&quot;</span> + serverPort);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，服务访问成功------testB：&quot;</span> + serverPort;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                SphO.exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 资源访问阻止，被限流或被降级</span></span><br><span class="line">            <span class="comment">//流控逻辑处理 - 开始</span></span><br><span class="line">            log.info(<span class="string">&quot;c语言中文网提醒您，testB 服务被限流&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，testB 服务被限流&quot;</span>;</span><br><span class="line">            <span class="comment">//流控逻辑处理 - 结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="注解方式定义资源（推荐）"><a href="#注解方式定义资源（推荐）" class="headerlink" title="注解方式定义资源（推荐）"></a>注解方式定义资源（推荐）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testC&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testCbyAnnotation&quot;)</span> <span class="comment">//通过注解定义资源</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testC</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;c语言中文网提醒您，服务访问成功------testC：&quot;</span> + serverPort);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，服务访问成功------testC：&quot;</span> + serverPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sentinel-流量控制"><a href="#Sentinel-流量控制" class="headerlink" title="Sentinel 流量控制"></a>Sentinel 流量控制</h3><p>任何系统处理请求的能力都是有限的，但任意时间内到达系统的请求量往往是随机且不可控的，如果在某一个瞬时时刻请求量急剧增，那么系统就很有可能被瞬时的流量高峰冲垮。为了避免此类情况发生，我们都需要根据系统的处理能力对请求流量进行控制，这就是我们常说的“流量控制”，简称“流控”。</p><p>Sentinel 作为一种轻量级高可用流量控制组件，流量控制是它最主要的工作之一。</p><p>我们可以针对资源定义流控规则，Sentinel 会根据这些规则对流量相关的各项指标进行监控。当这些指标当达到或超过流控规则规定的阈值时，Sentinel 会对请求的流量进行限制（即“限流”），以避免系统被瞬时的流量高峰冲垮，保障系统的高可用性。</p><p>一条流量规则主要由下表中的属性组成，我们可以通过组合这些属性来实现不同的限流效果。</p><table><thead><tr><th>属性</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>资源名</td><td>流控规则的作用对象。</td><td>-</td></tr><tr><td>阈值</td><td>流控的阈值。</td><td>-</td></tr><tr><td>阈值类型</td><td>流控阈值的类型，包括 QPS 或并发线程数。</td><td>QPS</td></tr><tr><td>针对来源</td><td>流控针对的调用来源。</td><td>default，表示不区分调用来源</td></tr><tr><td>流控模式</td><td>调用关系限流策略，包括直接、链路和关联。</td><td>直接</td></tr><tr><td>流控效果</td><td>流控效果（直接拒绝、Warm Up、匀速排队），不支持按调用关系限流。</td><td>直接拒绝</td></tr></tbody></table><blockquote><p>注：QPS 表示并发请求数，换句话说就是，每秒钟最多通过的请求数。</p></blockquote><p>同一个资源可以创建多条流控规则，Sentinel 会遍历这些规则，直到有规则触发限流或者所有规则遍历完毕为止。</p><p>Sentinel 触发限流时，资源会抛出 BlockException 异常，此时我们可以捕捉 BlockException 来自定义被限流之后的处理逻辑。</p><h4 id="通过-Sentinel-控制台定义流控规则"><a href="#通过-Sentinel-控制台定义流控规则" class="headerlink" title="通过 Sentinel 控制台定义流控规则"></a>通过 Sentinel 控制台定义流控规则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过 Sentinel 控制台定义流控规则</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/testD&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testD</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;c语言中文网提醒您，服务访问成功------testD：&quot;</span> + serverPort);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，服务访问成功------testD：&quot;</span> + serverPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用浏览器访问“<a href="http://localhost:8080”，登陆">http://localhost:8080”，登陆</a> Sentinel 控制台主页，点击 sentinel-sevice 下的“簇点链路”，</p><p>若页面中出现以上信息，则说明该服务已被限流，但这种提示是 Sentinel 系统自动生成的，用户体验不好。</p><p>在服务代码中使用 @SentinelResource 注解定义资源名称，并在 blockHandler 属性指定一个限流函数，自定义服务限流信息，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过 Sentinel 控制台定义流控规则</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/testD&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testD-resource&quot;, blockHandler = &quot;blockHandlerTestD&quot;)</span> <span class="comment">//通过注解定义资源</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testD</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;c语言中文网提醒您，服务访问成功------testD：&quot;</span> + serverPort);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，服务访问成功------testD：&quot;</span> + serverPort;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 限流之后的逻辑</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">blockHandlerTestD</span><span class="params">(BlockException exception)</span> &#123;</span><br><span class="line">    log.info(Thread.currentThread().getName() + <span class="string">&quot;c语言中文网提醒您，TestD服务访问失败! 您已被限流，请稍后重试&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，TestD服务访问失败! 您已被限流，请稍后重试&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，我们通过 @SentinelResource 注解的 blockHandler 属性指定了一个 blockHandler 函数，进行限流之后的后续处理。</p><p> 使用 @SentinelResource 注解的 blockHandler 属性时，需要注意以下事项：</p><ul><li>blockHandler 函数访问范围需要是 public；</li><li>返回类型需要与原方法相匹配；</li><li>参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException；</li><li>blockHandler 函数默认需要和原方法在同一个类中，若希望使用其他类的函数，则可以指定 blockHandler 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</li><li>请务必添加 blockHandler 属性来指定自定义的限流处理方法，若不指定，则会跳转到错误页（用户体验不好）。</li></ul><h4 id="通过代码定义流控规则"><a href="#通过代码定义流控规则" class="headerlink" title="通过代码定义流控规则"></a>通过代码定义流控规则</h4><p>我们还可以在服务代码中，调用 <strong>FlowRuleManager 类的 loadRules() 方法来定义流控规则</strong>，该方法需要一个 FlowRule 类型的 List 集合作为其参数，示例代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadRules</span><span class="params">(List&lt;FlowRule&gt; rules)</span> &#123;</span><br><span class="line">    currentProperty.updateValue(rules); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FlowRule 可以通过以下属性定义流控规则，如下表。</p><table><thead><tr><th>属性</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>resource</td><td>资源名，即流控规则的作用对象</td><td>-</td></tr><tr><td>count</td><td>限流的阈值。</td><td>-</td></tr><tr><td>grade</td><td>流控阈值的类型，包括 QPS 或并发线程数</td><td>QPS</td></tr><tr><td>limitApp</td><td>流控针对的调用来源</td><td>default，表示不区分调用来源</td></tr><tr><td>strategy</td><td>调用关系限流策略，包括直接、链路和关联</td><td>直接</td></tr><tr><td>controlBehavior</td><td>流控效果（直接拒绝、Warm Up、匀速排队），不支持按调用关系限流</td><td>直接拒绝</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过代码定义流量控制规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initFlowRules</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;FlowRule&gt; rules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//定义一个限流规则对象</span></span><br><span class="line">    <span class="type">FlowRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlowRule</span>();</span><br><span class="line">    <span class="comment">//资源名称</span></span><br><span class="line">    rule.setResource(<span class="string">&quot;testD-resource&quot;</span>);</span><br><span class="line">     <span class="comment">//限流阈值的类型</span></span><br><span class="line">    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    <span class="comment">// 设置 QPS 的阈值为 2</span></span><br><span class="line">    rule.setCount(<span class="number">2</span>);</span><br><span class="line">    rules.add(rule);</span><br><span class="line">    <span class="comment">//定义限流规则</span></span><br><span class="line">    FlowRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/testD&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testD-resource&quot;, blockHandler = &quot;blockHandlerTestD&quot;)</span> <span class="comment">//通过注解定义资源</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testD</span><span class="params">()</span> &#123;</span><br><span class="line">    initFlowRules(); <span class="comment">//调用初始化流控规则的方法</span></span><br><span class="line">    log.info(<span class="string">&quot;c语言中文网提醒您，服务访问成功------testD：&quot;</span> + serverPort);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，服务访问成功------testD：&quot;</span> + serverPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="熔断降级规则"><a href="#熔断降级规则" class="headerlink" title="熔断降级规则"></a>熔断降级规则</h3><p>Sentinel 的熔断将机制会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），暂时切断对这个资源的调用，以避免局部不稳定因素导致整个系统的雪崩。</p><p>熔断降级作为服务保护自身的手段，通常在客户端（调用端）进行配置，资源被熔断降级最直接的表现就是抛出 DegradeException 异常。</p><h4 id="Sentinel-熔断策略"><a href="#Sentinel-熔断策略" class="headerlink" title="Sentinel 熔断策略"></a>Sentinel 熔断策略</h4><table><thead><tr><th>熔断策略</th><th>说明</th></tr></thead><tbody><tr><td>慢调用比例 (SLOW_REQUEST_RATIO）</td><td>选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大响应时间），若请求的响应时间大于该值则统计为慢调用。  当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。  经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则再次被熔断。</td></tr><tr><td>异常比例 (ERROR_RATIO)</td><td>当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目且异常的比例大于阈值，则在接下来的熔断时长内请求会自动被熔断。  经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</td></tr><tr><td>异常数 (ERROR_COUNT)</td><td>当单位统计时长内的异常数目超过阈值之后会自动进行熔断。  经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</td></tr></tbody></table><h4 id="Sentinel-熔断状态"><a href="#Sentinel-熔断状态" class="headerlink" title="Sentinel 熔断状态"></a>Sentinel 熔断状态</h4><p>![image-20220913112004206](Spring Cloud 微服务.assets&#x2F;image-20220913112004206.png)</p><table><thead><tr><th>状态</th><th>说明</th><th>触发条件</th></tr></thead><tbody><tr><td>熔断关闭状态 （CLOSED）</td><td>处于关闭状态时，请求可以正常调用资源。</td><td>满足以下任意条件，Sentinel 熔断器进入熔断关闭状态：全部请求访问成功。单位统计时长（statIntervalMs）内请求数目小于设置的最小请求数目。未达到熔断标准，例如服务超时比例、异常数、异常比例未达到阈值。处于探测恢复状态时，下一个请求访问成功。</td></tr><tr><td>熔断开启状态 （OPEN）</td><td>处于熔断开启状态时，熔断器会一定的时间（规定的熔断时长）内，暂时切断所有请求对该资源的调用，并调用相应的降级逻辑使请求快速失败避免系统崩溃。</td><td>满足以下任意条件，Sentinel 熔断器进入熔断开启状态：单位统计时长内请求数目大于设置的最小请求数目，且已达到熔断标准，例如请求超时比例、异常数、异常比例达到阈值。处于探测恢复状态时，下一个请求访问失败。</td></tr><tr><td>探测恢复状态 （HALF-OPEN）</td><td>处于探测恢复状态时，Sentinel 熔断器会允许一个请求调用资源。则若接下来的一个请求成功完成（没有错误）则结束熔断，熔断器进入熔断关闭（CLOSED）状态；否则会再次被熔断，熔断器进入熔断开启（OPEN）状态。</td><td>在熔断开启一段时间（降级窗口时间或熔断时长，单位为 s）后，Sentinel 熔断器自动会进入探测恢复状态。</td></tr></tbody></table><h4 id="Sentinel-熔断规则属性"><a href="#Sentinel-熔断规则属性" class="headerlink" title="Sentinel 熔断规则属性"></a>Sentinel 熔断规则属性</h4><table><thead><tr><th>属性</th><th>说明</th><th>默认值</th><th>使用范围</th></tr></thead><tbody><tr><td>资源名</td><td>规则的作用对象。</td><td>-</td><td>所有熔断策略</td></tr><tr><td>熔断策略</td><td>Sentinel 支持3 中熔断策略：慢调用比例、异常比例、异常数策略。</td><td>慢调用比例</td><td>所有熔断策略</td></tr><tr><td>最大 RT</td><td>请求的最大相应时间，请求的响应时间大于该值则统计为慢调用。</td><td>-</td><td>慢调用比例</td></tr><tr><td>熔断时长</td><td>熔断开启状态持续的时间，超过该时间熔断器会切换为探测恢复状态（HALF-OPEN），单位为 s。</td><td>-</td><td>所有熔断策略</td></tr><tr><td>最小请求数</td><td>熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入）。</td><td>5</td><td>所有熔断策略</td></tr><tr><td>统计时长</td><td>熔断触发需要统计的时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）。</td><td>1000 ms</td><td>所有熔断策略</td></tr><tr><td>比例阈值</td><td>分为慢调用比例阈值和异常比例阈值，即慢调用或异常调用占所有请求的百分比，取值范围 [0.0,1.0]。</td><td>-</td><td>慢调用比例 、异常比例</td></tr><tr><td>异常数</td><td>请求或调用发生的异常的数量。</td><td>-</td><td>异常数</td></tr></tbody></table><h4 id="Sentinel-实现熔断降级过程"><a href="#Sentinel-实现熔断降级过程" class="headerlink" title="Sentinel 实现熔断降级过程"></a>Sentinel 实现熔断降级过程</h4><p>Sentinel 实现熔断降级的步骤如下：</p><ol><li>在项目中，使用 @SentinelResource 注解的 fallback 属性可以为资源指定熔断降级逻辑（方法）。</li><li>通过 Sentinel 控制台或代码定义熔断规则，包括熔断策略、最小请求数、阈值、熔断时长以及统计时长等。</li><li>若单位统计时长（statIntervalMs）内，请求数目大于设置的最小请求数目且达到熔断标准（例如请求超时比例、异常数、异常比例达到阈值），Sentinel 熔断器进入熔断开启状态（OPEN）。</li><li>处于熔断开启状态时， @SentinelResource 注解的 fallback 属性指定的降级逻辑会临时充当主业务逻辑，而原来的主逻辑则暂时不可用。当有请求访问该资源时，会直接调用降级逻辑使请求快速失败，而不会调用原来的主业务逻辑。</li><li>在经过一段时间（在熔断规则中设置的熔断时长）后，熔断器会进入探测恢复状态（HALF-OPEN），此时 Sentinel 会允许一个请求对原来的主业务逻辑进行调用，并监控其调用结果。</li><li>若请求调用成功，则熔断器进入熔断关闭状态（CLOSED ），服务原来的主业务逻辑恢复，否则重新进入熔断开启状态（OPEN）。</li></ol><h4 id="通过-Sentinel-控制台定义熔断降级规则"><a href="#通过-Sentinel-控制台定义熔断降级规则" class="headerlink" title="通过 Sentinel 控制台定义熔断降级规则"></a>通过 Sentinel 控制台定义熔断降级规则</h4><p>我们可以通过 Sentinel 控制台直接对资源定义熔断降级规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptFeignController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    DeptFeignService deptFeignService;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;consumer/feign/dept/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;fallback&quot;, fallback = &quot;handlerFallback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Dept&gt; <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        monitor();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------&gt;&gt;&gt;&gt;主业务逻辑&quot;</span>);</span><br><span class="line">        CommonResult&lt;Dept&gt; result = deptFeignService.get(id);</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">6</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;---------&gt;&gt;&gt;&gt;主业务逻辑，抛出非法参数异常&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;IllegalArgumentException，非法参数异常....&quot;</span>);</span><br><span class="line">            <span class="comment">//如果查到的记录也是 null 也控制正异常</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;---------&gt;&gt;&gt;&gt;主业务逻辑，抛出空指针异常&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;NullPointerException，该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;consumer/feign/dept/list&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;List&lt;Dept&gt;&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deptFeignService.list();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理异常的回退方法（服务降级）</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">handlerFallback</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id, Throwable e)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;---------&gt;&gt;&gt;&gt;服务降级逻辑&quot;</span>);</span><br><span class="line">        <span class="type">Dept</span> <span class="variable">dept</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dept</span>(id, <span class="string">&quot;null&quot;</span>, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">444</span>, <span class="string">&quot;C语言中文网提醒您，服务被降级！异常信息为：&quot;</span> + e.getMessage(), dept);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义事件监听器，监听熔断器状态转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">monitor</span><span class="params">()</span> &#123;</span><br><span class="line">        EventObserverRegistry.getInstance().addStateChangeObserver(<span class="string">&quot;logging&quot;</span>,</span><br><span class="line">                (prevState, newState, rule, snapshotValue) -&gt; &#123;</span><br><span class="line">                    <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (newState == CircuitBreaker.State.OPEN) &#123;</span><br><span class="line">                        <span class="comment">// 变换至 OPEN state 时会携带触发时的值</span></span><br><span class="line">                        System.err.println(String.format(<span class="string">&quot;%s -&gt; OPEN at %s, 发送请求次数=%.2f&quot;</span>, prevState.name(),</span><br><span class="line">                                format.format(<span class="keyword">new</span> <span class="title class_">Date</span>(TimeUtil.currentTimeMillis())), snapshotValue));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.err.println(String.format(<span class="string">&quot;%s -&gt; %s at %s&quot;</span>, prevState.name(), newState.name(),</span><br><span class="line">                                format.format(<span class="keyword">new</span> <span class="title class_">Date</span>(TimeUtil.currentTimeMillis()))));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 @SentinelResource 注解的 blockHandler 属性时，需要注意以下事项：</p><ul><li>返回值类型必须与原函数返回值类型一致；</li><li>方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常；</li><li>fallback 函数默认需要和原方法在同一个类中，若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</li></ul><p>使用浏览器访问 Sentinel 控制台，在“簇点链路”列表中，点击 fallback 资源的 “**+**熔断”按钮，</p><h4 id="通过代码定义熔断规则"><a href="#通过代码定义熔断规则" class="headerlink" title="通过代码定义熔断规则"></a>通过代码定义熔断规则</h4><p>Sentinel 核心库中提供了的一个名为 DegradeRuleManager 类，我们可以通过调用它的 loadRules() 方法来定义熔断降级规则，该方法需要一个 DegradeRule 类型的 List 参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadRules</span><span class="params">(List&lt;DegradeRule&gt; rules)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        currentProperty.updateValue(rules);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var2) &#123;</span><br><span class="line">        RecordLog.error(<span class="string">&quot;[DegradeRuleManager] Unexpected error when loading degrade rules&quot;</span>, var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DegradeRule 类可以用来定义一条熔断规则，它包含多个与熔断规则相关的属性，如下表。</p><table><thead><tr><th>属性</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>resource</td><td>资源名，即规则的作用对象</td><td></td></tr><tr><td>grade</td><td>熔断策略，支持慢调用比例&#x2F;异常比例&#x2F;异常数策略</td><td>慢调用比例</td></tr><tr><td>count</td><td>慢调用比例模式下为慢调用临界 RT（超出该值计为慢调用）；异常比例&#x2F;异常数模式下为对应的阈值</td><td></td></tr><tr><td>timeWindow</td><td>熔断时长，单位为 s</td><td></td></tr><tr><td>minRequestAmount</td><td>熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入）</td><td>5</td></tr><tr><td>statIntervalMs</td><td>统计时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）</td><td>1000 ms</td></tr><tr><td>slowRatioThreshold</td><td>慢调用比例阈值，仅慢调用比例模式有效（1.8.0 引入）</td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化熔断策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initDegradeRule</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;DegradeRule&gt; rules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">DegradeRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DegradeRule</span>(<span class="string">&quot;fallback&quot;</span>);</span><br><span class="line">    <span class="comment">//熔断策略为异常比例</span></span><br><span class="line">    rule.setGrade(CircuitBreakerStrategy.ERROR_RATIO.getType());</span><br><span class="line">    <span class="comment">//异常比例阈值</span></span><br><span class="line">    rule.setCount(<span class="number">0.7</span>);</span><br><span class="line">    <span class="comment">//最小请求数</span></span><br><span class="line">    rule.setMinRequestAmount(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//统计市场，单位毫秒</span></span><br><span class="line">    rule.setStatIntervalMs(<span class="number">30000</span>);</span><br><span class="line">    <span class="comment">//熔断市场，单位秒</span></span><br><span class="line">    rule.setTimeWindow(<span class="number">10</span>);</span><br><span class="line">    rules.add(rule);</span><br><span class="line">    DegradeRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;consumer/feign/dept/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;fallback&quot;, fallback = &quot;handlerFallback&quot;)</span></span><br><span class="line"><span class="keyword">public</span> CommonResult&lt;Dept&gt; <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">    initDegradeRule();</span><br><span class="line">    monitor();</span><br><span class="line">    System.out.println(<span class="string">&quot;---------&gt;&gt;&gt;&gt;主业务逻辑&quot;</span>);</span><br><span class="line">    CommonResult&lt;Dept&gt; result = deptFeignService.get(id);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">6</span>) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;---------&gt;&gt;&gt;&gt;主业务逻辑，抛出非法参数异常&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;IllegalArgumentException，非法参数异常....&quot;</span>);</span><br><span class="line">        <span class="comment">//如果查到的记录也是 null 也控制正异常</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="literal">null</span>) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;---------&gt;&gt;&gt;&gt;主业务逻辑，抛出空指针异常&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;NullPointerException，该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nacos：Spring-Cloud-Alibaba服务注册与配置中心"><a href="#Nacos：Spring-Cloud-Alibaba服务注册与配置中心" class="headerlink" title="Nacos：Spring Cloud Alibaba服务注册与配置中心"></a>Nacos：Spring Cloud Alibaba服务注册与配置中心</h2><p>Nacos 是一个更易于帮助构建云原生应用的动态服务发现、配置和服务管理平台</p><p>Nacos 英文全称为 Dynamic Naming and Configuration Service，是一个由阿里巴巴团队使用 Java 语言开发的开源项目</p><table><thead><tr><th>组成部分</th><th>全称</th><th>描述</th></tr></thead><tbody><tr><td>Na</td><td>naming&#x2F;nameServer</td><td>即服务注册中心，与 Spring Cloud Eureka 的功能类似。</td></tr><tr><td>co</td><td>configuration</td><td>即配置中心，与 Spring Cloud Config+Spring Cloud Bus 的功能类似。</td></tr><tr><td>s</td><td>service</td><td>即服务，表示 Nacos 实现的服务注册中心和配置中心都是以服务为核心的。</td></tr></tbody></table><p>我们可以将 Nacos 理解成服务注册中心和配置中心的组合体，它可以替换 <a href="http://c.biancheng.net/springcloud/eureka.html">Eureka</a> 作为服务注册中心，实现服务的注册与发现；还可以替换 <a href="http://c.biancheng.net/springcloud/config.html">Spring Cloud Config</a> 作为配置中心，实现配置的动态刷新。</p><h3 id="Nacos-的特性"><a href="#Nacos-的特性" class="headerlink" title="Nacos 的特性"></a>Nacos 的特性</h3><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><h4 id="服务健康监测"><a href="#服务健康监测" class="headerlink" title="服务健康监测"></a>服务健康监测</h4><h4 id="动态配置服务"><a href="#动态配置服务" class="headerlink" title="动态配置服务"></a>动态配置服务</h4><h4 id="动态-DNS-服务"><a href="#动态-DNS-服务" class="headerlink" title="动态 DNS 服务"></a>动态 DNS 服务</h4><h4 id="服务及其元数据管理"><a href="#服务及其元数据管理" class="headerlink" title="服务及其元数据管理"></a>服务及其元数据管理</h4><h3 id="Nacos-两大组件"><a href="#Nacos-两大组件" class="headerlink" title="Nacos 两大组件"></a>Nacos 两大组件</h3><p>![image-20220913113350951](Spring Cloud 微服务.assets&#x2F;image-20220913113350951.png)</p><h3 id="Nacos-服务注册中心"><a href="#Nacos-服务注册中心" class="headerlink" title="Nacos 服务注册中心"></a>Nacos 服务注册中心</h3><img src="/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220913113408462.png" alt="image-20220913113408462" style="zoom:67%;"><p>在图 1 中共涉及到以下 3 个角色：</p><ul><li>服务注册中心（Register Service）：它是一个 Nacos Server，可以为服务提供者和服务消费者提供服务注册和发现功能。</li><li>服务提供者（Provider Service）：它是一个 Nacos Client，用于对外服务。它将自己提供的服务注册到服务注册中心，以供服务消费者发现和调用。</li><li>服务消费者（Consumer Service）：它是一个 Nacos Client，用于消费服务。它可以从服务注册中心获取服务列表，调用所需的服务。</li></ul><p>Nacos 实现服务注册与发现的流程如下：</p><ol><li>从 Nacos 官方提供的下载页面中，下载 Nacos Server 并运行。</li><li>服务提供者 Nacos Client 启动时，会把服务以服务名（spring.application.name）的方式注册到服务注册中心（Nacos Server）；</li><li>服务消费者 Nacos Client 启动时，也会将自己的服务注册到服务注册中心；</li><li>服务消费者在注册服务的同时，它还会从服务注册中心获取一份服务注册列表信息，该列表中包含了所有注册到服务注册中心上的服务的信息（包括服务提供者和自身的信息）；</li><li>在获取了服务提供者的信息后，服务消费者通过 HTTP 或消息中间件远程调用服务提供者提供的服务。</li></ol><h4 id="搭建服务提供者"><a href="#搭建服务提供者" class="headerlink" title="搭建服务提供者"></a>搭建服务提供者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//开启服务发现功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringCloudAlibabaProvider8001Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringCloudAlibabaProvider8001Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="搭建服务消费者"><a href="#搭建服务消费者" class="headerlink" title="搭建服务消费者"></a>搭建服务消费者</h4><p> ApplicationContextBean 的配置类，并使用 @LoadBalanced 注解与 Ribbon 进行集成开启负载均衡功能，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextBean</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">//与 Ribbon 集成，并开启负载均衡功能</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Nacos-配置中心"><a href="#Nacos-配置中心" class="headerlink" title="Nacos 配置中心"></a>Nacos 配置中心</h3><p>Nacos Server 还可以作为配置中心，对 Spring Cloud 应用的外部配置进行统一地集中化管理。而我们只需要在应用的 POM 文件中引入 spring-cloud-starter-alibaba-nacos-config 即可实现配置的获取与动态刷新。</p><p>创建一个名为 ConfigClientController 的 Controller 类，并在该类上使用 @RefreshScope 注解实现配置的自动更新，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ConfigInfo;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config/info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConfigInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主启动类上，使用 @EnableDiscoveryClient 注解开启服务发现功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringCloudAlibabaNacosConfigClient3377Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringCloudAlibabaNacosConfigClient3377Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Nacos Server 中，配置的 dataId（即 Data ID）的完整格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</span><br></pre></td></tr></table></figure><p>dataId 格式中各参数说明如下：</p><ul><li>${prefix}：默认取值为微服务的服务名，即配置文件中 spring.application.name 的值，我们可以在配置文件中通过配置 spring.cloud.nacos.config.prefix 来指定。</li><li>${spring.profiles.active}：表示当前环境对应的 Profile，例如 dev、test、prod 等。当没有指定环境的 Profile 时，其对应的连接符也将不存在， dataId 的格式变成 ${prefix}.${file-extension}。</li><li>${file-extension}：表示配置内容的数据格式，我们可以在配置文件中通过配置项 spring.cloud.nacos.config.file-extension 来配置，例如 properties 和 yaml。</li></ul><h3 id="Nacos-Server-集群化部署"><a href="#Nacos-Server-集群化部署" class="headerlink" title="Nacos Server 集群化部署"></a>Nacos Server 集群化部署</h3><p>Nacos Server 的集群化部署有一个十分明显的优点，那就是可以保障系统的高可用性。在集群化部署中，只要不是所有的 Nacos Server 都停止工作，Nacos Client 就还可以从集群中正常的 Nacos Server 上获取服务信息及配置，而不会导致系统的整体瘫痪，这就是 Nacos Server 集群化部署的高可用性。</p><img src="/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220913113956551.png" alt="image-20220913113956551" style="zoom:67%;"><h2 id="Seata：Spring-Cloud-Alibaba分布式事务组件"><a href="#Seata：Spring-Cloud-Alibaba分布式事务组件" class="headerlink" title="Seata：Spring Cloud Alibaba分布式事务组件"></a>Seata：Spring Cloud Alibaba分布式事务组件</h2><p>随着业务的不断发展，单体架构已经无法满足我们的需求，分布式微服务架构逐渐成为大型互联网平台的首选，但所有使用分布式微服务架构的应用都必须面临一个十分棘手的问题，那就是“分布式事务”问题。</p><p>在分布式微服务架构中，几乎所有业务操作都需要多个服务协作才能完成。对于其中的某个服务而言，它的数据一致性可以交由其自身数据库事务来保证，但从整个分布式微服务架构来看，其全局数据的一致性却是无法保证的。</p><p>Seata 就是这样一个分布式事务处理框架，它是由阿里巴巴和蚂蚁金服共同开源的分布式事务解决方案，能够在微服务架构下提供高性能且简单易用的分布式事务服务。</p>]]></content:encoded>
      
      
      <category domain="https://HoldusTogether.github.io/categories/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/categories/Java/Spring-Cloud/">Spring Cloud</category>
      
      
      <category domain="https://HoldusTogether.github.io/tags/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/tags/Spring-Cloud/">Spring Cloud</category>
      
      <category domain="https://HoldusTogether.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
      
      
      <comments>https://holdustogether.github.io/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JVM随记</title>
      <link>https://holdustogether.github.io/2022/09/01/JVM/</link>
      <guid>https://holdustogether.github.io/2022/09/01/JVM/</guid>
      <pubDate>Thu, 01 Sep 2022 04:43:55 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h1&gt;&lt;h2 id=&quot;JVM内存模型&quot;&gt;&lt;a href=&quot;#JVM内存模型&quot; class=&quot;h</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p>（私有）</p><p>1.程序计数器：保存当前线程执行的字节码位置，每个线程工作时都有独立的计数器</p><p>2.栈：线程私有每个线程运行时所以要的内存，与线程一同创建，有多个栈帧组成</p><p>3.本地方法栈：保存本地方法信息，执行本地方法是使用本地方法栈（c++）</p><p>（共享）</p><p>4.堆：存储对象实例，是垃圾回收的主要区域，线程共享</p><p>5.方法区：存放虚拟机加载的类信息，类加载器，常量池（元空间&#x2F;永久代 实现）</p><img src="/2022/09/01/JVM/image-20220824141742761.png" alt="image-20220824141742761" style="zoom: 67%;"><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="如何判断哪些对象可以回收"><a href="#如何判断哪些对象可以回收" class="headerlink" title="如何判断哪些对象可以回收"></a>如何判断哪些对象可以回收</h3><p>1.引用计数法:有引用，计数+1，计数为0，则可以回收 </p><p>缺点：相互引用<img src="/2022/09/01/JVM/image-20220824142645248.png" alt="image-20220824142645248" style="zoom:33%;"></p><p>2.可达性分析：扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，找不到则可以回收</p><h4 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h4><p>1.强引用： 当所有的GC Root对象都不通过【强引用】引用该对象，该对象能被垃圾回收</p><p>2.软引用：仅有【软引用】引用该对象时，在垃圾回收后，内存仍不足，会再次发出垃圾回收，回收软引用对象；可配合软引用队列释放软引用自身</p><p>3.弱引用：仅有【弱引用】引用该对象时，在垃圾回收时，无论内存是否足够，都会回收弱引用对象；可以配合弱引用队列回收弱引用自身</p><p>4.虚引用：必须配合虚引用队列使用，主要配合ByteBuffer使用，引用直接内存地址，引用对象被回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放内存</p><h3 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h3><p>1.标记清除：会有内存碎片，速度较快</p><img src="/2022/09/01/JVM/image-20220824144624458.png" alt="image-20220824144624458" style="zoom: 50%;"><p>2.标记整理：没有内存碎片，但速度较慢</p><img src="/2022/09/01/JVM/image-20220824144648093.png" alt="image-20220824144648093" style="zoom: 50%;"><p>3.复制：不会有内存碎片，但需要双倍空间</p><img src="/2022/09/01/JVM/image-20220824144709382.png" alt="image-20220824144709382" style="zoom: 50%;"><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>(分代回收)</p><p>新生代（伊甸园&#x2F;幸存区form&#x2F;幸存区to）&#x2F;老年代</p><p>对象分配规则：</p><p>新生代复制算法  老年代标记清除</p><p>对象会先被分配在伊甸园，如果伊甸园没有足够的空间，则会进行一次Minor GC，伊甸园和幸存区from存活的对象会复制到幸存区to中</p><p>并且年龄+1，会发生stw，暂停其他线程，等垃圾回收结束，用户线程才会恢复，当对象年龄超过一定阈值（15），则会晋升老年代；当老年代空间不足时，会先进行Minor GC，，如果空间仍不足，则会进行Full GC，stw时间更长；</p><p><img src="/typora-user-images%5Cimage-20220824150357346.png" alt="image-20220824150357346"></p><p>1.串行</p><p><img src="/typora-user-images%5Cimage-20220824150444562.png" alt="image-20220824150444562"></p><p>2.并行</p><p><img src="/typora-user-images%5Cimage-20220824150454594.png" alt="image-20220824150454594"></p><p>3.CMS</p><p><img src="/typora-user-images%5Cimage-20220824150517061.png" alt="image-20220824150517061"></p><p>（分区回收）</p><p>4.G1（物理分区逻辑分代）：同时注重吞吐量和低延迟，默认暂停目标200ms</p><p>超大堆内存，将堆划分为许多大小相等的区</p><p>整体标记整理，两个区域间复制</p><p>三个阶段 <img src="/2022/09/01/JVM/image-20220824150959610.png" alt="image-20220824150959610" style="zoom:33%;">  </p><p>1.新生代回收（会stw）：新创建的对象在伊甸园区域，<img src="/2022/09/01/JVM/image-20220824151654728.png" alt="image-20220824151654728" style="zoom: 33%;"></p><p>新生代回收会把伊甸园幸存的对象复制到幸存区，<img src="/2022/09/01/JVM/image-20220824151723329.png" alt="image-20220824151723329" style="zoom:33%;"></p><p>当幸存区的年龄足够后，会复制到老年代，年龄不够幸存的对象复制到新的幸存区<img src="/2022/09/01/JVM/image-20220824152159103.png" alt="image-20220824152159103" style="zoom:33%;"></p><p>2.新生代回收+并发标记 ：young GC时会进行GC Root初始标记，老年代占用堆空间比例达到阈值时，进行并发标记（不会 STW）</p><p>3.混合回收：会对 E、S、O 进行全面垃圾回收</p><p>最终标记（Remark）会 STW</p><p>拷贝存活（Evacuation）会 STW</p><p>会优先对可回收空间大的区域进行回收</p><img src="/2022/09/01/JVM/image-20220824153902244.png" alt="image-20220824153902244" style="zoom:67%;"><p>5.ZGC （没有stw）（64位） （分区）42-44位 指针地址 4位标识状态</p><p>最开时都是Remapped状态，垃圾回收器开始工作后凡是从GC Root上找的，能找到的都标注为M0状态，此时有别的创建新的对象也依然标记为M0状态（不会漏标） ，之后把整体不是M0的区域快清除掉，下次标注用M1，依次循环</p><img src="/2022/09/01/JVM/image-20220824160024636.png" alt="image-20220824160024636" style="zoom:50%;"><img src="/2022/09/01/JVM/image-20220824160252736.png" alt="image-20220824160252736" style="zoom:50%;"><p>(四种状态)</p><p>Finalizable：重写了finaliz方法，此方法等待被调用（很少用到)</p><p>Remapped</p><p>Marked0</p><p>Marked1</p><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>1.加载：将类的字节码载入方法区</p><p>2.验证：确保class文件符合jvm虚拟机规范</p><p>3.准备：进行内存分配，为static修饰的变量分配内存，并设置初始值</p><p>4.解析：将常量池中的符号引用替换为直接引用</p><p>（234）合称连接</p><p>5.初始化：初始化即调用 <cinit>()V ，虚拟机会保证这个类的『构造方法』的线程安全</cinit></p><img src="/2022/09/01/JVM/image-20220824162316164.png" alt="image-20220824162316164" style="zoom: 80%;"><p>6.卸载：执行垃圾回收</p><p>双亲委派:是指调用类加载器loadclass方法时，查找类的规则</p><p>先检查该类是否加载，如果没有，则委派上级loadclass，如果没有上级，则委派BootstrapClassLoader，找不到则调用findclass方法（每个类加载器自己扩展）</p><img src="/2022/09/01/JVM/image-20220824163528463.png" alt="image-20220824163528463" style="zoom:80%;"><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>1.启动类加载器</p><p>2.扩展类加载器</p><p>3.应用程序类加载器</p><p>4.自定义类加载器</p><p><img src="/typora-user-images%5Cimage-20220824163612255.png" alt="image-20220824163612255"></p><p><img src="/typora-user-images%5Cimage-20220824163657962.png" alt="image-20220824163657962"></p><p><img src="/typora-user-images%5Cimage-20220824164135399.png" alt="image-20220824164135399"></p><p><img src="/typora-user-images%5Cimage-20220824164233951.png" alt="image-20220824164233951"></p><h3 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h3><p>1.逃逸分析</p><p><img src="/typora-user-images%5Cimage-20220824170038248.png" alt="image-20220824170038248"></p><p><img src="/typora-user-images%5Cimage-20220824165934640.png" alt="image-20220824165934640"></p><p>2.方法内联</p><p><img src="/typora-user-images%5Cimage-20220824170209312.png" alt="image-20220824170209312"></p><p>3.字段优化</p><p>4反射优化</p>]]></content:encoded>
      
      
      <category domain="https://HoldusTogether.github.io/categories/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/categories/Java/JVM/">JVM</category>
      
      
      <category domain="https://HoldusTogether.github.io/tags/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/tags/Jvm/">Jvm</category>
      
      
      <comments>https://holdustogether.github.io/2022/09/01/JVM/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySql篇</title>
      <link>https://holdustogether.github.io/2022/09/01/MYSQL%E7%AF%87/</link>
      <guid>https://holdustogether.github.io/2022/09/01/MYSQL%E7%AF%87/</guid>
      <pubDate>Thu, 01 Sep 2022 04:43:50 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;MYSQL篇&quot;&gt;&lt;a href=&quot;#MYSQL篇&quot; class=&quot;headerlink&quot; title=&quot;MYSQL篇&quot;&gt;&lt;/a&gt;MYSQL篇&lt;/h1&gt;&lt;h2 id=&quot;基础篇&quot;&gt;&lt;a href=&quot;#基础篇&quot; clas</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h1 id="MYSQL篇"><a href="#MYSQL篇" class="headerlink" title="MYSQL篇"></a>MYSQL篇</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><p><img src="/typora-user-images%5Cimage-20220831121118541.png" alt="image-20220831121118541"></p><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="MYSQL-体系结构"><a href="#MYSQL-体系结构" class="headerlink" title="MYSQL 体系结构"></a>MYSQL 体系结构</h4><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831103354276.png" alt="image-20220831103354276" style="zoom:80%;"><p>1). 连接层 </p><p>最上层是一些客户端和链接服务。主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 </p><p>2). 服务层 </p><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部 分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。</p><p> 3). 引擎层 </p><p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通 信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</p><p> 4). 存储层 </p><p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</p><h4 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h4><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式 。存储引擎是基于表的，而不是 基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果 没有指定将自动选择默认的存储引擎。</p><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831103614022.png" alt="image-20220831103614022" style="zoom:80%;"><p>1.InnoDB</p><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。</p><p>. 特点 </p><ul><li><p>DML操作遵循ACID模型，支持事务；</p></li><li><p>行级锁，提高并发访问性能； </p></li><li><p>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</p></li></ul><p>逻辑存储结构</p><p><img src="/typora-user-images%5Cimage-20220831103804768.png" alt="image-20220831103804768"></p><ul><li><p>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以 包含多个Segment段。</p></li><li><p>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管 理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 </p></li><li><p>区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。</p></li><li><p>页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默 认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。 </p></li><li><p>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时 所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。</p></li></ul><p>2.MyISAM</p><p>MyISAM是MySQL早期的默认存储引擎。</p><p>特点</p><ul><li><p>不支持事务，不支持外键 </p></li><li><p>支持表锁，不支持行锁 </p></li><li><p>访问速度快</p></li></ul><p>3.Memory</p><p>Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为 临时表或缓存使用。</p><p>特点 </p><ul><li><p>内存存放 </p></li><li><p>hash索引（默认）</p></li></ul><p>(<strong>面试题</strong>)InnoDB引擎与MyISAM引擎的区别 ? </p><p>①. InnoDB引擎, 支持事务, 而MyISAM不支持。 </p><p>②. InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。 </p><p>③. InnoDB引擎, 支持外键, 而MyISAM是不支持的。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h4><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足 特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。</p><p>特点</p><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831104203451.png" alt="image-20220831104203451" style="zoom:80%;"><h4 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h4><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831104238316.png" alt="image-20220831104238316" style="zoom:80%;"><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831104301126.png" alt="image-20220831104301126" style="zoom:80%;"><p>B-tree</p><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831104348316.png" alt="image-20220831104348316" style="zoom:80%;"><p>B+tree</p><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831104414563.png" alt="image-20220831104414563" style="zoom:80%;"><p>最终我们看到，B+Tree 与 B-Tree相比，主要有以下三点区别： </p><ul><li><p>所有的数据都会出现在叶子节点。 </p></li><li><p>叶子节点形成一个单向链表。 </p></li><li><p>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</p></li></ul><p>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831104523541.png" alt="image-20220831104523541" style="zoom:80%;"><p>hash索引</p><p>MySQL中除了支持B+Tree索引，还支持一种索引类型—Hash索引。</p><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash表中。</p><p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可 以通过链表来解决。</p><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831104712186.png" alt="image-20220831104712186" style="zoom:80%;"><p>. 特点</p><p>A. Hash索引只能用于对等比较(&#x3D;，in)，不支持范围查询（between，&gt;，&lt; ，…）</p><p> B. 无法利用索引完成排序操作 </p><p>C. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</p><p> （<strong>面试题</strong>）为什么InnoDB存储引擎选择使用B+tree索引结构?</p><p>A. 相对于二叉树，层级更少，搜索效率高； </p><p>B. 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储 的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</p><p> C. 相对Hash索引，B+tree支持范围匹配及排序操作；</p><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831104853542.png" alt="image-20220831104853542" style="zoom:80%;"><p>而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831104922516.png" alt="image-20220831104922516" style="zoom:80%;"><p>聚集索引选取规则: </p><ul><li><p>如果存在主键，主键索引就是聚集索引。</p></li><li><p>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p></li><li><p>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p></li></ul><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831105010632.png" alt="image-20220831105010632" style="zoom:80%;"><p>聚集索引的叶子节点下挂的是这一行的数据 。 </p><p>二级索引的叶子节点下挂的是该字段值对应的主键值。</p><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831105103938.png" alt="image-20220831105103938" style="zoom:80%;"><p>回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取 数据的方式，就称之为回表查询。</p><h4 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h4><p> 创建索引</p><p>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name ( index_col_name,… ) ;</p><p>查看索引</p><p>SHOW INDEX FROM table_name ;</p><p> 删除索引</p><p>DROP INDEX index_name ON table_name ;</p><p>案例</p><p>A. name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。</p><p>CREATE INDEX idx_user_name ON tb_user(name);</p><p>B.phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引。</p><p>CREATE UNIQUE INDEX idx_user_phone ON tb_user(phone);</p><p>C. 为profession、age、status创建联合索引。</p><p>CREATE INDEX idx_user_pro_age_sta ON tb_user(profession,age,status);</p><p>D. 为email建立合适的索引来提升查询效率。</p><p>CREATE INDEX idx_email ON tb_user(email)</p><p>再查看tb_user表的所有的索引数据</p><p>show index from tb_user;</p><h4 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h4><p>1.SQL执行频率</p><p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信 息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：</p><p>SHOW GLOBAL STATUS LIKE ‘Com_______’;</p><p>Com_delete: 删除次数</p><p>Com_insert: 插入次数 </p><p>Com_select: 查询次数 </p><p>Com_update: 更新次数 </p><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831105636649.png" alt="image-20220831105636649" style="zoom:80%;"><p>2.慢查询日志</p><p>开启MySQL慢日志查询开关 </p><p>slow_query_log&#x3D;1 </p><p>设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 </p><p>long_query_time&#x3D;2</p><p>3.profile详情</p><p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p><p>当前MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在 session&#x2F;global级别开启profiling：</p><p>SET profiling &#x3D; 1;</p><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831110034498.png" alt="image-20220831110034498" style="zoom:80%;"><p>– 查看每一条SQL的耗时基本情况</p><p> show profiles;</p><p> – 查看指定query_id的SQL语句各个阶段的耗时情况 </p><p>show profile for query query_id;</p><p> – 查看指定query_id的SQL语句CPU的使用情况 </p><p>show profile cpu for query query_id;</p><p>4.explain</p><p>– 直接在select语句之前加上关键字 explain &#x2F; desc EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;</p><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831110200450.png" alt="image-20220831110200450" style="zoom:80%;"><h4 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h4><p>1.最左前缀法则</p><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。</p><p>2.范围查询</p><p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效。</p><p>所以，在业务允许的情况下，尽可能的使用类似于 &gt;&#x3D; 或 &lt;&#x3D; 这类的范围查询，而避免使用 &gt; 或 &lt;</p><p>3.索引失效情况</p><p> 索引列运算</p><p>不要在索引列上进行运算操作， 索引将失效。（例如一些函数运算）</p><p>explain select * from tb_user where <strong>substring</strong>(phone,10,2) &#x3D; ‘15’;</p><p>字符串不加引号</p><p>字符串类型字段使用时，不加引号，索引将失效。</p><p>加引号     explain select * from tb_user where profession &#x3D; ‘软件工程’ and age &#x3D; 31 and status &#x3D; **’0’**；</p><p>不加引号 explain select * from tb_user where profession &#x3D; ‘软件工程’ and age &#x3D; 31 and status &#x3D; <strong>0</strong>;</p><p>模糊查询</p><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><p>不失效 explain select * from tb_user where profession like <strong>‘软件%’;</strong> </p><p>失效     explain select * from tb_user where profession like <strong>‘%工程’;</strong> </p><p>失效     explain select * from tb_user where profession like <strong>‘%工%’;</strong></p><p>or连接条件</p><p>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会 被用到。</p><p>explain select * from tb_user where id &#x3D; 10 or age &#x3D; 23;</p><p>id有索引 age没索引，最后没用索引</p><p>当or连接的条件，左右两侧字段都有索引时，索引才会生效。</p><p>数据分布影响</p><p>如果MySQL评估使用索引比全表更慢，则不使用索引。</p><p>MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃 索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不 如走全表扫描来的快，此时索引就会失效。</p><p>SQL提示</p><p>1). use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估）。</p><p>explain select * from tb_user <strong>use index(idx_user_pro</strong>) where profession &#x3D; ‘软件工 程’;</p><p>2). ignore index ： 忽略指定的索引。</p><p>explain select * from tb_user <strong>ignore index(idx_user_pro)</strong> where profession &#x3D; ‘软件工 程’;</p><p>3). force index ： 强制使用索引。</p><p>explain select * from tb_user <strong>force index(idx_user_pro)</strong> where profession &#x3D; ‘软件工 程’;</p><p>覆盖索引</p><p>尽量使用覆盖索引，减少select *。</p><p><img src="/typora-user-images%5Cimage-20220831111430617.png" alt="image-20220831111430617"></p><p>虽然是根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索 引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。</p><p><img src="/typora-user-images%5Cimage-20220831111445541.png" alt="image-20220831111445541"></p><p>由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相 对较差一点。</p><p>而select* 就会回表查询性能较差</p><p>前缀索引</p><p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让 索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建 立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法</p><p>create index idx_xxxx on table_name(column(n)) ;</p><p>前缀长度</p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><p>select count(distinct email) &#x2F; count(*) from tb_user ; </p><p>select count(distinct substring(email,1,5)) &#x2F; count(*) from tb_user ;</p><img src="/2022/09/01/MYSQL%E7%AF%87/image-20220831111846613.png" alt="image-20220831111846613" style="zoom:80%;"><p>单列索引与联合索引</p><p>单列索引：即一个索引只包含单个列。</p><p>联合索引：即一个索引包含了多个列。</p><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。</p><p>索引设计原则</p><p>1). 针对于数据量较大，且查询比较频繁的表建立索引。 </p><p>2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索 引。</p><p>3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。 </p><p>4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p><p>5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。 </p><p>6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增 删改的效率。</p><p>7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p><h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><h4 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h4><h4 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h4><h4 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h4><h4 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h4><h4 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h4><h4 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h4><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><h3 id="InnoDB核心"><a href="#InnoDB核心" class="headerlink" title="InnoDB核心"></a>InnoDB核心</h3><h4 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h4><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><h4 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h4><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><h2 id="运维篇"><a href="#运维篇" class="headerlink" title="运维篇"></a>运维篇</h2><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h3 id="主-从复制"><a href="#主-从复制" class="headerlink" title="主 从复制"></a>主 从复制</h3><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3>]]></content:encoded>
      
      
      <category domain="https://HoldusTogether.github.io/categories/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/categories/Java/MySql/">MySql</category>
      
      
      <category domain="https://HoldusTogether.github.io/tags/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/tags/MySql/">MySql</category>
      
      <category domain="https://HoldusTogether.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      
      <comments>https://holdustogether.github.io/2022/09/01/MYSQL%E7%AF%87/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring Boot</title>
      <link>https://holdustogether.github.io/2022/09/01/spring%20boot%E7%AF%87/</link>
      <guid>https://holdustogether.github.io/2022/09/01/spring%20boot%E7%AF%87/</guid>
      <pubDate>Thu, 01 Sep 2022 04:43:46 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;Spring-Boot篇&quot;&gt;&lt;a href=&quot;#Spring-Boot篇&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot篇&quot;&gt;&lt;/a&gt;Spring Boot篇&lt;/h1&gt;&lt;h2 id=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h1 id="Spring-Boot篇"><a href="#Spring-Boot篇" class="headerlink" title="Spring Boot篇"></a>Spring Boot篇</h1><h2 id="为什么要用Spring-Boot"><a href="#为什么要用Spring-Boot" class="headerlink" title="为什么要用Spring Boot"></a>为什么要用Spring Boot</h2><p>①独立运行<br>SpringBoot内嵌servlet容器，Tomcat、Jetty等，现在不再需要打成war包部署到容器中，SpringBoot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内。</p><p>②简化配置<br>spring-boot-starter-web启动器自动依赖其他组件，简少了maven的配置。</p><p>③自动配置<br>SpringBoot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他配置。</p><p>④无代码生成和XML配置<br>SpringBoot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是Spring4.x的核心功能之一。</p><p>⑤应用监控<br>SpringBoot提供一系列端点可以监控服务及应用，做健康检测。</p><p>缺点：<br>SpringBoot虽然很容易上手，但如果不了解其核心技术及流程，一遇到问题就很棘手，而且现在的解决方案也不多，需要一个完善的过程。</p><h2 id="创建SpringBoot项目的方式"><a href="#创建SpringBoot项目的方式" class="headerlink" title="创建SpringBoot项目的方式"></a>创建SpringBoot项目的方式</h2><p>1.通过web方式在官网在线构建SpringBoot项目</p><p>2.使用idea等开发工具进行创建</p><p>3.基于Maven构建SpringBoot项目</p><h2 id="运行SpringBoot的方式"><a href="#运行SpringBoot的方式" class="headerlink" title="运行SpringBoot的方式"></a>运行SpringBoot的方式</h2><img src="/2022/09/01/spring%20boot%E7%AF%87/image-20220831210440346.png" alt="image-20220831210440346" style="zoom:67%;"><h2 id="SpringBoot的核心注解"><a href="#SpringBoot的核心注解" class="headerlink" title="SpringBoot的核心注解"></a>SpringBoot的核心注解</h2><p>@SpringBootApplication</p><p>包含3个注解</p><p>@SpringBootConfiguration ：组合了@Congifuration注解，实现配置文件的功能</p><p>@EnableAutoConfiguration：打开自动配置功能</p><p>@ComponentScan：Spring组件扫描</p><h2 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h2><p>使用parent可以帮助开发者进行版本的统一管理。</p><h2 id="starter"><a href="#starter" class="headerlink" title="starter"></a>starter</h2><p>starter定义了使用某种技术时对于依赖的固定搭配格式（在某些场景下包含的一系列依赖），也是一种最佳解决方案，使用starter可以帮助开发者减少依赖配置</p><p><strong>starter与parent的区别</strong></p><p>​<font color="#ff0000"><b>starter</b></font>是一个坐标中定了若干个坐标，以前写多个的，现在写一个，<font color="#ff0000"><b>是用来减少依赖配置的书写量的</b></font>。</p><p>​<font color="#ff0000"><b>parent</b></font>是定义了几百个依赖版本号，以前写依赖需要自己手工控制版本，现在由SpringBoot统一管理，这样就不存在版本冲突了，<font color="#ff0000"><b>是用来减少依赖冲突的</b></font>。</p><h2 id="引导类"><a href="#引导类" class="headerlink" title="引导类"></a>引导类</h2><p>SpringBoot程序启动还是创建了一个Spring容器对象。当前运行的这个类在SpringBoot程序中是所有功能的入口，称为<font color="#ff0000"><b>引导类</b></font>。</p><p>作为一个引导类最典型的特征就是当前类上方声明了一个注解<font color="#ff0000"><b>@SpringBootApplication</b></font>。</p><ol><li>SpringBoot工程提供引导类用来启动程序</li><li>SpringBoot工程启动后创建并初始化Spring容器</li></ol><h2 id="内嵌tomcat"><a href="#内嵌tomcat" class="headerlink" title="内嵌tomcat"></a>内嵌tomcat</h2><ol><li>内嵌Tomcat服务器是SpringBoot辅助功能之一</li><li>内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理</li><li>变更内嵌服务器思想是去除现有服务器，添加全新的服务器</li></ol><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>SpringBoot默认配置文件是application.properties</p><ol><li><p>SpringBoot程序可以在application.properties文件中进行属性配置</p></li><li><p>application.properties文件中只要输入要配置的属性关键字就可以根据提示进行设置</p></li><li><p>SpringBoot将配置信息集中在一个文件中写，不管你是服务器的配置，还是数据库的配置，总之都写在一起，逃离一个项目十几种配置文件格式的尴尬局面</p></li></ol><p>SpringBoot除了支持properties格式的配置文件，还支持另外两种格式的配置文件。三种配置文件格式分别如下:</p><ul><li>properties格式</li><li>yml格式</li><li>yaml格式</li></ul><ol><li>配置文件间的加载优先级properties（最高）&gt;  yml  &gt;  yaml（最低）</li><li>不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留</li></ol><p>yaml书写格式</p><ol><li>大小写敏感</li><li>属性层级关系使用多行描述，<strong>每行结尾使用冒号结束</strong></li><li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</li><li>属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）</li><li>#号 表示注释</li></ol><img src="/2022/09/01/spring%20boot%E7%AF%87/image-20220831205215169.png" alt="image-20220831205215169" style="zoom: 67%;"><p>字面值、对象数据格式、数组数据格式</p><img src="/2022/09/01/spring%20boot%E7%AF%87/image-20220831205327006.png" alt="image-20220831205327006" style="zoom:67%;"><p>yaml数据读取</p><p>yaml中保存的单个数据，可以使用Spring中的注解@Value读取单个数据，属性名引用方式：<font color="#ff0000"><b>${一级属性名.二级属性名……}</b></font></p><img src="/2022/09/01/spring%20boot%E7%AF%87/image-20220831205450903.png" alt="image-20220831205450903" style="zoom:67%;"><p>读取全部数据</p><ol><li>使用Environment对象封装全部配置信息</li><li>使用@Autowired自动装配数据到Environment对象中</li></ol><img src="/2022/09/01/spring%20boot%E7%AF%87/image-20220831205601000.png" alt="image-20220831205601000" style="zoom:67%;"><p>读取对象数据</p><p>首先定义一个对象，并将该对象纳入Spring管控的范围，也就是定义成一个bean，然后使用注解@ConfigurationProperties指定该对象加载哪一组yaml中配置的信息。</p><img src="/2022/09/01/spring%20boot%E7%AF%87/image-20220831205728840.png" alt="image-20220831205728840" style="zoom:67%;"><ol><li>使用@ConfigurationProperties注解绑定配置信息到封装类中</li><li>封装类需要定义为Spring管理的bean，否则无法进行属性注入</li></ol><p>数据引用</p><ol><li>在配置文件中可以使用${属性名}方式引用属性值</li><li>如果属性中出现特殊字符，可以使用双引号包裹起来作为字符解析</li></ol><img src="/2022/09/01/spring%20boot%E7%AF%87/image-20220831205842391.png" alt="image-20220831205842391" style="zoom:67%;"><p>在书写字符串时，如果需要使用转义字符，需要将数据字符串使用双引号包裹起来</p><img src="/2022/09/01/spring%20boot%E7%AF%87/image-20220831205901099.png" alt="image-20220831205901099" style="zoom:67%;"><p>配置文件分类</p><p>SpringBoot提供的4个级别的配置文件：</p><ul><li><p>类路径下配置文件（一直使用的是这个，也就是resources目录中的application.yml文件）</p></li><li><p>类路径下config目录下配置文件</p></li><li><p>程序包所在目录中配置文件</p></li><li><p>程序包所在目录中config目录下配置文件</p><p>上面4个文件的加载优先顺序为</p><ol><li>file ：config&#x2F;application.yml <strong>【最高】</strong></li><li>file ：application.yml</li><li>classpath：config&#x2F;application.yml</li><li>classpath：application.yml  <strong>【最低】</strong></li></ol></li></ul><p>自定义配置文件</p><ol><li>配置文件可以修改名称，通过启动参数设定</li><li>配置文件可以修改路径，通过启动参数设定</li><li>微服务开发中配置文件通过配置中心进行设置</li></ol><p>多环境开发（yaml单一文件版）</p><ol><li><p>多环境开发需要设置若干种常用环境，例如开发、生产、测试环境</p></li><li><p>yaml格式中设置多环境使用—区分环境设置边界</p></li><li><p>每种环境的区别在于加载的配置属性不同</p></li><li><p>启用某种环境时需要指定启动时使用该环境</p><img src="/2022/09/01/spring%20boot%E7%AF%87/image-20220831211924641.png" alt="image-20220831211924641" style="zoom:67%;"></li></ol><p>多环境开发（yaml多文件版）</p><p>环境配置文件因为每一个都是配置自己的项，所以连名字都不用写里面了，使用文件名区分。</p><p>文件的命名规则为：application-环境名.yml。</p><ul><li>主配置文件中设置公共配置（全局）</li><li>环境分类配置文件中常用于设置冲突属性（局部）</li></ul><ol><li><p>可以使用独立配置文件定义环境属性</p></li><li><p>独立配置文件便于线上系统维护更新并保障系统安全性</p></li></ol><h2 id="SpringBoot中加载配置的几种方式"><a href="#SpringBoot中加载配置的几种方式" class="headerlink" title="SpringBoot中加载配置的几种方式"></a>SpringBoot中加载配置的几种方式</h2><p>1、properties文件；</p><p>2、YAML文件；</p><p>3、系统环境变量；</p><p>4、命令行参数；</p><h2 id="如何使用-Spring-Boot-实现异常处理？"><a href="#如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="如何使用 Spring Boot 实现异常处理？"></a>如何使用 Spring Boot 实现异常处理？</h2><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p><h2 id="SpringBoot程序的打包与运行"><a href="#SpringBoot程序的打包与运行" class="headerlink" title="SpringBoot程序的打包与运行"></a>SpringBoot程序的打包与运行</h2><ol><li>SpringBoot工程可以基于java环境下独立运行jar文件启动服务</li><li>SpringBoot工程执行mvn命令package进行打包</li><li>执行jar命令：java –jar 工程名.jar</li></ol><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>日志其实就是记录程序日常运行的信息，主要作用如下：</p><ul><li>编程期调试代码</li><li>运营期记录信息</li><li>记录日常运营重要信息（峰值流量、平均响应时长……）</li><li>记录应用报错信息（错误堆栈）</li><li>记录运维过程数据（扩容、宕机、报警……）</li></ul><p>日志的级别分为6种，分别是：</p><ul><li>TRACE：运行堆栈信息，使用率低</li><li>DEBUG：程序员调试代码使用</li><li>INFO：记录运维过程数据</li><li>WARN：记录运维过程报警数据</li><li>ERROR：记录错误堆栈信息</li><li>FATAL：灾难信息，合并计入ERROR</li></ul><p>一般情况下，开发时候使用DEBUG，上线后使用INFO，运维信息记录使用WARN即可。</p><p>基于lombok提供的@Slf4j注解为类快速添加日志对象</p><h2 id="实现热部署"><a href="#实现热部署" class="headerlink" title="实现热部署"></a>实现热部署</h2><img src="/2022/09/01/spring%20boot%E7%AF%87/image-20220831202106134.png" alt="image-20220831202106134" style="zoom:80%;"><h2 id="Spring-Boot-中的监视器是什么？"><a href="#Spring-Boot-中的监视器是什么？" class="headerlink" title="Spring Boot 中的监视器是什么？"></a>Spring Boot 中的监视器是什么？</h2><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访 问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和 监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器 模块公开了一组可直接作为 HTTP URL 访问的 REST 端点来检查状态。</p>]]></content:encoded>
      
      
      <category domain="https://HoldusTogether.github.io/categories/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/categories/Java/Spring-Boot/">Spring Boot</category>
      
      
      <category domain="https://HoldusTogether.github.io/tags/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/tags/Spring-Boot/">Spring Boot</category>
      
      
      <comments>https://holdustogether.github.io/2022/09/01/spring%20boot%E7%AF%87/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SSM框架篇</title>
      <link>https://holdustogether.github.io/2022/09/01/SSM%E6%A1%86%E6%9E%B6%E7%AF%87/</link>
      <guid>https://holdustogether.github.io/2022/09/01/SSM%E6%A1%86%E6%9E%B6%E7%AF%87/</guid>
      <pubDate>Thu, 01 Sep 2022 04:43:32 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;SSM框架篇&quot;&gt;&lt;a href=&quot;#SSM框架篇&quot; class=&quot;headerlink&quot; title=&quot;SSM框架篇&quot;&gt;&lt;/a&gt;SSM框架篇&lt;/h1&gt;&lt;h2 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h1 id="SSM框架篇"><a href="#SSM框架篇" class="headerlink" title="SSM框架篇"></a>SSM框架篇</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="spring概述"><a href="#spring概述" class="headerlink" title="spring概述"></a>spring概述</h3><p>Spring 是最受欢迎的企业级 Java 应用程序开发框架，Spring 框架的核心特性是可以用于开发任何 Java 应用程序，但是在 Java EE 平台上构建 web 应 用程序是需要扩展的。Spring 框架的目标是使 J2EE 开发变得更容易使用，通过启用基于 POJO 编程模型来促进良好的编程习惯。</p><h3 id="spring-优点"><a href="#spring-优点" class="headerlink" title="spring 优点"></a>spring 优点</h3><ul><li>轻量级</li><li>控制反转</li><li>面向切面（AOP）</li><li>容器：Spring包含并管理应用中对象的生命周期和配置</li><li>MVC框架</li><li>事务管理</li><li>异常处理</li></ul><h3 id="spring的七大模块"><a href="#spring的七大模块" class="headerlink" title="spring的七大模块"></a>spring的七大模块</h3><p>Spring Core:核心库类，提供IOC服务</p><p>Spring Context：提供框架式的Bean访问方式</p><p>Spring AOP：AOP服务</p><p>Spring Dao：对JDBC的抽象</p><p>Spring ORM：对ORM框架的支持</p><p>Spring Web：提供了面向Web的综合特性</p><p>Spring MVC：提供面向Web应用的MVC框架</p><h3 id="IOC思想：控制反转"><a href="#IOC思想：控制反转" class="headerlink" title="IOC思想：控制反转"></a>IOC思想：控制反转</h3><p>①获取资源的传统方式</p><p>传统的方式是组件主动的从容器中获取所需要的资源</p><p>②控制反转方式获取资源</p><p>改由容器主动的将资源推送给需要的组件</p><p>③DI：依赖注入</p><p>DI 是 IOC 的另一种表述方式：即组件以一些预先定义好的方式（例如：setter 方法）接受来自于容器 的资源注入</p><p>IOC 就是一种控制反转的思想， 而 DI 是对 IOC 的一种具体实现。</p><h3 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h3><ul><li>构造器注入：通过构造函数的参数注入给依赖对象</li><li>setter注入：通过调用setter函数注入给依赖对象</li><li>接口注入：通过实现指定接口中的一个函数，函数用于依赖注入</li></ul><h3 id="Bean的配置"><a href="#Bean的配置" class="headerlink" title="Bean的配置"></a>Bean的配置</h3><p>id：唯一标识</p><p>class：全限定名称</p><p>scope：对象的作用范围 singleton（默认单例）prototype（多例）</p><p><img src="/2022/09/01/SSM%E6%A1%86%E6%9E%B6%E7%AF%87/image-20220831150753631.png" alt="image-20220831150753631" style="zoom:50%;"><img src="/2022/09/01/SSM%E6%A1%86%E6%9E%B6%E7%AF%87/image-20220831150823831.png" alt="image-20220831150823831" style="zoom: 50%;"></p><img src="/2022/09/01/SSM%E6%A1%86%E6%9E%B6%E7%AF%87/image-20220831161207904.png" alt="image-20220831161207904" style="zoom:80%;"><p>init-method（初始化方法名称）</p><p>destroy-method（销毁的方法名称）</p><p>Bean实例化的三种方式</p><ul><li><p>无参构造方法  </p></li><li><p>工厂静态方法</p></li><li><p>工厂实例方法</p></li></ul><p>Bean的依赖注入的数据类型</p><ul><li>普通数据类型</li><li>引用数据类型</li><li>集合数据类型</li></ul><img src="/2022/09/01/SSM%E6%A1%86%E6%9E%B6%E7%AF%87/image-20220831151911569.png" alt="image-20220831151911569" style="zoom:80%;"><p>基于注解管理Bean</p><p>@Component：将类标识为普通组件 </p><p>@Controller：将类标识为控制层组件 </p><p>@Service：将类标 识为业务层组件 </p><p>@Repository：将类标识为持久层组件</p><p>@Autowired注解 在成员变量上直接标记@Autowired注解即可完成自动装配</p><p>Autowired注解和Resource注解的区别</p><p>相同：两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><p>不同：</p><p>1.@Autowired为Spring提供的注解，@Resource注解由J2EE提供</p><p>2.@Autowired采取的策略为按照类型注入。@Resource默认按照ByName自动注入。同时支持byType。</p><p>@Resource装配顺序</p><p>①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</p><p>②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</p><p>③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</p><p>④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</p><h3 id="Bean的生命周期（面试）"><a href="#Bean的生命周期（面试）" class="headerlink" title="Bean的生命周期（面试）"></a>Bean的生命周期（面试）</h3><p>创建Bean</p><p>1.实例化Bean</p><p>2.设置对象属性（依赖注入）</p><p>3.初始化</p><p>检测对象是否实现了Aware相关接口，并将相关的Aware实例注入给Bean</p><ul><li><p>当Bean本身实现了BeanNameAware接口，这个时候会根据接口方法，来设置Bean的name。</p></li><li><p>当Bean本身实现了BeanFactoryAware接口，这个时候会根据接口方法，将BeanFactory设置给Bean。</p></li><li><p>当Bean本身实现了ApplicationContextAware接口，这个时候Spring会将当前Bean引入到应用上下文中，也就是说可以通过ApplicationContext获取到当前Bean。</p></li></ul><p>BeanPostProcessor中的前置处理方法。</p><p>是否实现了InitializingBean接口，执行afterPropertiesSet方法，进行配置的一个加载。</p><p>是否配置自定义的init-method，执行自身的init方法。</p><p>BeanPostProcessor中的后置处理方法。</p><p>使用Bean</p><p>4.销毁Bean</p><p>是否实现DisposableBean接口的destroy方法。</p><p>是否配置自定义的destroy-method执行自身的destroy方法。</p><p>Spring中BeanFactory和ApplicationContext的区别</p><h3 id="AOP面向切面"><a href="#AOP面向切面" class="headerlink" title="AOP面向切面"></a>AOP面向切面</h3><p>AOP能够将那些与业务无关的，却被业务模块所共同调用的逻辑封装起来，，让被抽取的方法更专注于自己的核心功能，减少重复代码，降低耦合度，有利于未来的可扩展性和可维护性。</p><p>Spring AOP是基于动态代理的，JDK原生的实现方式，需要被代理的目标类必须实现接口，对于没有实现接口的对象，转而使用cglib的方式生成一个被代理对象的子类来作为代理。</p><p>前置通知：使用@Before注解标识，在被代理的目标方法前执行 </p><p>返回通知：使用@AfterReturning注解标识，在被代理的目标方法成功结束后执行（寿终正寝） </p><p>异常通知：使用@AfterThrowing注解标识，在被代理的目标方法异常结束后执行（死于非命）</p><p>后置通知：使用@After注解标识，在被代理的目标方法最终结束后执行（盖棺定论） </p><p>环绕通知：使用@Around注解标识，使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</p><img src="/2022/09/01/SSM%E6%A1%86%E6%9E%B6%E7%AF%87/image-20220831160446237.png" alt="image-20220831160446237" style="zoom:80%;"><h3 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h3><p>编程式事务控制：自己写代码实现功能 </p><p>声明式事务控制：通过配置让框架实现功能</p><p>事务四大特性</p><p>1.原子性</p><p>2.一致性</p><p>3.隔离性</p><p>4.持久性</p><p>事务隔离级别</p><p>1.未提交读</p><p>2.提交读</p><p>3.可重复读</p><p>4.串行化</p><p>并发事务问题</p><p>1.脏读：一个事务读到另外一个事务还没有提交的数据。</p><p>2.不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读</p><p>3.幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 “幻影”。</p><p>基于注解的声明式事务</p><p>@Transactional注解标识的位置 </p><p>@Transactional标识在方法上，只会影响该方法 </p><p>@Transactional标识的类上，会影响类中所有的方法</p><p>事务属性：只读   @Transactional(readOnly &#x3D; true)</p><p>事务属性：超时  @Transactional(timeout &#x3D; 3)</p><p>事务属性：回滚策略</p><img src="/2022/09/01/SSM%E6%A1%86%E6%9E%B6%E7%AF%87/image-20220831163321101.png" alt="image-20220831163321101" style="zoom: 67%;"><p>事务属性：事务隔离级别</p><p>@Transactional(isolation &#x3D; Isolation.DEFAULT)&#x2F;&#x2F;使用数据库默认的隔离级别</p><p>@Transactional(isolation &#x3D; Isolation.READ_UNCOMMITTED)&#x2F;&#x2F;读未提交 </p><p>@Transactional(isolation &#x3D; Isolation.READ_COMMITTED)&#x2F;&#x2F;读已提交 </p><p>@Transactional(isolation &#x3D; Isolation.REPEATABLE_READ)&#x2F;&#x2F;可重复读</p><p>@Transactional(isolation &#x3D; Isolation.SERIALIZABLE)&#x2F;&#x2F;串行化</p><p>事务属性：事务传播行为</p><p>可以通过@Transactional中的propagation属性设置事务传播行为</p><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="MVC概述"><a href="#MVC概述" class="headerlink" title="MVC概述"></a>MVC概述</h3><p>Spring MVC是一种基于java实现的MVC设计模型的请求驱动类型的轻量级Wen框架</p><p>M：Model，模型层，</p><p>V：View，视图层，</p><p>C：Controller，控制层，</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>1.用户发送请求至前端控制器</p><p>2.收到请求调用处理器映射器</p><p>3.处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器一并返回给前端控制器</p><p>4.前端控制器调用处理器适配器</p><p>5.处理器适配器经过适配调用具体处理器</p><p>6.处理器执行完成返回ModelAndView</p><p>7.处理器适配器将ModelAndView返回给前端控制器</p><p>8.前端控制器将ModelAndView传给视图解析器</p><p>9.视图解析器解析后返回具体视图</p><p>10.前端控制器根据视图进行渲染</p><p>11.最后响应用户</p><img src="/2022/09/01/SSM%E6%A1%86%E6%9E%B6%E7%AF%87/image-20220831165135371.png" alt="image-20220831165135371" style="zoom: 67%;"><p>前端控制器：接受请求，响应结果</p><p>处理器映射器：根据URL查找处理器</p><p>处理器适配器：把处理器包装成适配器，这些可支持多种类型的处理器</p><p>处理器：程序员写代码处理逻辑</p><p>视图解析器：进行视图解析</p><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><p>@RequestMapping：用于处理请求url映射的注解</p><p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</p><p>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</p><p>@RequestMapping注解的value属性通过请求的请求地址匹配请求映射</p><p>@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射</p><p>SpringMVC中提供了@RequestMapping的派生注解 </p><ul><li><p>处理get请求的映射–&gt;@GetMapping </p></li><li><p>处理post请求的映射–&gt;@PostMapping </p></li><li><p>处理put请求的映射–&gt;@PutMapping </p></li><li><p>处理delete请求的映射–&gt;@DeleteMapping</p></li></ul><p>@RequestBody：实现接收http请求的json数据，将json转化为java对象</p><p>@ResponseBody：实现将controller方法返回的对象转化为json对象响应给用户</p><h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><h3 id="mybatis概述"><a href="#mybatis概述" class="headerlink" title="mybatis概述"></a>mybatis概述</h3><p>mybatis是优秀的基于java的持久层框架，他内部封装了jdbc，使开发者只需关注sql本身，而不需要花费精力区处理加载驱动，创建连接等繁杂的过程</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优</p><p>1.基于SQL编程</p><p>2.消除了jdbc大量冗余的代码，不需要手动开关连接</p><p>3.很好的与各种数据库兼容</p><p>4.能够和Spring很好的整合</p><p>5.提供映射标签，支持对象与数据库ORM字段关系映射，支持对象关系映射标签，支持对象关系组件维护</p><p>缺</p><p>1.SQL语句编写的工作量大</p><p>2.SQL语句依赖数据库，导致数据库移植性差，不能随便更换数据库。</p><p>当实体类的属性名与表的字段名不一样怎么办</p><p>1.定义字段名的别名，让别名和实体类的属性名一致</p><p>2.通过映射字段名和属性名一一对应的关系</p><p>如何分页，分页插件原理</p><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页。可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p><img src="/2022/09/01/SSM%E6%A1%86%E6%9E%B6%E7%AF%87/image-20220831174008418.png" alt="image-20220831174008418" style="zoom:80%;">]]></content:encoded>
      
      
      <category domain="https://HoldusTogether.github.io/categories/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/categories/Java/SSM%E6%A1%86%E6%9E%B6/">SSM框架</category>
      
      
      <category domain="https://HoldusTogether.github.io/tags/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/tags/SSM%E6%A1%86%E6%9E%B6/">SSM框架</category>
      
      
      <comments>https://holdustogether.github.io/2022/09/01/SSM%E6%A1%86%E6%9E%B6%E7%AF%87/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring Cloud</title>
      <link>https://holdustogether.github.io/2022/09/01/spring%20cloud%E7%AF%87/</link>
      <guid>https://holdustogether.github.io/2022/09/01/spring%20cloud%E7%AF%87/</guid>
      <pubDate>Thu, 01 Sep 2022 04:43:31 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;Spring-Cloud篇&quot;&gt;&lt;a href=&quot;#Spring-Cloud篇&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud篇&quot;&gt;&lt;/a&gt;Spring Cloud篇&lt;/h1&gt;&lt;h2 </description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h1 id="Spring-Cloud篇"><a href="#Spring-Cloud篇" class="headerlink" title="Spring Cloud篇"></a>Spring Cloud篇</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SpringCloud是一种微服务框架，集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，，提供了良好的开箱即用体验</p><h2 id="Nacos动态注册"><a href="#Nacos动态注册" class="headerlink" title="Nacos动态注册"></a>Nacos动态注册</h2><p><a href="https://nacos.io/">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud">SpringCloud</a>中的一个组件。</p><p>与Eureka</p><ul><li>依赖不同</li><li>服务地址不同</li></ul><p>Nacos：localhost:8848</p><p>Eureka：localhost:10086</p><!--more--><p>服务分级存储：</p><p><img src="/typora-user-images%5Cimage-20220901093346390.png" alt="image-20220901093346390"></p><p>环境隔离：</p><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><img src="/2022/09/01/spring%20cloud%E7%AF%87/image-20220901093655693.png" alt="image-20220901093655693" style="zoom:50%;"><p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p><img src="/2022/09/01/spring%20cloud%E7%AF%87/image-20220901093741915.png" alt="image-20220901093741915" style="zoom:50%;"><p>可以配置不同的环境</p><p>Nacos的服务实例分为两种l类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>Nacos与Eureka的区别：</p><ul><li><p>Nacos与eureka的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos与Eureka的区别</p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。</p><p><img src="/typora-user-images%5Cimage-20220901094036623.png" alt="image-20220901094036623"></p><p>基本流程</p><ul><li>拦截RestTemplate请求</li><li>获取服务名称</li><li>根据服务名称到Eureka中拉取服务列表</li><li>Eureka返回服务列表</li><li>根据负载均衡规则，从列表中选择端口</li><li>修改请求地址，发起真实请求</li></ul><p>负载均衡策略</p><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule（轮询）</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule          （可用过滤）（过滤掉一直失败和高并发的服务）</td><td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit属性进行配置。</clientConfigNameSpace></clientName></td></tr><tr><td>WeightedResponseTimeRule（响应时间+权重）</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td>**ZoneAvoidanceRule **             （区域权衡）（优先同区域轮询）</td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule                    （最低并发）</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule（随机）</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule（重试）</td><td>重试机制的选择逻辑</td></tr></tbody></table><p>nginx的五种负载均衡策略</p><p>1.轮询（默认）</p><p>2.指定权重</p><p>3.IP_hash（IP绑定）</p><p>4.fair（第三方）</p><p>5.url_hash</p><h2 id="Feign远程调用"><a href="#Feign远程调用" class="headerlink" title="Feign远程调用"></a>Feign远程调用</h2><p>使用Feign的步骤：</p><p>① 引入依赖</p><p>② 添加@EnableFeignClients注解</p><p>③ 编写FeignClient接口</p><p>④ 使用FeignClient中定义的方法代替RestTemplate</p><p>feign和openfeign的区别</p><p>他们底层都是内置了Ribbon，去调用注册中心的服务</p><p>Feign是SpringCloud组件中的一个轻量级RESTful的HTTP服务客户端，是SpringCloud中的第一代负载均衡客户端。</p><p>OpenFeign是SpringCloud自己研发的，在Feign的基础上支持了Spring MVC的注解。</p><h2 id="Gateway服务网关"><a href="#Gateway服务网关" class="headerlink" title="Gateway服务网关"></a>Gateway服务网关</h2><p>网关的<strong>核心功能特性</strong>：</p><ul><li><p>请求路由</p></li><li><p>权限控制</p></li><li><p>限流</p><img src="/2022/09/01/spring%20cloud%E7%AF%87/image-20220901100512015.png" alt="image-20220901100512015" style="zoom: 67%;"></li></ul><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。</p><p>SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现</p><p>过滤器工厂</p><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p><img src="/2022/09/01/spring%20cloud%E7%AF%87/image-20220901100834485.png" alt="image-20220901100834485" style="zoom:67%;"><p>过滤器的作用是什么？</p><p>① 对路由的请求或响应做加工处理，比如添加请求头</p><p>② 配置在路由下的过滤器只对当前路由的请求生效</p><p>defaultFilters的作用是什么？</p><p>① 对所有路由都生效的过滤器</p><p>过滤器执行顺序</p><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li><li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li></ul><img src="/2022/09/01/spring%20cloud%E7%AF%87/image-20220901101036742.png" alt="image-20220901101036742" style="zoom:67%;"><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>同步和异步通讯</p><p>微服务间通讯有同步和异步两种方式：</p><p>同步通讯：就像打电话，需要实时响应。</p><p>异步通讯：就像发邮件，不需要马上回复</p><p>同步调用的优点：</p><ul><li>时效性较强，可以立即得到结果</li></ul><p>同步调用的问题：</p><ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul><p>异步通讯：发布订阅模式</p><p>好处：</p><ul><li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p></li><li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p></li><li><p>调用间没有阻塞，不会造成无效的资源占用</p></li><li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p></li><li><p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p></li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><p><img src="/typora-user-images%5Cimage-20220901101426162.png" alt="image-20220901101426162"></p><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><p>基本结构：</p><p><img src="/typora-user-images%5Cimage-20220901101602432.png" alt="image-20220901101602432"></p><p>RabbitMQ中的一些角色：</p><ul><li>publisher：生产者</li><li>consumer：消费者</li><li>exchange个：交换机，负责消息路由</li><li>queue：队列，存储消息</li><li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li></ul><p>RabbitMQ消息模型</p><ul><li>基本消息队列（BasicQueue）</li><li>工作消息队列（WorkQueue）</li><li>发布订阅（Publish，Subscribe）根据交换机类型分以下三种<ul><li>广播（Fanout Exchange）</li><li>路由（Direct Exchange）</li><li>主题（Topic Exchange）（通配符）</li></ul></li></ul><p>基本消息队列</p><img src="/2022/09/01/spring%20cloud%E7%AF%87/image-20220901102029643.png" alt="image-20220901102029643" style="zoom:50%;"><p>工作消息队列：<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p><p><img src="/typora-user-images%5Cimage-20220901102131369.png" alt="image-20220901102131369"></p><p>发布订阅</p><img src="/2022/09/01/spring%20cloud%E7%AF%87/image-20220901102236428.png" alt="image-20220901102236428" style="zoom:67%;"><p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li><li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li>Consumer：消费者，与以前一样，订阅队列，没有变化</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><p><strong>Fanout广播</strong></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><img src="/2022/09/01/spring%20cloud%E7%AF%87/image-20220901102513476.png" alt="image-20220901102513476" style="zoom:67%;"><p><strong>Direct定向</strong></p><p> 在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><img src="/2022/09/01/spring%20cloud%E7%AF%87/image-20220901102601018.png" alt="image-20220901102601018" style="zoom: 67%;"><p><strong>Topic通配符</strong></p><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p> 通配符规则：</p><p><code>#</code>：匹配一个或多个词</p><p><code>*</code>：匹配不多不少恰好1个词</p><p>举例：</p><p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p><p><code>item.*</code>：只能匹配<code>item.spu</code></p><img src="/2022/09/01/spring%20cloud%E7%AF%87/image-20220901102859843.png" alt="image-20220901102859843" style="zoom:67%;">]]></content:encoded>
      
      
      <category domain="https://HoldusTogether.github.io/categories/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/categories/Java/Spring-Cloud/">Spring Cloud</category>
      
      
      <category domain="https://HoldusTogether.github.io/tags/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/tags/Spring-Cloud/">Spring Cloud</category>
      
      <category domain="https://HoldusTogether.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</category>
      
      
      <comments>https://holdustogether.github.io/2022/09/01/spring%20cloud%E7%AF%87/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JUC</title>
      <link>https://holdustogether.github.io/2022/09/01/JUC/</link>
      <guid>https://holdustogether.github.io/2022/09/01/JUC/</guid>
      <pubDate>Thu, 01 Sep 2022 04:42:54 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;JUC&quot;&gt;&lt;a href=&quot;#JUC&quot; class=&quot;headerlink&quot; title=&quot;JUC&quot;&gt;&lt;/a&gt;JUC&lt;/h1&gt;&lt;h2 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;heade</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>（进程）</p><p>1.当一个程序被运行，从磁盘加载这个程序的代码到内存，这是就开启了一个进程。</p><p>2.进程可以视为程序的一个实例；大部门程序可以同时运行多个实例进程，也有的程序只能启动一个实例进程。</p><p>（线程）</p><p>1.一个进程可以分为一道多个线程。</p><p>2.一个线程就是一个指令流。</p><p>3.线程作为最小调度单位，进程作为资源分配最小单位。</p><p>（区别）</p><p>1.进程基本相互独立，而线程存于进程之中，是进程的一个子集。</p><p>2.进程拥有共享的资源，供其内部的线程共享。</p><p>3.进程间通信较为复杂，线程间相对简单，线程上下文切换成本一般要比进程上下文切换低。</p><p>（并发并行）</p><p>1.线程轮流使用cpu的做法称为并发。</p><p>2.多核cpu下，每个核都可以调度运行线程称为并行。</p><p>3.并发时是同一时间应对多件事情的能力</p><p>4.并行时是同一时间做多件事情的能力</p><h2 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h2><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><p>1.继承Thread类</p><p>Thread t1 &#x3D; new Thread（）{</p><p>public void run（）{</p><p>&#x2F;&#x2F;执行的任务</p><p>}</p><p>} ；</p><p>t1.start（）；</p><img src="/2022/09/01/JUC/image-20220825150714014.png" alt="image-20220825150714014" style="zoom:50%;"><p>2.实现Runnable接口</p><p>Runnable runnable &#x3D; new Runnable（）{</p><p>public void run（）{</p><p>&#x2F;&#x2F;执行的任务</p><p>}</p><p>}；</p><p>Thread t &#x3D; new Thread（runnable）；</p><p>t.start（）；</p><img src="/2022/09/01/JUC/image-20220825150733923.png" alt="image-20220825150733923" style="zoom:50%;"><p>3.实现Callable接口(需要借助FutureTask类)</p><p>FutureTask<Integer> task &#x3D; new FutureTask&lt;&gt;(() -&gt;{</Integer></p><p>&#x2F;&#x2F;执行的任务</p><p>return 100；</p><p>})；</p><p>new Theard（task）.start（）；</p><p>Integer result &#x3D; task.get（）；</p><p><img src="/typora-user-images%5Cimage-20220825152200251.png" alt="image-20220825152200251"></p><p>使用Runnable和Callable的区别</p><p>1.Runnable重写的是run()方法，Callable重写的是call（）方法。</p><p>2.Callable能够抛出exception，而Runnable不可以。</p><p>3.Callable能得到返回结果，而Runnable不可以。</p><p>4.线程池方式</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>1.start()；启动一个新线程 </p><p>2.run();新线程启动后调用的方法</p><p>3.join();等待线程运行结束</p><p>4.join(long n);最多等待n毫秒</p><p>5.getId();获取线程长整型Id</p><p>6.getName();获取线程名</p><p>7.setName(String);修改线程名</p><p>8.getPriority();获取线程优先级</p><p>9.setPriority(int);修改线程优先级</p><p>10.getState();获取线程状态</p><p>11.isInterrupted();判断是否被打断（不会清楚打断标记）</p><p>12.isAlive();判断是否存活</p><p>13.interrupt();打断线程</p><p>14.interrupted();判断是否被打断（清除打断标记）</p><p>15.currentTread();获取当前线程</p><p>16.sellp(long n);休眠n毫秒</p><p>17.yield();让出当前线程对cpu的使用</p><p>18.stop();停止线程运行</p><p>19.suspend();挂起线程</p><p>20.resume();恢复线程运行</p><p><img src="/typora-user-images%5Cimage-20220825154647229.png" alt="image-20220825154647229"></p><p><img src="/typora-user-images%5Cimage-20220825154804449.png" alt="image-20220825154804449"></p><p>有三个线程T1,T2,T3,如何保证顺序执行</p><p>使用线程类里的join()方法在一个线程中启动另一个线程，另外一个线程完成后该线程继续执行。</p><p><img src="/typora-user-images%5Cimage-20220825160633562.png" alt="image-20220825160633562"></p><h3 id="两阶段终止之interrupt（如何在T1优雅的终止线程T2）"><a href="#两阶段终止之interrupt（如何在T1优雅的终止线程T2）" class="headerlink" title="两阶段终止之interrupt（如何在T1优雅的终止线程T2）"></a>两阶段终止之interrupt（如何在T1优雅的终止线程T2）</h3><p><img src="/typora-user-images%5Cimage-20220825161134185.png" alt="image-20220825161134185"></p><img src="/2022/09/01/JUC/image-20220825161450735.png" alt="image-20220825161450735" style="zoom: 80%;"><p>睡眠中被打断 打断标记会被置为假，所以需要重新设置打断标记</p><p><img src="/typora-user-images%5Cimage-20220825161818811.png" alt="image-20220825161818811"></p><h3 id="主线程与守护线程"><a href="#主线程与守护线程" class="headerlink" title="主线程与守护线程"></a>主线程与守护线程</h3><p>默认情况下，Java进程需要等待所有线程运行结束后才会结束，但有一种特殊的线程叫做守护线程，只要其他的非守护线程都运行结束了，即使守护线程没有执行完，也会强制结束。</p><h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>（操作系统层面  - 5种）</p><p>1.初始状态，仅是创建了线程对象，未与操作系统线程关联</p><p>2.可运行状态（就绪状态），指线程已经被创建，与操作系统线程关联，可由CPU调度执行</p><p>3.运行状态，之线程获取CPU时间片运行中的状态</p><p>当CPU时间片用完会从运行状态变为可运行状态导致线程上下文切换。</p><p>4.阻塞状态，如果调用阻塞API，如读写文件，这时线程实际不会用到CPU，会导致线程上下文切换，进入阻塞状态</p><p>操作执行完，操作系统会唤醒阻塞线程，转换为可运行状态</p><p>对于阻塞状态，只要一直不唤醒它们，调度器就一直不会考虑调度它们</p><p>5.终止状态，表示线程执行完毕，生命周期结束</p><img src="/2022/09/01/JUC/image-20220825163113360.png" alt="image-20220825163113360" style="zoom:50%;"><p>（Java API层面  -6种）</p><img src="/2022/09/01/JUC/image-20220825163219022.png" alt="image-20220825163219022" style="zoom:50%;"><ul><li><p>new -&gt; runnable</p><ul><li>调用t.start()方法时，new –&gt;runnable</li></ul></li><li><p>runnable &lt;—&gt; waiting</p><ul><li>t线程用synchronized获取对象锁后<ul><li>调用wait()方法时，runnable –&gt; waiting</li><li>调用notify()&#x2F;notifyAll()&#x2F;interrupt()方法时,竞争成功waiting–&gt;runnable，竞争失败waiting–&gt;blocked</li></ul></li><li>当前线程调用t.join()方法时<ul><li>当前线程从runnable –&gt; waiting</li><li>t线程运行结束，或调用当前线程的interrupt()时，waiting –&gt; runnable</li></ul></li><li>当前线程调用LockSupport.park()方法时<ul><li>当前线程runnable –&gt; waiting</li><li>调用LockSupport.Unpark()，或调用当前线程interrupt()，waiting –&gt; runnable</li></ul></li></ul></li><li><p>runnable &lt;—&gt; Timed waiting</p><ul><li>当前线程调用Thread.sleep(long n)，当前线程从runnable –&gt; Timed waiting,等待超过n毫秒，从Timed waiting–&gt; runnable</li><li>其他与runnable &lt;—&gt;waiting相同，只是规定了等待时间</li></ul></li><li><p>runnable &lt;—&gt; blocked</p><ul><li><p>t线程使用synchronized获取对象锁竞争失败</p></li><li><p>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t线程竞争</p><p>成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 BLOCKED</p></li></ul></li><li><p>runnable -&gt; terminated</p><ul><li>当前线程所有代码运行完毕</li></ul></li></ul><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>线程安全是指在拥有共享数据的多线程并行执行的程序中，线程安全的代码会保证各个宣称都可以正常且正确的执行，不会出现数据污染的意外情况。</p><p><img src="/typora-user-images%5Cimage-20220825164114057.png"></p><p><img src="/typora-user-images%5Cimage-20220825163723043.png" alt="image-20220825163723043"></p><h3 id="重量级锁synchronized"><a href="#重量级锁synchronized" class="headerlink" title="重量级锁synchronized"></a>重量级锁synchronized</h3><img src="/2022/09/01/JUC/image-20220825165424914.png" alt="image-20220825165424914" style="zoom:50%;"><p><img src="/2022/09/01/JUC/image-20220825165453774.png" alt="image-20220825165453774" style="zoom:50%;"><img src="/2022/09/01/JUC/image-20220825165551728.png" alt="image-20220825165551728" style="zoom: 50%;"></p><p>（原理）Java对象头</p><img src="/2022/09/01/JUC/image-20220825165953337.png" alt="image-20220825165953337" style="zoom:50%;"><img src="/2022/09/01/JUC/image-20220825194325146.png" alt="image-20220825194325146" style="zoom: 67%;"><p>Monitor结构</p><p>每一个对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁（重量级），该对象的对象头中的Mark Word中就被设置为指向Monitor对象的指针</p><p><img src="/typora-user-images%5Cimage-20220825170517236.png" alt="image-20220825170517236"></p><p>刚开始 Monitor 中 Owner 为 null</p><p>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一</p><p>个 Owner</p><p>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入</p><p>EntryList BLOCKED</p><p>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</p><p>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲</p><p>wait-notify 时会分析</p><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><p>1.轻量级锁</p><p>如果一个对象有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），便可以使用轻量级锁来优化</p><p><img src="/typora-user-images%5Cimage-20220825191706980.png" alt="image-20220825191706980"></p><p>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的</p><p>Mark Word</p><img src="/2022/09/01/JUC/image-20220825192418373.png" alt="image-20220825192418373" style="zoom:50%;"><p>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存</p><p>入锁记录</p><img src="/2022/09/01/JUC/image-20220825192434491.png" alt="image-20220825192434491" style="zoom:50%;"><p>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</p><img src="/2022/09/01/JUC/image-20220825192450508.png" alt="image-20220825192450508" style="zoom:50%;"><p>如果 cas 失败，有两种情况</p><p>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</p><p>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</p><img src="/2022/09/01/JUC/image-20220825192504498.png" alt="image-20220825192504498" style="zoom:50%;"><p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重</p><p>入计数减一</p><img src="/2022/09/01/JUC/image-20220825192520642.png" alt="image-20220825192520642" style="zoom:50%;"><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象</p><p>头</p><p>成功，则解锁成功</p><p>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p><p>2.偏向锁：轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现</p><p>这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p><img src="/2022/09/01/JUC/image-20220825193847816.png" alt="image-20220825193847816" style="zoom:50%;"><p><img src="/typora-user-images%5Cimage-20220825193931187.png" alt="image-20220825193931187"></p><p>一个对象创建时：</p><p>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的</p><p>thread、epoch、age 都为 0</p><p>撤销偏向锁—调用对象hashcode</p><p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被</p><p>撤销</p><p>轻量级锁会在锁记录中记录 hashCode</p><p>重量级锁会在 Monitor 中记录 hashCode</p><p>撤销偏向锁—调用其他线程</p><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p><p>撤销偏向锁—调用wait&#x2F;notify</p><p>3.自旋 ： 让线程进入一种忙循环</p><p><img src="/2022/09/01/JUC/image-20220825193316371.png" alt="image-20220825193316371" style="zoom: 33%;"><img src="/2022/09/01/JUC/image-20220825193347077.png" alt="image-20220825193347077" style="zoom:33%;"></p><p>4.自适应自旋：自旋的时间不是固定时间，而是由前一次在同一个锁上的自旋时间和锁的持有者的状态决定</p><p>5.锁消除：是指JVM检测到一些同步的代码块，完全不存在数据竞争的场景，也就是完全不需要加锁，就会进行锁消除</p><p>6.锁粗化：是指很多操作都是对同一个对象加锁，就会把锁的同步范围扩展到整个操作序列之外</p><h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有</p><p>竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</p><img src="/2022/09/01/JUC/image-20220825192712870.png" alt="image-20220825192712870" style="zoom:50%;"><p>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程</p><p>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址，然后自己进入 Monitor 的 EntryList BLOCKED</p><img src="/2022/09/01/JUC/image-20220825192747897.png" alt="image-20220825192747897" style="zoom:50%;"><p>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁</p><p>流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</p><h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait - notify"></a>wait - notify</h3><p>sleep（）和wait（）的区别</p><p>1.sleep是属于Thread类中，wait属于Object类中</p><p>2.sleep不需要强制和synchronized配合使用，wait需要</p><p>3.sleep在睡眠时不会释放锁对象，wait会释放锁对象</p><p>notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线</p><p>程，称之为【虚假唤醒】</p><p>原理</p><img src="/2022/09/01/JUC/image-20220825201243619.png" alt="image-20220825201243619" style="zoom: 67%;"><p>Owner 线程中的Thread-2在运行时发现条件不满足，会调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</p><p>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</p><p>BLOCKED 线程会在 Owner 线程释放锁时唤醒</p><p>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入</p><p>EntryList 重新竞争</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>原理</p><p>判断线程是否存活，存活就一直等待</p><img src="/2022/09/01/JUC/image-20220825202020706.png" alt="image-20220825202020706" style="zoom:80%;"><h3 id="Park-amp-amp-Unpark"><a href="#Park-amp-amp-Unpark" class="headerlink" title="Park&amp;&amp;Unpark"></a>Park&amp;&amp;Unpark</h3><p>基本使用</p><p><img src="/typora-user-images%5Cimage-20220825202404102.png" alt="image-20220825202404102"></p><p>原理</p><p>每个线程都有自己的一个 Parker 对象，由三部分组成 _counter ， _cond 和 _mutex 打个比喻</p><ul><li>线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中</li></ul><p>​     的备用干粮（0 为耗尽，1 为充足）</p><ul><li><p>调用 park 就是要看需不需要停下来歇息</p><ul><li>如果备用干粮耗尽，那么钻进帐篷歇息</li><li>如果备用干粮充足，那么不需停留，继续前进</li></ul></li><li><p>调用 unpark，就好比令干粮充足</p><ul><li>如果这时线程还在帐篷，就唤醒让他继续前进</li><li>如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进<ul><li>因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮</li></ul></li></ul></li></ul><p>与 Object 的 wait &amp; notify 相比</p><p>1.wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</p><p>2.park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll </p><p>是唤醒所有等待线程，就不那么【精确】</p><p>3.park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</p><h3 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h3><p>一个对象设置多把锁，设置不同的功能</p><p><img src="/typora-user-images%5Cimage-20220825210124349.png" alt="image-20220825210124349"></p><p>将锁的粒度细分</p><ul><li><p>好处，是可以增强并发度</p></li><li><p>坏处，如果一个线程需要同时获得多把锁，就容易发生死锁</p></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁</p><p>t1 线程 获得A对象锁，接下来想获取B对象的锁</p><p>t2 线程 获得B对象锁，接下来想获取A对象的锁</p><img src="/2022/09/01/JUC/image-20220825210636173.png" alt="image-20220825210636173" style="zoom:67%;"><p>产生死锁的必要条件</p><p>1.互斥条件：一个资源每次只能被一个线程调用</p><p>2.请求与保持条件：一个线程因请求资源而阻塞时，对以获得的资源保持不放</p><p>3.不剥夺条件：进程已经获得的资源，在未使用完成之前，不能强行剥夺</p><p>4.循环等待条件：若干线程之间形成一种头尾相接的循环等待资源的关系</p><p>避免死锁</p><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束</p><img src="/2022/09/01/JUC/image-20220825210914165.png" alt="image-20220825210914165" style="zoom:80%;"><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>相对于 synchronized 有什么不同</p><p>相同点都是加锁同步，而且都是阻塞式同步，都可重入</p><p>不同点</p><ul><li>对于synchronized来说，他是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock是API层面的互斥锁，需要lock()和unlock()方法配合try&#x2F;finally语句块完成</li><li>ReentrantLock功能更高级，支持可中断，可以设置超时时间，可以设置为公平锁，支持多个条件变量</li></ul><p>基本语法</p><img src="/2022/09/01/JUC/image-20220825212031737.png" alt="image-20220825212031737" style="zoom:50%;"><ul><li><p>可打断<img src="/2022/09/01/JUC/image-20220825212723789.png" alt="image-20220825212723789" style="zoom:50%;"></p></li><li><p>设置超时时间</p><ul><li>立刻失败<img src="/2022/09/01/JUC/image-20220825212826045.png" alt="image-20220825212826045" style="zoom:50%;"></li><li>超时失败<img src="/2022/09/01/JUC/image-20220825212928805.png" alt="image-20220825212928805" style="zoom:50%;"></li></ul></li><li><p>设置公平锁（默认不公平）<img src="/2022/09/01/JUC/image-20220825213047895.png" alt="image-20220825213047895" style="zoom: 80%;"></p></li><li><p>设置条件变量（休息室）<img src="/2022/09/01/JUC/image-20220825213505085.png" alt="image-20220825213505085" style="zoom:80%;"></p><p>await（等待） signal&#x2F;signalAll（唤醒）</p><p>await 前需要获得锁</p><p>await 执行后，会释放锁，进入 conditionObject 等待</p><p>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</p><p>竞争 lock 锁成功后，从 await 后继续执行</p></li></ul><h2 id="Java内存模型-JMM"><a href="#Java内存模型-JMM" class="headerlink" title="Java内存模型 JMM"></a>Java内存模型 JMM</h2><h3 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h3><p>JMM 体现在以下几个方面</p><p>原子性 - 保证指令不会受到线程上下文切换的影响</p><p>可见性 - 保证指令不会受 cpu 缓存的影响</p><p>有序性 - 保证指令不会受 cpu 指令并行优化的影响</p><ul><li>对于可见性—–volatile（易变关键字）</li></ul><p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取</p><p>它的值，线程操作 volatile 变量都是直接操作主存</p><ul><li>对于有序性—volatile 修饰的变量，可以禁用指令重排</li></ul><h3 id="两阶段终止-volatile"><a href="#两阶段终止-volatile" class="headerlink" title="两阶段终止-volatile"></a>两阶段终止-volatile</h3><img src="/2022/09/01/JUC/image-20220826092842804.png" alt="image-20220826092842804" style="zoom:80%;"><h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence） </p><ul><li><p>对 volatile 变量的写指令后会加入写屏障</p></li><li><p>对 volatile 变量的读指令前会加入读屏障</p><p>可见性</p><ul><li><p>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中</p></li><li><p>而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</p><img src="/2022/09/01/JUC/image-20220825215023006.png" alt="image-20220825215023006" style="zoom: 80%;"><img src="/2022/09/01/JUC/image-20220825215039128.png" alt="image-20220825215039128" style="zoom:80%;"><p><img src="/typora-user-images%5Cimage-20220825215101205.png" alt="image-20220825215101205"></p></li></ul><p>有序性</p><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p></li><li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><img src="/2022/09/01/JUC/image-20220825215113043.png" alt="image-20220825215113043" style="zoom:80%;"><img src="/2022/09/01/JUC/image-20220825215129469.png" alt="image-20220825215129469" style="zoom:80%;"><img src="/2022/09/01/JUC/image-20220825215153476.png" alt="image-20220825215153476" style="zoom:80%;"></li></ul><p>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性</p></li></ul><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><h3 id="cas（-Compare-And-Set）"><a href="#cas（-Compare-And-Set）" class="headerlink" title="cas（ Compare And Set）"></a>cas（ Compare And Set）</h3><p><strong>cas与volatile</strong></p><p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。</p><p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取</p><p>它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p><p><strong>注意</strong></p><p>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原</p><p>子性）</p><p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</p><p><strong>原理</strong></p><p>cas主要通过处理器的指令保证操作的原子性，包含3个操作数：1.变量内存地址，V表示  2.旧的预期值，A表示  3.准备设置的新值，B表示</p><p>当执行cas指令时，只有当V等于A，才会用B去更新V的值，否则不会执行更新操作。</p><p><strong>CAS</strong> <strong>的特点</strong></p><p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</p><p>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再</p><p>重试呗。</p><p>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想</p><p>改，我改完了解开锁，你们才有机会。</p><p>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思</p><p>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</p><p>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</p><p><strong>缺点</strong></p><p>1.对于ABA问题：主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况</p><p>如果主线程希望：</p><p>只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号</p><p>【AtomicStampedReference】</p><img src="/2022/09/01/JUC/image-20220826100632311.png" alt="image-20220826100632311" style="zoom:80%;"><p>2.循环时间长开销大，自旋 cas的方式如果长时间不成功，会给cpu带来很大的开销</p><p>3.只能保证一个共享变量的原子操作</p><h3 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h3><p>AtomicBoolean</p><p>AtomicInteger</p><p>AtomicLong</p><p>举例：</p><p>AtomicInteger i &#x3D; new AtomicInteger(0);</p><p>i.getAndIncrement() 获取并自增</p><p>i.incrementAndGet() 自增并获取</p><p>i.decrementAndGet()自减并获取</p><p>i.getAndDecrement() 获取并自减</p><p>i.getAndAdd(5) 获取并加值</p><p>i.addAndGet(-5) 加值并获取</p><p>i.getAndUpdate(p -&gt; p - 2) 获取并更 新</p><p>i.updateAndGet(p -&gt; p + 2) 更新并获取</p><p>i.getAndAccumulate(10, (p, x) -&gt; p + x) 获取并计算</p><p>i.accumulateAndGet(-10, (p, x) -&gt; p + x)  计算并获取</p><h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><p>AtomicReference</p><p>AtomicMarkableReference</p><p>AtomicStampedReference</p><h3 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h3><p>AtomicIntegerArray</p><p>AtomicLongArray</p><p>AtomicReferenceArray</p><h3 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h3><p>AtomicReferenceFieldUpdater &#x2F;&#x2F; 域 字段</p><p>AtomicIntegerFieldUpdater</p><p>AtomicLongFieldUpdater</p><h3 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h3><p>AtomicLong</p><p>LongAdder（性能更好）</p><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><p><strong>final原理</strong></p><p>设置final变量</p><img src="/2022/09/01/JUC/image-20220826104623218.png" alt="image-20220826104623218" style="zoom:80%;"><p>获取final变量</p><img src="/2022/09/01/JUC/image-20220826105013411.png" alt="image-20220826105013411" style="zoom:80%;"><p>直接获取到值，而不是获取对象</p><h2 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h4><p>结构</p><p><img src="/typora-user-images%5Cimage-20220826110530194.png" alt="image-20220826110530194"></p><p>拒绝接口</p><img src="/2022/09/01/JUC/image-20220826115305754.png" alt="image-20220826115305754" style="zoom:80%;"><p>线程池</p><img src="/2022/09/01/JUC/image-20220826112226546.png" alt="image-20220826112226546" style="zoom: 80%;"><p>​                                                        <img src="/2022/09/01/JUC/image-20220826115144003.png" alt="image-20220826115144003" style="zoom:80%;"><img src="/2022/09/01/JUC/image-20220826114654120.png" alt="image-20220826114654120" style="zoom:80%;"></p><img src="/2022/09/01/JUC/image-20220826113525615.png" alt="image-20220826113525615" style="zoom:80%;"><p>阻塞队列</p><img src="/2022/09/01/JUC/image-20220826112837373.png" alt="image-20220826112837373" style="zoom:80%;"><img src="/2022/09/01/JUC/image-20220826113011484.png" alt="image-20220826113011484" style="zoom:80%;"><img src="/2022/09/01/JUC/image-20220826113254434.png" alt="image-20220826113254434" style="zoom:80%;"><img src="/2022/09/01/JUC/image-20220826113139239.png" alt="image-20220826113139239" style="zoom:80%;"><img src="/2022/09/01/JUC/image-20220826114007540.png" alt="image-20220826114007540" style="zoom:80%;"><img src="/2022/09/01/JUC/image-20220826113210241.png" alt="image-20220826113210241" style="zoom:80%;"><img src="/2022/09/01/JUC/image-20220826114940379.png" alt="image-20220826114940379" style="zoom:80%;"><p>测试</p><img src="/2022/09/01/JUC/image-20220826115339617.png" alt="image-20220826115339617" style="zoom:80%;"><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p><strong>线程池状态</strong></p><img src="/2022/09/01/JUC/image-20220826142212198.png" alt="image-20220826142212198" style="zoom:80%;"><p><strong>构造方法</strong></p><img src="/2022/09/01/JUC/image-20220826142236947.png" alt="image-20220826142236947" style="zoom:80%;"><p><strong>jdk提供的四种拒绝策略</strong></p><ul><li><p>AbortPolicy让调用者抛出 RejectedExecutionException 异常，这是默认策略</p></li><li><p>CallerRunsPolicy 让调用者运行任务</p></li><li><p>DiscardPolicy 放弃本次任务</p></li><li><p>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</p><p><strong>其他框架提供的策略</strong></p></li><li><p>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方</p><p>便定位问题</p></li><li><p>Netty 的实现，是创建一个新线程来执行任务</p></li><li><p>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</p></li><li><p>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</p></li></ul><p><strong>工厂方法创建常用线程池</strong></p><p>1.newSingleThreadExecutor：创建一个单线程的线程池，保证所有任务的执行顺序按任务的提交顺序执行</p><p>2.newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小</p><ul><li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</li><li>阻塞队列是无界的，可以放任意数量的任务</li></ul><p>3.newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程的大小做限制，线程池大大小完全依赖于操作系统能够创建的最大线程大小</p><ul><li>核心线程数是 0， </li><li>最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，</li><li>意味着全部都是救急线程（60s 后可以回收）</li><li>救急线程可以无限创建</li></ul><p>4.newScheduledThreadPool：任务调度线程池，支持定时已经周期性执行任务的需求</p><p><strong>线程池的提交</strong></p><p>&#x2F;&#x2F; 执行任务</p><p>void execute(Runnable command);</p><p>&#x2F;&#x2F; 提交任务 task，用返回值 Future 获得任务执行结果</p><p><T> Future<T> submit(Callable<T> task);</T></T></T></p><p>&#x2F;&#x2F; 提交 tasks 中所有任务</p><p><T> List&lt;Future<T>&gt; invokeAll(Collection&lt;? extends Callable<T>&gt; tasks)</T></T></T></p><p> throws InterruptedException;</p><p>&#x2F;&#x2F; 提交 tasks 中所有任务，带超时时间</p><p><T> List&lt;Future<T>&gt; invokeAll(Collection&lt;? extends Callable<T>&gt; tasks,</T></T></T></p><p> long timeout, TimeUnit unit) throws InterruptedException;</p><p>&#x2F;&#x2F; 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</p><p><T> T invokeAny(Collection&lt;? extends Callable<T>&gt; tasks) throws InterruptedException, ExecutionException;</T></T></p><p>&#x2F;&#x2F; 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</p><p><T> T invokeAny(Collection&lt;? extends Callable<T>&gt; tasks,</T></T></p><p> long timeout, TimeUnit unit)throws InterruptedException, ExecutionException, TimeoutException;</p><p><img src="/typora-user-images%5Cimage-20220826145642488.png" alt="image-20220826145642488"></p><p><strong>关闭线程池</strong></p><p>shutdown</p><p>线程池状态变为 SHUTDOWN</p><p>- 不会接收新任务</p><p>- 但已提交任务会执行完</p><p>- 此方法不会阻塞调用线程的执行</p><p>shutdownNow</p><p>线程池状态变为 STOP</p><p>- 不会接收新任务</p><p>- 会将队列中的任务返回</p><p>- 并用 interrupt 的方式中断正在执行的任务</p><p>使用线程池的好处</p><p>1.降低资源消耗</p><p>2.提高响应速度</p><p>3.提高线程可管理性</p><h4 id="Fork-x2F-join"><a href="#Fork-x2F-join" class="headerlink" title="Fork&#x2F;join"></a>Fork&#x2F;join</h4><p>Fork&#x2F;Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型</p><p>运算</p><p>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。</p><p>Fork&#x2F;Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运</p><p>算效率</p><p>Fork&#x2F;Join 默认会创建与 cpu 核心数大小相同的线程池</p><p>提交给 Fork&#x2F;Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值）</p><p>例如<img src="/2022/09/01/JUC/image-20220826151100687.png" alt="image-20220826151100687" style="zoom:50%;"></p><h3 id="JUC原理"><a href="#JUC原理" class="headerlink" title="JUC原理"></a>JUC原理</h3><h4 id="aqs原理"><a href="#aqs原理" class="headerlink" title="aqs原理"></a>aqs原理</h4><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p><p>特点</p><ul><li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取</li></ul><p>锁和释放锁</p><ul><li><p>getState - 获取 state 状态</p></li><li><p>setState - 设置 state 状态</p></li><li><p>compareAndSetState - cas 机制设置 state 状态</p></li><li><p>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</p></li><li><p>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</p></li><li><p>条件变量来实现等待、唤醒机制，支持多个条件变量</p></li></ul><p><strong>实现</strong></p><p>子类继承aqs并实现一些方法（默认抛出 UnsupportedOperationException）</p><ul><li><p>tryAcquire</p></li><li><p>tryRelease</p></li><li><p>tryAcquireShared</p></li><li><p>tryReleaseShared</p></li><li><p>isHeldExclusively</p></li></ul><p><img src="/2022/09/01/JUC/image-20220826153237774.png" alt="image-20220826153237774" style="zoom:80%;"><img src="/2022/09/01/JUC/image-20220826153342401.png" alt="image-20220826153342401" style="zoom:80%;"></p><img src="/2022/09/01/JUC/image-20220826153027824.png" alt="image-20220826153027824" style="zoom:80%;"><img src="/2022/09/01/JUC/image-20220826153102537.png" alt="image-20220826153102537" style="zoom:80%;"><h4 id="ReentrantLock原理（非公平锁实现）"><a href="#ReentrantLock原理（非公平锁实现）" class="headerlink" title="ReentrantLock原理（非公平锁实现）"></a>ReentrantLock原理（非公平锁实现）</h4><p>1.没有竞争时，state从0改为1，并将Owner改为自己【Thread-0】</p><img src="/2022/09/01/JUC/image-20220826153700629.png" alt="image-20220826153700629" style="zoom:80%;"><img src="/2022/09/01/JUC/image-20220826154010516.png" alt="image-20220826154010516" style="zoom:80%;"><p>2.有竞争时</p><p><img src="/typora-user-images%5Cimage-20220826154025734.png" alt="image-20220826154025734"></p><img src="/2022/09/01/JUC/image-20220826154044609.png" alt="image-20220826154044609" style="zoom:80%;"><p>Thread-1 执行了</p><ol><li><p>CAS 尝试将 state 由 0 改为 1，结果失败</p></li><li><p>进入acquire中的 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败（尝试重新加锁）</p></li><li><p>接下来进入 addWaiter 逻辑，构造 Node 队列</p></li></ol><p>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态</p><p>Node 的创建是懒惰的</p><p>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</p><img src="/2022/09/01/JUC/image-20220826154120285.png" alt="image-20220826154120285" style="zoom:80%;"><p>当前线程进入 acquireQueued 逻辑</p><ol><li><p>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</p></li><li><p>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</p></li><li><p>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false（-1代表有责任唤醒其后继节点）</p></li></ol><p><img src="/typora-user-images%5Cimage-20220826154702722.png" alt="image-20220826154702722"></p><img src="/2022/09/01/JUC/image-20220826154953365.png" alt="image-20220826154953365" style="zoom:80%;"><ol start="4"><li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时</li></ol><p>state 仍为 1，失败</p><ol start="5"><li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回</li></ol><p>true</p><ol start="6"><li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li></ol><p><img src="/typora-user-images%5Cimage-20220826155153454.png" alt="image-20220826155153454"></p><img src="/2022/09/01/JUC/image-20220826155232539.png" alt="image-20220826155232539" style="zoom: 67%;"><p>再次有多个线程经历上述过程竞争失败，变成这个样子</p><img src="/2022/09/01/JUC/image-20220826155248963.png" alt="image-20220826155248963" style="zoom: 67%;"><p>Thread-0 释放锁，进入 tryRelease 流程，如果成功</p><p>设置 exclusiveOwnerThread 为 null</p><p>state &#x3D; 0</p><img src="/2022/09/01/JUC/image-20220826155510110.png" alt="image-20220826155510110" style="zoom:67%;"><p>当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor 流程</p><p>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1</p><p>回到 Thread-1 的 acquireQueued 流程</p><img src="/2022/09/01/JUC/image-20220826155728301.png" alt="image-20220826155728301" style="zoom: 80%;"><img src="/2022/09/01/JUC/image-20220826155943764.png" alt="image-20220826155943764" style="zoom: 67%;"><p>如果加锁成功（没有竞争），会设置</p><ul><li><p>exclusiveOwnerThread 为 Thread-1，state &#x3D; 1</p></li><li><p>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</p></li><li><p>原本的 head 因为从链表断开，而可被垃圾回收</p></li></ul><p>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</p><img src="/2022/09/01/JUC/image-20220826160136113.png" alt="image-20220826160136113" style="zoom:67%;"><p>如果不巧又被 Thread-4 占了先</p><ul><li><p>Thread-4 被设置为 exclusiveOwnerThread，state &#x3D; 1</p></li><li><p>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻</p></li></ul><p><strong>可重入原理</strong></p><p>第一次设置状态为1</p><p>之后如果已经获得了锁，计数次数不断累加</p><img src="/2022/09/01/JUC/image-20220826160527607.png" alt="image-20220826160527607" style="zoom:80%;"><p>释放锁</p><p>计数-1，state没有减到0，返回false，减到0，返回true，Owner设为null</p><img src="/2022/09/01/JUC/image-20220826160740536.png" alt="image-20220826160740536" style="zoom: 80%;"><p><strong>不可打断模式</strong></p><p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了</p><p><strong>可打断模式</strong></p><p><img src="/typora-user-images%5Cimage-20220826161410194.png" alt="image-20220826161410194"></p><p>在被打断时会抛出异常，而不会进入for循环，停止去等待</p><p><strong>公平锁原理</strong></p><p><img src="/typora-user-images%5Cimage-20220826161759586.png" alt="image-20220826161759586"></p><p>检查AQS队列中是否有老二节点或检查当前节点是不是老二节点，如果没有才回去竞争，如果当前节点不是老二节点，说明有前驱节点在等待，则不会进入compareAndSetState()</p><p><strong>条件变量原理</strong></p><p>await原理</p><p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程</p><p>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p><img src="/2022/09/01/JUC/image-20220826162556697.png" alt="image-20220826162556697" style="zoom:80%;"><img src="/2022/09/01/JUC/image-20220826162948005.png" alt="image-20220826162948005" style="zoom:80%;"><p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁（释放可重入锁所有重入的次数）</p><img src="/2022/09/01/JUC/image-20220826162618897.png" alt="image-20220826162618897" style="zoom:80%;"><p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p><img src="/2022/09/01/JUC/image-20220826162637768.png" alt="image-20220826162637768" style="zoom:80%;"><p>park 阻塞 Thread-0</p><img src="/2022/09/01/JUC/image-20220826162651360.png" alt="image-20220826162651360" style="zoom:80%;"><p>signal原理</p><p>假设 Thread-1 要来唤醒 Thread-0</p><img src="/2022/09/01/JUC/image-20220826163129737.png" alt="image-20220826163129737" style="zoom:80%;"><p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p><p><img src="/typora-user-images%5Cimage-20220826163411187.png" alt="image-20220826163411187"></p><img src="/2022/09/01/JUC/image-20220826163209070.png" alt="image-20220826163209070" style="zoom:80%;"><p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为 -1</p><img src="/2022/09/01/JUC/image-20220826163242657.png" alt="image-20220826163242657" style="zoom:80%;"><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p> <strong>ReentrantReadWriteLock</strong></p><p>当【读操作】远远高于【写操作】时，这时候使用 读写锁 让【 读-读】 可以并发，提高性能。 </p><p>读锁-读锁 可以并发</p><p>读锁-写锁 相互阻塞</p><p>写锁-写锁 也是相互阻塞的</p><p>注意事项</p><ul><li>读锁不支持条件变量</li></ul><ul><li><p>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</p></li><li><p>重入时降级支持：即持有写锁的情况下去获取读锁</p></li></ul><p><strong>StampedLock</strong></p><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p><p>加解读锁</p><p><img src="/typora-user-images%5Cimage-20220826164613917.png" alt="image-20220826164613917"></p><p>加解写锁</p><p><img src="/typora-user-images%5Cimage-20220826164622020.png" alt="image-20220826164622020"></p><p>乐观读，StampedLock 支持 tryOptimisticRead() 方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通</p><p>过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p><p><img src="/typora-user-images%5Cimage-20220826164628446.png" alt="image-20220826164628446"></p><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量，用来限制能同时访问共享资源的线程上限。</p><p>例如      此实例最多三个线程访问</p><img src="/2022/09/01/JUC/image-20220826164949724.png" alt="image-20220826164949724" style="zoom:67%;"><p><strong>原理</strong></p><p>Semaphore 有点像一个停车场，permits 就好像停车位数量，当线程获得了 permits 就像是获得了停车位，然后</p><p>停车场显示空余车位减一</p><p>刚开始，state为 3，这时 5 个线程来获取资源</p><img src="/2022/09/01/JUC/image-20220826165525001.png" alt="image-20220826165525001" style="zoom:50%;"><p>假设其中 Thread-1，Thread-2，Thread-4 cas 竞争成功，而 Thread-0 和 Thread-3 竞争失败，进入 AQS 队列park 阻塞</p><img src="/2022/09/01/JUC/image-20220826165547511.png" alt="image-20220826165547511" style="zoom: 80%;"><p>这时 Thread-4 释放了 permits，state+1状态如下</p><img src="/2022/09/01/JUC/image-20220826165713631.png" alt="image-20220826165713631" style="zoom:67%;"><p>接下来 Thread-0 竞争成功，获得permits 再次设置state为 0，设置自己为 head 节点，断开原来的 head 节点，unpark 接</p><p>下来的 Thread-3 节点，但由于 permits 是 0，因此 Thread-3 在尝试不成功后再次进入 park 状</p><h4 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h4><p>用来进行线程同步协作，等待所有线程完成倒计时。</p><p>其中构造参数用来初始化等待计数值，等待线程调用await() 用来等待计数归零，其他线程调用countDown() 用来让计数减一，减到零等待线程回复运行</p><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p> 循环栅栏，用来进行线程协作，等待线程满足某个计数。（此技术可恢复成初始值）构造时设置『计数个数』，每个线程执</p><p>行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p><p><img src="/typora-user-images%5Cimage-20220826170838931.png" alt="image-20220826170838931"></p><h4 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h4><p><img src="/typora-user-images%5Cimage-20220826171327567.png" alt="image-20220826171327567"></p><ul><li><p>遗留的线程安全集合如 Hashtable ， Vector</p></li><li><p>使用 Collections 装饰的线程安全集合，如：</p><ul><li>Collections.synchronizedCollection</li><li>Collections.synchronizedList</li><li>Collections.synchronizedMap</li><li>Collections.synchronizedSet</li><li>Collections.synchronizedNavigableMap</li><li>Collections.synchronizedNavigableSet </li><li>Collections.synchronizedSortedMap</li><li>Collections.synchronizedSortedSet</li></ul></li><li><p>J.U.C 安全集合</p><ul><li><p>Blocking 大部分实现基于锁，并提供用来阻塞的方法</p></li><li><p>CopyOnWrite 之类容器修改开销相对较重</p></li><li><p>Concurrent 类型的容器</p><ul><li><p>内部很多操作使用 cas 优化，一般可以提供较高吞吐量</p></li><li><p>弱一致性</p><p>1.遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍</p><p>历，这时内容是旧的</p><p>2.求大小弱一致性，size 操作未必是 100% 准确</p><p>3.读取弱一致性</p></li></ul></li></ul></li></ul><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p><strong>Java 8</strong> </p><p>数组（Node） +（ 链表 Node | 红黑树 TreeNode ） 以下数组简称（table），链表简称（bin）</p><ul><li><p>初始化，使用 cas 来保证并发安全，懒惰初始化 table</p></li><li><p>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程会用 synchronized 锁住链表头</p></li><li><p>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的尾部</p></li><li><p>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新table 进行搜索</p></li><li><p>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1&#x2F;6 的节点会把复制到新 table 中</p></li><li><p>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加即可</p></li></ul><p><img src="/typora-user-images%5Cimage-20220826173727926.png" alt="image-20220826173727926"></p><p><strong>java7</strong></p><p>它维护了一个 segment 数组，每个 segment 对应一把锁,每个HasnEntry中又是数组+链表的结构</p><p>优点：如果多个线程访问不同的 segment，实际是没有冲突的，这与 jdk8 中是类似的</p><p>缺点：Segments 数组默认大小为16，这个容量初始化指定后就不能改变了，并且不是懒惰初始化</p><img src="/2022/09/01/JUC/image-20220826173515748.png" alt="image-20220826173515748" style="zoom: 67%;"><p>其中 this.segmentShift 和 this.segmentMask 的作用是决定将 key 的 hash 结果匹配到哪个 segment</p><p>例如，根据某一 hash 值求 segment 位置，先将高位向低位移动 this.segmentShift 位</p><p><img src="/typora-user-images%5Cimage-20220826174248152.png" alt="image-20220826174248152"></p><p>结果再与 this.segmentMask 做位于运算，最终得到 1010 即下标为 10 的 segment</p><p><img src="/typora-user-images%5Cimage-20220826174307398.png" alt="image-20220826174307398"></p><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p><strong>原理</strong></p><p>初始化链表 last &#x3D; head &#x3D; new Node<E>(null); Dummy 节点用来占位，item 为 null</E></p><img src="/2022/09/01/JUC/image-20220826174623421.png" alt="image-20220826174623421" style="zoom:50%;"><p>当一个节点入队 last &#x3D; last.next &#x3D; node;</p><img src="/2022/09/01/JUC/image-20220826174651434.png" alt="image-20220826174651434" style="zoom:67%;"><p>再来一个节点入队 last &#x3D; last.next &#x3D; node;</p><img src="/2022/09/01/JUC/image-20220826174711055.png" alt="image-20220826174711055" style="zoom:67%;"><p>出队h &#x3D; head</p><img src="/2022/09/01/JUC/image-20220826174734826.png" alt="image-20220826174734826" style="zoom:67%;"><p>first &#x3D; h.next</p><img src="/2022/09/01/JUC/image-20220826174748174.png" alt="image-20220826174748174" style="zoom:67%;"><p>h.next &#x3D; h</p><img src="/2022/09/01/JUC/image-20220826174812143.png" alt="image-20220826174812143" style="zoom:67%;"><p>head &#x3D; first</p><img src="/2022/09/01/JUC/image-20220826174836535.png" alt="image-20220826174836535" style="zoom:67%;"><p>E x &#x3D; first.item;</p><p>first.item &#x3D; null;</p><p>return x;</p><img src="/2022/09/01/JUC/image-20220826175007990.png" alt="image-20220826175007990" style="zoom:67%;"><p> <strong>加锁分析</strong></p><p>&#x3D;&#x3D;高明之处&#x3D;&#x3D;在于用了两把锁和 dummy 节点</p><ul><li><p>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</p></li><li><p>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</p><ul><li>消费者与消费者线程仍然串行</li><li>生产者与生产者线程仍然串行</li></ul></li></ul><p>线程安全分析</p><ul><li><p>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是</p><p>head 节点的线程安全。两把锁保证了入队和出队没有竞争</p></li><li><p>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</p></li><li><p>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</p></li></ul><p><strong>性能比较</strong></p><p>主要列举 LinkedBlockingQueue 与 ArrayBlockingQueue 的性能比较</p><ul><li><p>Linked 支持有界，Array 强制有界</p></li><li><p>Linked 实现是链表，Array 实现是数组</p></li><li><p>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</p></li><li><p>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</p></li><li><p>Linked 两把锁，Array 一把锁</p></li></ul><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是</p><ul><li><p>两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</p></li><li><p>dummy 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争</p></li><li><p>只是这【锁】使用了 cas 来实现</p></li></ul><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>底层实现采用了【 写入时拷贝】 的思想，增删改操作会将底层数组拷贝一份，更改操作在新数组上执行，这时不影响其它线程的<strong>并发读</strong>，<strong>读写分离</strong>。</p><p>读读并发 读写并发 写写互斥</p><p>适合『读多写少』的应用场景</p><img src="/2022/09/01/JUC/image-20220826180058867.png" alt="image-20220826180058867" style="zoom:67%;"><p><strong>这里的源码版本是 Java 11，在 Java 1.8 中使用的是ReentrantLock而不是 synchronized</strong></p><p>读操作并未加锁</p><img src="/2022/09/01/JUC/image-20220826180230264.png" alt="image-20220826180230264" style="zoom:67%;"><p><strong>get弱一致性</strong></p><img src="/2022/09/01/JUC/image-20220826180348567.png" alt="image-20220826180348567" style="zoom:80%;"><img src="/2022/09/01/JUC/image-20220826180412869.png" alt="image-20220826180412869" style="zoom:80%;"><p><strong>迭代器弱一致性</strong></p><img src="/2022/09/01/JUC/image-20220826180510564.png" alt="image-20220826180510564" style="zoom:80%;"><p>新线程在移除时是先拷贝一份，在新数组里删除</p><p>而迭代器仍然用的是旧数组，遍历时仍然是旧数组</p><p>不要觉得弱一致性就不好</p><ul><li><p>数据库的 MVCC 都是弱一致性的表现</p></li><li><p>并发高和一致性是矛盾的，需要权衡</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://HoldusTogether.github.io/categories/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/categories/Java/JUC/">JUC</category>
      
      
      <category domain="https://HoldusTogether.github.io/tags/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/tags/JUC/">JUC</category>
      
      
      <comments>https://holdustogether.github.io/2022/09/01/JUC/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>最难不过坚持</title>
      <link>https://holdustogether.github.io/2022/08/30/%E6%9C%80%E9%9A%BE%E4%B8%8D%E8%BF%87%E5%9D%9A%E6%8C%81/</link>
      <guid>https://holdustogether.github.io/2022/08/30/%E6%9C%80%E9%9A%BE%E4%B8%8D%E8%BF%87%E5%9D%9A%E6%8C%81/</guid>
      <pubDate>Tue, 30 Aug 2022 03:02:31 GMT</pubDate>
      
      
      
      
      <category domain="https://HoldusTogether.github.io/categories/%E6%96%87%E5%AD%A6/">文学</category>
      
      <category domain="https://HoldusTogether.github.io/categories/%E6%96%87%E5%AD%A6/%E6%91%98%E5%BD%95/">摘录</category>
      
      
      <category domain="https://HoldusTogether.github.io/tags/%E6%96%87%E5%AD%97/">文字</category>
      
      <category domain="https://HoldusTogether.github.io/tags/%E6%91%98%E5%BD%95/">摘录</category>
      
      
      <comments>https://holdustogether.github.io/2022/08/30/%E6%9C%80%E9%9A%BE%E4%B8%8D%E8%BF%87%E5%9D%9A%E6%8C%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JVM类加载与字节码技术</title>
      <link>https://holdustogether.github.io/2022/08/22/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/</link>
      <guid>https://holdustogether.github.io/2022/08/22/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/</guid>
      <pubDate>Mon, 22 Aug 2022 06:42:43 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;1-类的文件结构&quot;&gt;&lt;a href=&quot;#1-类的文件结构&quot; class=&quot;headerlink&quot; title=&quot;1. 类的文件结构&quot;&gt;&lt;/a&gt;1. 类的文件结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/JVM%E7%B</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h2 id="1-类的文件结构"><a href="#1-类的文件结构" class="headerlink" title="1. 类的文件结构"></a>1. 类的文件结构</h2><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220822145500913.png" alt="image-20220822145500913"></p><h3 id="1-1-魔数"><a href="#1-1-魔数" class="headerlink" title="1.1 魔数"></a>1.1 魔数</h3><hr><p>0~3 字节，表示它是否是【class】类型的文件 </p><p>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</p><h3 id="1-2-版本"><a href="#1-2-版本" class="headerlink" title="1.2 版本"></a>1.2 版本</h3><p>4~7 字节，表示类的版本 00 34（52） 表示是 Java 8</p><h3 id="1-3-常量池"><a href="#1-3-常量池" class="headerlink" title="1.3 常量池"></a>1.3 常量池</h3><h3 id="1-4-访问标识与继承信息"><a href="#1-4-访问标识与继承信息" class="headerlink" title="1.4 访问标识与继承信息"></a>1.4 访问标识与继承信息</h3><h3 id="1-5-Field-信息"><a href="#1-5-Field-信息" class="headerlink" title="1.5 Field 信息"></a>1.5 Field 信息</h3><h3 id="1-6-Method-信息"><a href="#1-6-Method-信息" class="headerlink" title="1.6 Method 信息"></a>1.6 Method 信息</h3><p>​表示方法数量，本类为 2</p><p>​0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p><h3 id="1-7-附加属性"><a href="#1-7-附加属性" class="headerlink" title="1.7 附加属性"></a>1.7 附加属性</h3><p>参考文献</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><h2 id="2-字节码指令"><a href="#2-字节码指令" class="headerlink" title="2. 字节码指令"></a>2. 字节码指令</h2><h3 id="2-1-入门"><a href="#2-1-入门" class="headerlink" title="2.1 入门"></a>2.1 入门</h3><p>接着上一节，研究一下两组字节码指令，一个是</p><p>public cn.itcast.jvm.t5.HelloWorld（）;构造方法的字节码指令</p><ol><li><p>2a &#x3D;&gt; aload_0 加载 slot 0 的局部变量，即 this，做为下面的 invokespecial 构造方法调用的参数</p></li><li><p>b7 &#x3D;&gt; invokespecial 预备调用构造方法，哪个方法呢？</p></li><li><p>00 01 引用常量池中 #1 项，即【Method java&#x2F;lang&#x2F;Object.”“:(）五】</p></li><li><p>b1 表示返回</p></li></ol><p>另一个是 public static void main（java.lang.String[]）;主方法的字节码指令</p><ol><li><p>b2 &#x3D;&gt; getstatic 用来加载静态变量，哪个静态变量呢？</p></li><li><p>00 02 引用常量池中 #2 项，即【Field java&#x2F;lang&#x2F;System.out：Ljava&#x2F;io&#x2F;PrintStream;】</p></li><li><p>12 &#x3D;&gt; ldc 加载参数，哪个参数呢？</p></li><li><p>03 引用常量池中 #3 项，即 【String hello world】</p></li><li><p>b6 &#x3D;&gt; invokevirtual 预备调用成员方法，哪个方法呢？</p></li><li><p>00 04 引用常量池中 #4 项，即【Method java&#x2F;io&#x2F;PrintStream.println：（Ljava&#x2F;lang&#x2F;String;）V】</p></li><li><p>b1 表示返回</p></li></ol><p>请参考</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6%E3%80%82">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6。</a></p><h3 id="2-2-javap-工具"><a href="#2-2-javap-工具" class="headerlink" title="2.2 javap 工具"></a>2.2 javap 工具</h3><p>自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译类 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">2a b7 00 01 b</span><br><span class="line">b2 00 02 12 03 b6 00 04 b</span><br><span class="line">[root@localhost ~]# javap -v HelloWorld.class</span><br><span class="line">Classfile /root/HelloWorld.class</span><br><span class="line">Last modified Jul 7, 2019; size 597 bytes</span><br><span class="line">MD5 checksum 361dca1c3f4ae38644a9cd5060ac6dbc</span><br><span class="line">Compiled from &quot;HelloWorld.java&quot;</span><br><span class="line">public class cn.itcast.jvm.t5.HelloWorld</span><br><span class="line">minor version: 0</span><br><span class="line">major version: 52</span><br><span class="line">flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">#1 = Methodref #6.#21 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#2 = Fieldref #22.#23 //</span><br><span class="line">java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">#3 = String #24 // hello world</span><br><span class="line">#4 = Methodref #25.#26 // java/io/PrintStream.println:</span><br><span class="line">(Ljava/lang/String;)V</span><br><span class="line">#5 = Class #27 // cn/itcast/jvm/t5/HelloWorld</span><br><span class="line">#6 = Class #28 // java/lang/Object</span><br><span class="line">#7 = Utf8 &lt;init&gt;</span><br><span class="line">#8 = Utf8 ()V</span><br><span class="line">#9 = Utf8 Code</span><br><span class="line">#10 = Utf8 LineNumberTable</span><br><span class="line">#11 = Utf8 LocalVariableTable</span><br><span class="line">#12 = Utf8 this</span><br><span class="line">#13 = Utf8 Lcn/itcast/jvm/t5/HelloWorld;</span><br></pre></td></tr></table></figure><p>#14 &#x3D; Utf8 main<br>#15 &#x3D; Utf8 （[Ljava&#x2F;lang&#x2F;String;）V<br>#16 &#x3D; Utf8 args<br>#17 &#x3D; Utf8 [Ljava&#x2F;lang&#x2F;String;<br>#18 &#x3D; Utf8 MethodParameters<br>#19 &#x3D; Utf8 SourceFile<br>#20 &#x3D; Utf8 HelloWorld.java<br>#21 &#x3D; NameAndType #7：#8 &#x2F;&#x2F; “”:(）V<br>#22 &#x3D; Class #29 &#x2F;&#x2F; java&#x2F;lang&#x2F;System<br>#23 &#x3D; NameAndType #30：#31 &#x2F;&#x2F; out：Ljava&#x2F;io&#x2F;PrintStream;<br>#24 &#x3D; Utf8 hello world<br>#25 &#x3D; Class #32 &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream<br>#26 &#x3D; NameAndType #33：#34 &#x2F;&#x2F; println：（Ljava&#x2F;lang&#x2F;String;）V<br>#27 &#x3D; Utf8 cn&#x2F;itcast&#x2F;jvm&#x2F;t5&#x2F;HelloWorld<br>#28 &#x3D; Utf8 java&#x2F;lang&#x2F;Object<br>#29 &#x3D; Utf8 java&#x2F;lang&#x2F;System<br>#30 &#x3D; Utf8 out<br>#31 &#x3D; Utf8 Ljava&#x2F;io&#x2F;PrintStream;<br>#32 &#x3D; Utf8 java&#x2F;io&#x2F;PrintStream<br>#33 &#x3D; Utf8 println<br>#34 &#x3D; Utf8 （Ljava&#x2F;lang&#x2F;String;）V<br>{<br>public cn.itcast.jvm.t5.HelloWorld（）;<br>descriptor： （）V<br>flags： ACC_PUBLIC<br>Code：<br>stack&#x3D;1， locals&#x3D;1， args_size&#x3D;<br>0： aload_<br>1： invokespecial #1 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.”<br>“:(）V<br>4： 返回<br>行号表：<br>行 4： 0<br>局部变量表：<br>起始长度 插槽名称 签名<br>0 5 0 this Lcn&#x2F;itcast&#x2F;jvm&#x2F;t5&#x2F;HelloWorld;</p><p>public static void main（java.lang.String[]）;<br>描述符： （[Ljava&#x2F;lang&#x2F;String;）V<br>标志： ACC_PUBLIC， ACC_STATIC<br>代码：<br>stack&#x3D;2， locals&#x3D;1， args_size&#x3D;<br>0： getstatic #2 &#x2F;&#x2F; Field<br>java&#x2F;lang&#x2F;System.out：Ljava&#x2F;io&#x2F;PrintStream;<br>3： ldc #3 &#x2F;&#x2F; String hello world<br>5： invokevirtual #4 &#x2F;&#x2F; Method<br>java&#x2F;io&#x2F;PrintStream.println：（Ljava&#x2F;lang&#x2F;String;）V<br>8： return<br>Number LineTable：<br>line 6： 0<br>line 7： 8<br>LocalVariableTable：<br>Start Length Slot Name Signature<br>0 9 0 args [Ljava&#x2F;lang&#x2F;String;<br>方法参数：<br>名称标志<br>参数<br>}</p><h3 id="2-3-图解方法执行流程"><a href="#2-3-图解方法执行流程" class="headerlink" title="2.3 图解方法执行流程"></a>2.3 图解方法执行流程</h3><h4 id="1-）原始-java-代码"><a href="#1-）原始-java-代码" class="headerlink" title="1 ）原始 java 代码"></a>1 ）原始 java 代码</h4><h4 id="2-）编译后的字节码文件"><a href="#2-）编译后的字节码文件" class="headerlink" title="2 ）编译后的字节码文件"></a>2 ）编译后的字节码文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.jvm.t3.bytecode;</span><br><span class="line">/**</span><br><span class="line">* 演示 字节码指令 和 操作数栈、常量池的关系</span><br><span class="line">*/</span><br><span class="line">public class Demo3_1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int a = 10 ;</span><br><span class="line">int b = Short.MAX_VALUE + 1 ;</span><br><span class="line">int c = a + b;</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@localhost ~]# javap -v Demo3_1.class</span><br><span class="line">Classfile /root/Demo3_1.class</span><br><span class="line">Last modified Jul 7, 2019; size 665 bytes</span><br><span class="line">MD5 checksum a2c29a22421e218d4924d31e6990cfc</span><br><span class="line">Compiled from &quot;Demo3_1.java&quot;</span><br><span class="line">public class cn.itcast.jvm.t3.bytecode.Demo3_</span><br><span class="line">minor version: 0</span><br><span class="line">major version: 52</span><br><span class="line">flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">#1 = Methodref #7.#26 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#2 = Class #27 // java/lang/Short</span><br><span class="line">#3 = Integer 32768</span><br><span class="line">#4 = Fieldref #28.#29 //</span><br><span class="line">java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">#5 = Methodref #30.#31 // java/io/PrintStream.println:(I)V</span><br><span class="line">#6 = Class #32 // cn/itcast/jvm/t3/bytecode/Demo3_</span><br><span class="line">#7 = Class #33 // java/lang/Object</span><br><span class="line">#8 = Utf8 &lt;init&gt;</span><br><span class="line">#9 = Utf8 ()V</span><br><span class="line">#10 = Utf8 Code</span><br><span class="line">#11 = Utf8 LineNumberTable</span><br><span class="line">#12 = Utf8 LocalVariableTable</span><br><span class="line">#13 = Utf8 this</span><br><span class="line">#14 = Utf8 Lcn/itcast/jvm/t3/bytecode/Demo3_1;</span><br><span class="line">#15 = Utf8 main</span><br><span class="line">#16 = Utf8 ([Ljava/lang/String;)V</span><br><span class="line">#17 = Utf8 args</span><br><span class="line">#18 = Utf8 [Ljava/lang/String;</span><br><span class="line">#19 = Utf8 a</span><br></pre></td></tr></table></figure><p>#20 &#x3D; Utf8 I<br>#21 &#x3D; Utf8 b<br>#22 &#x3D; Utf8 c<br>#23 &#x3D; Utf8 MethodParameters<br>#24 &#x3D; Utf8 SourceFile<br>#25 &#x3D; Utf8 Demo3_1.java<br>#26 &#x3D; NameAndType #8:#9 &#x2F;&#x2F; “”:()V<br>#27 &#x3D; Utf8 java&#x2F;lang&#x2F;Short<br>#28 &#x3D; Class #34 &#x2F;&#x2F; java&#x2F;lang&#x2F;System<br>#29 &#x3D; NameAndType #35:#36 &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;<br>#30 &#x3D; Class #37 &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream<br>#31 &#x3D; NameAndType #38:#39 &#x2F;&#x2F; println:(I)V<br>#32 &#x3D; Utf8 cn&#x2F;itcast&#x2F;jvm&#x2F;t3&#x2F;bytecode&#x2F;Demo3_<br>#33 &#x3D; Utf8 java&#x2F;lang&#x2F;Object<br>#34 &#x3D; Utf8 java&#x2F;lang&#x2F;System<br>#35 &#x3D; Utf8 out<br>#36 &#x3D; Utf8 Ljava&#x2F;io&#x2F;PrintStream;<br>#37 &#x3D; Utf8 java&#x2F;io&#x2F;PrintStream<br>#38 &#x3D; Utf8 println<br>#39 &#x3D; Utf8 (I)V<br>{<br>public cn.itcast.jvm.t3.bytecode.Demo3_1();<br>descriptor: ()V<br>flags: ACC_PUBLIC<br>Code:<br>stack&#x3D;1, locals&#x3D;1, args_size&#x3D;<br>0: aload_<br>1: invokespecial #1 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.”<br>“:()V<br>4: return<br>LineNumberTable:<br>line 6: 0<br>LocalVariableTable:<br>Start Length Slot Name Signature<br>0 5 0 this Lcn&#x2F;itcast&#x2F;jvm&#x2F;t3&#x2F;bytecode&#x2F;Demo3_1;</p><p>public static void main(java.lang.String[]);<br>descriptor: ([Ljava&#x2F;lang&#x2F;String;)V<br>flags: ACC_PUBLIC, ACC_STATIC<br>Code:<br>stack&#x3D;2, locals&#x3D;4, args_size&#x3D;<br>0: bipush 10<br>2: istore_<br>3: ldc #3 &#x2F;&#x2F; int 32768<br>5: istore_<br>6: iload_<br>7: iload_<br>8: iadd<br>9: istore_<br>10: getstatic #4 &#x2F;&#x2F; Field<br>java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;<br>13: iload_<br>14: invokevirtual #5 &#x2F;&#x2F; Method<br>java&#x2F;io&#x2F;PrintStream.println:(I)V<br>17: return<br>LineNumberTable:<br>line 8: 0<br>line 9: 3</p><h4 id="3-）常量池载入运行时常量池"><a href="#3-）常量池载入运行时常量池" class="headerlink" title="3 ）常量池载入运行时常量池"></a>3 ）常量池载入运行时常量池</h4><h4 id="4-）方法字节码载入方法区"><a href="#4-）方法字节码载入方法区" class="headerlink" title="4 ）方法字节码载入方法区"></a>4 ）方法字节码载入方法区</h4><h4 id="5-）main-线程开始运行，分配栈帧内存"><a href="#5-）main-线程开始运行，分配栈帧内存" class="headerlink" title="5 ）main 线程开始运行，分配栈帧内存"></a>5 ）main 线程开始运行，分配栈帧内存</h4><p>（stack&#x3D;2，locals&#x3D;4）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">line 10: 6</span><br><span class="line">line 11: 10</span><br><span class="line">line 12: 17</span><br><span class="line">LocalVariableTable:</span><br><span class="line">Start Length Slot Name Signature</span><br><span class="line">0 18 0 args [Ljava/lang/String;</span><br><span class="line">3 15 1 a I</span><br><span class="line">6 12 2 b I</span><br><span class="line">10 8 3 c I</span><br><span class="line">MethodParameters:</span><br><span class="line">Name Flags</span><br><span class="line">args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-）执行引擎开始执行字节码"><a href="#6-）执行引擎开始执行字节码" class="headerlink" title="6 ）执行引擎开始执行字节码"></a>6 ）执行引擎开始执行字节码</h4><p>bipush 10</p><p>将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有</p><p>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</p><p>ldc 将一个 int 压入操作数栈</p><p>ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）</p><p>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</p><p>istore_</p><p>将操作数栈顶数据弹出，存入局部变量表的 slot 1</p><p>ldc</p><p>从常量池加载 #3 数据到操作数栈</p><p>注意 Short.MAX_VALUE 是 32767 ，所以 32768 &#x3D; Short.MAX_VALUE + 1 实际是在编译期间计算</p><p>好的</p><p>istore_</p><p>iload_1</p><p>iload_2</p><p>iadd</p><p> istore_3</p><p> getstatic #4</p><p>iload_3</p><p> invokevirtual #5</p><p> 找到常量池 #5 项</p><p> 定位到方法区 java&#x2F;io&#x2F;PrintStream.println:(I)V 方法</p><p> 生成新的栈帧（分配 locals、stack等）</p><p> 传递参数，执行新栈帧中的字节码</p><p> 执行完毕，弹出栈帧</p><p> 清除 main 操作数栈内容</p><p> return</p><p> 完成 main 方法调用，弹出 main 栈帧</p><p> 程序结束</p><h3 id="2-4-练习-分析-i"><a href="#2-4-练习-分析-i" class="headerlink" title="2.4 练习 - 分析 i++"></a>2.4 练习 - 分析 i++</h3><p> 目的：从字节码角度分析 a++ 相关题目</p><p> 源码：</p><p> 字节码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.jvm.t3.bytecode;</span><br><span class="line">/**</span><br><span class="line">* 从字节码角度分析 a++ 相关题目</span><br><span class="line">*/</span><br><span class="line">public class Demo3_2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int a = 10 ;</span><br><span class="line">int b = a++ + ++a + a--;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">descriptor: ([Ljava/lang/String;)V</span><br><span class="line">flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">stack=2, locals=3, args_size=1</span><br><span class="line">0: bipush 10</span><br><span class="line">2: istore_1</span><br><span class="line">3: iload_1</span><br><span class="line">4: iinc 1, 1</span><br><span class="line">7: iinc 1, 1</span><br><span class="line">10: iload_1</span><br><span class="line">11: iadd</span><br><span class="line">12: iload_1</span><br><span class="line">13: iinc 1, -1</span><br><span class="line">16: iadd</span><br><span class="line">17: istore_2</span><br></pre></td></tr></table></figure><p> 分析：</p><p> 注意 iinc 指令是直接在局部变量 slot 上进行运算</p><p> a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">18: getstatic #2 // Field</span><br><span class="line">java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">21: iload_1</span><br><span class="line">22: invokevirtual #3 // Method</span><br><span class="line">java/io/PrintStream.println:(I)V</span><br><span class="line">25: getstatic #2 // Field</span><br><span class="line">java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">28: iload_2</span><br><span class="line">29: invokevirtual #3 // Method</span><br><span class="line">java/io/PrintStream.println:(I)V</span><br><span class="line">32: return</span><br><span class="line">LineNumberTable:</span><br><span class="line">line 8: 0</span><br><span class="line">line 9: 3</span><br><span class="line">line 10: 18</span><br><span class="line">line 11: 25</span><br><span class="line">line 12: 32</span><br><span class="line">LocalVariableTable:</span><br><span class="line">Start Length Slot Name Signature</span><br><span class="line">0 33 0 args [Ljava/lang/String;</span><br><span class="line">3 30 1 a I</span><br><span class="line">18 15 2 b I</span><br></pre></td></tr></table></figure><h3 id="2-5-条件判断指令"><a href="#2-5-条件判断指令" class="headerlink" title="2.5 条件判断指令"></a>2.5 条件判断指令</h3><p> 指令 助记符 含义</p><p> 0x99 ifeq 判断是否 &#x3D;&#x3D; 0</p><p>0x9a ifne 判断是否 ！&#x3D; 0</p><p>0x9b iflt 判断是否 &lt; 0</p><p>0x9c ifge 判断是否 &gt;&#x3D; 0</p><p>0x9d ifgt 判断是否 &gt; 0</p><p>0x9e ifle 判断是否 &lt;&#x3D; 0</p><p>0x9f if_icmpeq 两个int是否 &#x3D;&#x3D;</p><p>0xa0 if_icmpne 两个int是否 ！&#x3D;</p><p>0xa1 if_icmplt 两个int是否 &lt;</p><p>0xa2 if_icmpge 两个int是否&gt;&#x3D;</p><p>0xa3 if_icmpgt 两个int是否&gt;</p><p>0xa4 if_icmple 两个int是否&lt;&#x3D;</p><p>0xa5 if_acmpeq 两个引用是否 &#x3D;&#x3D;</p><p>0xa6 if_acmpne 两个引用是否 ！&#x3D;</p><p>0xc6 ifnull 判断是否 &#x3D;&#x3D; null</p><p>0xc7 ifnonnull 判断是否 ！&#x3D; null</p><p>几点说明：</p><p>byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节</p><p>goto 用来进行跳转到指定行号的字节码</p><p>源码：</p><p>字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3_3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span> ) &#123;</span><br><span class="line">a = <span class="number">10</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">a = <span class="number">20</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考</p><p>细心的同学应当注意到，以上比较指令中没有 long，float，double 的比较，那么它们要比较怎</p><p>么办？</p><p>参考 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp</a></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918103529201.png" alt="image-20220918103529201"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918103753258.png" alt="image-20220918103753258"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918104707749.png" alt="image-20220918104707749"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918104951679.png" alt="image-20220918104951679"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918105241895.png" alt="image-20220918105241895"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918110023747.png" alt="image-20220918110023747"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918112619676.png" alt="image-20220918112619676"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918113007437.png" alt="image-20220918113007437"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918113044757.png" alt="image-20220918113044757"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918113107342.png" alt="image-20220918113107342"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918113143812.png" alt="image-20220918113143812"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918113827109.png" alt="image-20220918113827109"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918114223826.png" alt="image-20220918114223826"></p><p> <img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918114236000.png" alt="image-20220918114236000"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918114249488.png" alt="image-20220918114249488"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918114333971.png" alt="image-20220918114333971"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918114346565.png" alt="image-20220918114346565"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918114356723.png" alt="image-20220918114356723"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918114420583.png" alt="image-20220918114420583"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918114437030.png" alt="image-20220918114437030"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918114451496.png" alt="image-20220918114451496"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918114503775.png" alt="image-20220918114503775"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918114531832.png" alt="image-20220918114531832"></p><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220918114611352.png" alt="image-20220918114611352"></p>]]></content:encoded>
      
      
      <category domain="https://HoldusTogether.github.io/categories/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/categories/Java/JVM/">JVM</category>
      
      
      <category domain="https://HoldusTogether.github.io/tags/Java/">Java</category>
      
      <category domain="https://HoldusTogether.github.io/tags/JVM/">JVM</category>
      
      
      <comments>https://holdustogether.github.io/2022/08/22/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
