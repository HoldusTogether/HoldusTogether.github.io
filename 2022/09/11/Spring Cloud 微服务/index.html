<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"holdustogether.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="常见面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Cloud">
<meta property="og:url" content="https://holdustogether.github.io/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/index.html">
<meta property="og:site_name" content="南北橘子">
<meta property="og:description" content="常见面试题">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://holdustogether.github.io/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220912173002658.png">
<meta property="og:image" content="https://holdustogether.github.io/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220912173236315.png">
<meta property="og:image" content="https://holdustogether.github.io/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220913113408462.png">
<meta property="og:image" content="https://holdustogether.github.io/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220913113956551.png">
<meta property="article:published_time" content="2022-09-11T02:36:21.202Z">
<meta property="article:modified_time" content="2022-09-21T02:32:24.502Z">
<meta property="article:author" content="wFei">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring Cloud">
<meta property="article:tag" content="微服务">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://holdustogether.github.io/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220912173002658.png">

<link rel="canonical" href="https://holdustogether.github.io/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Spring Cloud | 南北橘子</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="南北橘子" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a target="_blank" rel="noopener" href="https://github.com/holdustogether" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">南北橘子</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://holdustogether.github.io/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="wFei">
      <meta itemprop="description" content="不要停止成为更好的自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="南北橘子">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring Cloud
        </h1>

        <div class="post-meta">
	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-11 10:36:21" itemprop="dateCreated datePublished" datetime="2022-09-11T10:36:21+08:00">2022-09-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-21 10:32:24" itemprop="dateModified" datetime="2022-09-21T10:32:24+08:00">2022-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Spring-Cloud/" itemprop="url" rel="index"><span itemprop="name">Spring Cloud</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><span id="more"></span>

<h3 id="1-1-什么是微服务？"><a href="#1-1-什么是微服务？" class="headerlink" title="1.1 什么是微服务？"></a>1.1 什么是微服务？</h3><blockquote>
<p>对于微服务，业界并没有一个统一的，标准的定义。</p>
<p>微服务架构是一种架构模式，或者说是一种架构风格，将单一的应用程序划分成一组小的服务，每个服务运行在其独立的自己的进程内，服务之间采用轻量级的通信机制（HTTP）相互沟通，互相协调，为用户提供价值。</p>
<p>微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情。</p>
</blockquote>
<h3 id="2-2-微服务与微服务架构"><a href="#2-2-微服务与微服务架构" class="headerlink" title="2.2 微服务与微服务架构"></a>2.2 微服务与微服务架构</h3><blockquote>
<p>微服务</p>
<p>强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题&#x2F;提供落地对应服务的一个服务应用，狭义的看，可以看作是IDEA中的一个个微服务工程，或者Moudel。强调的是一个个的个体，每个个体完成一个具体的任务或者功能。</p>
<p>微服务架构</p>
<p>一种新的架构形式，Martin Fowler 于2014年提出。</p>
<p>微服务架构是一种架构模式，它体长将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。</p>
</blockquote>
<h3 id="2-3-微服务优缺点"><a href="#2-3-微服务优缺点" class="headerlink" title="2.3 微服务优缺点"></a>2.3 微服务优缺点</h3><blockquote>
<p>优点：</p>
<ul>
<li>单一职责</li>
<li>每个服务足够小，足够内聚，处理指定的业务功能</li>
<li>开发简单效率高</li>
<li>松耦合</li>
<li><strong>每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库；</strong></li>
</ul>
<p>缺点：</p>
<ul>
<li>开发人员要处理分布式系统的复杂性；</li>
<li>系统部署依赖问题；</li>
<li>服务间通信成本问题；</li>
<li>数据一致性问题；</li>
</ul>
</blockquote>
<h2 id="Eureka-Spring-Cloud服务注册与发现组件"><a href="#Eureka-Spring-Cloud服务注册与发现组件" class="headerlink" title="Eureka Spring Cloud服务注册与发现组件"></a>Eureka Spring Cloud服务注册与发现组件</h2><h3 id="1-Eureka-两大组件"><a href="#1-Eureka-两大组件" class="headerlink" title="1.Eureka 两大组件"></a>1.Eureka 两大组件</h3><p>​	<strong>CS架构</strong></p>
<ul>
<li><strong>Eureka Server</strong>：Eureka 服务注册中心，主要用于提供服务注册功能。当微服务启动时，会将自己的服务注册到 Eureka Server。Eureka Server 维护了一个可用服务列表，存储了所有注册到 Eureka Server 的可用服务的信息，这些可用服务可以在 Eureka Server 的管理界面中直观看到。</li>
<li><strong>Eureka Client</strong>：Eureka 客户端，通常指的是微服务系统中各个微服务，主要用于和 Eureka Server 进行交互。在微服务应用启动后，Eureka Client 会向 Eureka Server 发送心跳（默认周期为 30 秒）。若 Eureka Server 在多个心跳周期内没有接收到某个 Eureka Client 的心跳，Eureka Server 将它从可用服务列表中移除（默认 90 秒）。 </li>
<li>![image-20220911120302056](Spring Cloud 微服务.assets&#x2F;image-20220911120302056.png)</li>
</ul>
<hr>
<ol>
<li><p>服务端导包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--为服务注册中心引入 Eureka Server 的依赖--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>服务端配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span>  <span class="comment">#该 Module 的端口号</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment">#eureka服务端的实例名称，</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#false表示不向注册中心注册自己。</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span> <span class="comment">#单机版服务注册中心</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>主类加注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">//开启 Eureka server,接受其他微服务的注册</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudEureka7001Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudEureka7001Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol>
<li><p>服务提供端导包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入 Eureka Client 的依赖，将服务注册到 Eureka Server--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>服务提供端配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span> <span class="comment">#服务端口号</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">microServiceCloudProviderDept</span>  <span class="comment">#微服务名称，对外暴漏的微服务名称，十分重要</span></span><br><span class="line"><span class="comment">################################################## JDBC 通用配置  ##########################################</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span>        <span class="comment">#数据库登陆用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span>        <span class="comment">#数据库登陆密码</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/bianchengbang_jdbc</span>       <span class="comment">#数据库url</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span>                  <span class="comment">#数据库驱动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################### 不检查 spring.config.import=configserver:##################</span></span><br><span class="line"><span class="comment">#  cloud:</span></span><br><span class="line"><span class="comment">#    config:</span></span><br><span class="line"><span class="comment">#      enabled: false</span></span><br><span class="line"><span class="comment">###################################### MyBatis 配置 ######################################</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment"># 指定 mapper.xml 的位置</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span></span><br><span class="line">  <span class="comment">#扫描实体类的位置,在此处指明扫描实体类的包，在 mapper.xml 中就可以不写实体类的全路径名</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">net.biancheng.c.entity</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#默认开启驼峰命名法，可以不用设置该属性</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">########################################### Spring cloud 自定义服务名称和 ip 地址###############################################</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#将客户端注册到 eureka 服务列表内</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span>  <span class="comment">#这个地址是 7001注册中心在 application.yml 中暴露出来额注册地址 （单机版）</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">spring-cloud-provider-8001</span> <span class="comment">#自定义服务名称信息</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>  <span class="comment">#显示访问路径的 ip 地址</span></span><br><span class="line"><span class="comment">########################################## spring cloud 使用 Spring Boot actuator 监控完善信息###################################</span></span><br><span class="line"><span class="comment"># Spring Boot 2.50对 actuator 监控屏蔽了大多数的节点，只暴露了 heath 节点，本段配置（*）就是为了开启所有的节点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span>   <span class="comment"># * 在yaml 文件属于关键字，所以需要加引号</span></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app.name:</span> <span class="string">micro-service-cloud-provider-dept</span></span><br><span class="line">  <span class="attr">company.name:</span> <span class="string">c.biancheng.net</span></span><br><span class="line">  <span class="attr">build.aetifactId:</span> <span class="string">@project.artifactId@</span></span><br><span class="line">  <span class="attr">build.version:</span> <span class="string">@project.version@</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>服务端启动类注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">// Spring cloud Eureka 客户端，自动将本服务注册到 Eureka Server 注册中心中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudProviderDept8001Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudProviderDept8001Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="2-Eureka-Server-集群"><a href="#2-Eureka-Server-集群" class="headerlink" title="2.Eureka Server 集群"></a>2.Eureka Server 集群</h3><blockquote>
<p>在微服务架构中，一个系统往往由十几甚至几十个服务组成，若将这些服务全部注册到同一个 Eureka Server 中，就极有可能导致 Eureka Server 因不堪重负而崩溃，最终导致整个系统瘫痪。解决这个问题最直接的办法就是部署 Eureka Server 集群。 保证高可用</p>
<p>我们知道，在 Eureka 实现服务注册与发现时一共涉及了 3 个角色：服务注册中心、服务提供者以及服务消费者，这三个角色分工明确，各司其职。但是其实在 Eureka 中，所有服务都既是服务消费者也是服务提供者，服务注册中心 Eureka Server 也不例外。</p>
<p>举个例子，有两个 Eureka Server 分别为 A 和 B，虽然 A 不能将自己注册到 A 上，B 也不能将自己注册到 B 上，但 A 是可以作为一个服务把自己注册到 B 上的，同理 B 也可以将自己注册到 A 上。</p>
<p>这样就可以形成一组互相注册的 Eureka Server 集群，当服务提供者发送注册请求到 Eureka Server 时，Eureka Server 会将请求转发给集群中所有与之相连的 Eureka Server 上，以实现 Eureka Server 之间的服务同步。</p>
<p>通过服务同步，服务消费者可以在集群中的任意一台 Eureka Server 上获取服务提供者提供的服务。这样，即使集群中的某个服务注册中心发生故障，服务消费者仍然可以从集群中的其他 Eureka Server 中获取服务信息并调用，而不会导致系统的整体瘫痪，这就是 Eureka Server 集群的高可用性。</p>
</blockquote>
<hr>
<h3 id="3-Eureka-自我保护机制"><a href="#3-Eureka-自我保护机制" class="headerlink" title="3.Eureka 自我保护机制"></a>3.Eureka 自我保护机制</h3><blockquote>
<p>实际上，这个警告是触发了 Eureka 的自我保护机制而出现的。默认情况下，如果 Eureka Server 在一段时间内（默认为 90 秒）没有接收到某个服务提供者（Eureka Client）的心跳，就会将这个服务提供者提供的服务从服务注册表中移除。 这样服务消费者就再也无法从服务注册中心中获取到这个服务了，更无法调用该服务。</p>
<p>但在实际的分布式微服务系统中，健康的服务（Eureka Client）也有可能会由于网络故障（例如网络延迟、卡顿、拥挤等原因）而无法与 Eureka Server 正常通讯。若此时 Eureka Server 因为没有接收心跳而误将健康的服务从服务列表中移除，这显然是不合理的。而 Eureka 的自我保护机制就是来解决此问题的。</p>
<p>所谓 “Eureka 的自我保护机制”，其中心思想就是“好死不如赖活着”。如果 Eureka Server 在一段时间内没有接收到 Eureka Client 的心跳，那么 Eureka Server 就会开启自我保护模式，将所有的 Eureka Client 的注册信息保护起来，而不是直接从服务注册表中移除。一旦网络恢复，这些 Eureka Client 提供的服务还可以继续被服务消费者消费。</p>
<p>综上，Eureka 的自我保护机制是一种应对网络异常的安全保护措施。它的架构哲学是：宁可同时保留所有微服务（健康的服务和不健康的服务都会保留）也不盲目移除任何健康的服务。通过 Eureka 的自我保护机制，可以让 Eureka Server 集群更加的健壮、稳定。</p>
<p>Eureka 的自我保护机制也存在弊端。如果在 Eureka 自我保护机制触发期间，服务提供者提供的服务出现问题，那么服务消费者就很容易获取到已经不存在的服务进而出现调用失败的情况，此时，我们可以通过客户端的容错机制来解决此问题，详情请参考 <a target="_blank" rel="noopener" href="http://c.biancheng.net/springcloud/ribbon.html">Spring Cloud Netflix Ribbon</a> 和 <a target="_blank" rel="noopener" href="http://c.biancheng.net/springcloud/hystrix.html">Spring Cloud Netflix Hystrix</a>。</p>
</blockquote>
<h2 id="Ribbon：Spring-Cloud负载均衡与服务调用组件"><a href="#Ribbon：Spring-Cloud负载均衡与服务调用组件" class="headerlink" title="Ribbon：Spring Cloud负载均衡与服务调用组件"></a>Ribbon：Spring Cloud负载均衡与服务调用组件</h2><h3 id="1-什么是Ribbon"><a href="#1-什么是Ribbon" class="headerlink" title="1. 什么是Ribbon"></a>1. 什么是Ribbon</h3><pre><code>&gt; Ribbon 是 Spring Cloud Netflix 模块的子模块，它是 Spring Cloud 对 Netflix Ribbon 的二次封装。通过它，我们可以将面向服务的 REST 模板（RestTemplate）请求转换为客户端负载均衡的服务调用。
&gt;
&gt; Ribbon 是 Spring Cloud 体系中最核心、最重要的组件之一。它虽然只是一个工具类型的框架，并不像 Eureka Server（服务注册中心）那样需要独立部署，但它几乎存在于每一个使用 Spring Cloud 构建的微服务中。
&gt;
&gt; Spring Cloud 微服务之间的调用，API 网关的请求转发等内容，实际上都是通过 Spring Cloud Ribbon 来实现的，包括后续我们要介绍的 [OpenFeign](http://c.biancheng.net/springcloud/open-feign.html) 也是基于它实现的。
</code></pre>
<h3 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2.负载均衡"></a>2.负载均衡</h3><blockquote>
<p>负载均衡（Load Balance） ，简单点说就是将用户的请求平摊分配到多个服务器上运行，以达到扩展服务器带宽、增强数据处理能力、增加吞吐量、提高网络的可用性和灵活性的目的。</p>
</blockquote>
<p>常见的负载均衡方式: (其实就是判断在客户端发送请求前负载均衡还是后负载均衡)</p>
<ul>
<li>服务端负载均衡(服务端负责均衡就是客户端发送请求后进行的)</li>
<li>客户端负载均衡(就是客户端发送请求前进行负载均衡)</li>
</ul>
<h4 id="服务端负载均衡"><a href="#服务端负载均衡" class="headerlink" title="服务端负载均衡"></a>服务端负载均衡</h4><p>![image-20220911160533799](Spring Cloud 微服务.assets&#x2F;image-20220911160533799.png)</p>
<p>服务端负载均衡是在客户端和服务端之间建立一个独立的负载均衡服务器，该服务器既可以是硬件设备（例如 F5），也可以是软件（例如 Nginx）。这个负载均衡服务器维护了一份可用服务端清单，然后通过心跳机制来删除故障的服务端节点，以保证清单中的所有服务节点都是可以正常访问的。</p>
<p>当客户端发送请求时，该请求不会直接发送到服务端进行处理，而是全部交给负载均衡服务器，由负载均衡服务器按照某种算法（例如轮询、随机等），从其维护的可用服务清单中选择一个服务端，然后进行转发。</p>
<p>服务端负载均衡具有以下特点：</p>
<ul>
<li>需要建立一个独立的负载均衡服务器。</li>
<li>负载均衡是在客户端发送请求后进行的，因此客户端并不知道到底是哪个服务端提供的服务。</li>
<li>可用服务端清单存储在负载均衡服务器上。</li>
</ul>
<h4 id="客户端负载均衡"><a href="#客户端负载均衡" class="headerlink" title="客户端负载均衡"></a>客户端负载均衡</h4><p>![image-20220911160747167](Spring Cloud 微服务.assets&#x2F;image-20220911160747167.png)</p>
<p>客户端负载均衡是将负载均衡逻辑以代码的形式封装到客户端上，即负载均衡器位于客户端。客户端通过服务注册中心（例如 Eureka Server）获取到一份服务端提供的可用服务清单。有了服务清单后，负载均衡器会在客户端发送请求前通过负载均衡算法选择一个服务端实例再进行访问，以达到负载均衡的目的；</p>
<p>客户端负载均衡也需要心跳机制去维护服务端清单的有效性，这个过程需要配合服务注册中心一起完成。</p>
<p>客户端负载均衡具有以下特点：</p>
<ul>
<li>负载均衡器位于客户端，不需要单独搭建一个负载均衡服务器。</li>
<li>负载均衡是在客户端发送请求前进行的，因此客户端清楚地知道是哪个服务端提供的服务。</li>
<li>客户端都维护了一份可用服务清单，而这份清单都是从服务注册中心获取的。</li>
</ul>
<p>Ribbon 就是一个基于 HTTP 和 TCP 的客户端负载均衡器，当我们将 Ribbon 和 Eureka 一起使用时，Ribbon 会从 Eureka Server（服务注册中心）中获取服务端列表，然后通过负载均衡策略将请求分摊给多个服务提供者，从而达到负载均衡的目的。</p>
<h4 id="服务端负载均衡-VS-客户端负载均衡"><a href="#服务端负载均衡-VS-客户端负载均衡" class="headerlink" title="服务端负载均衡 VS 客户端负载均衡"></a>服务端负载均衡 VS 客户端负载均衡</h4><table>
<thead>
<tr>
<th>不同点</th>
<th>服务端负载均衡</th>
<th>客户端负载均衡</th>
</tr>
</thead>
<tbody><tr>
<td>是否需要建立负载均衡服务器</td>
<td>需要在客户端和服务端之间建立一个独立的负载均衡服务器。</td>
<td>将负载均衡的逻辑以代码的形式封装到客户端上，因此不需要单独建立负载均衡服务器。</td>
</tr>
<tr>
<td>是否需要服务注册中心</td>
<td>不需要服务注册中心。</td>
<td>需要服务注册中心。  在客户端负载均衡中，所有的客户端和服务端都需要将其提供的服务注册到服务注册中心上。</td>
</tr>
<tr>
<td>可用服务清单存储的位置</td>
<td>可用服务清单存储在位于客户端与服务器之间的负载均衡服务器上。</td>
<td>所有的客户端都维护了一份可用服务清单，这些清单都是从服务注册中心获取的。</td>
</tr>
<tr>
<td>负载均衡的时机</td>
<td>先将请求发送到负载均衡服务器，然后由负载均衡服务器通过负载均衡算法，在多个服务端之间选择一个进行访问；即在服务器端再进行负载均衡算法分配。  简单点说就是，先发送请求，再进行负载均衡。</td>
<td>在发送请求前，由位于客户端的服务负载均衡器（例如 Ribbon）通过负载均衡算法选择一个服务器，然后进行访问。  简单点说就是，先进行负载均衡，再发送请求。</td>
</tr>
<tr>
<td>客户端是否了解服务提供方信息</td>
<td>由于负载均衡是在客户端发送请求后进行的，因此客户端并不知道到底是哪个服务端提供的服务。</td>
<td>负载均衡是在客户端发送请求前进行的，因此客户端清楚的知道是哪个服务端提供的服务。</td>
</tr>
</tbody></table>
<h3 id="3-Ribbon-实现服务调用"><a href="#3-Ribbon-实现服务调用" class="headerlink" title="3.Ribbon 实现服务调用"></a>3.Ribbon 实现服务调用</h3><p>Ribbon 可以与 RestTemplate（Rest 模板）配合使用，以实现微服务之间的调用。</p>
<p>RestTemplate 是 Spring 家族中的一个用于消费第三方 REST 服务的请求框架。RestTemplate 实现了对 HTTP 请求的封装，提供了一套模板化的服务调用方法。通过它，Spring 应用可以很方便地对各种类型的 HTTP 请求进行访问。</p>
<p>RestTemplate 针对各种类型的 HTTP 请求都提供了相应的方法进行处理，例如 HEAD、GET、POST、PUT、DELETE 等类型的 HTTP 请求，分别对应 RestTemplate 中的 headForHeaders()、getForObject()、postForObject()、put() 以及 delete() 方法。</p>
<ol>
<li><p>导包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring Cloud Eureka 客户端依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Spring Cloud Ribbon 依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line"><span class="comment">############################################# Spring Cloud Ribbon 负载均衡配置##########################</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#本微服务为服务消费者，不需要将自己注册到服务注册中心</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span>  <span class="comment">#本微服务为服务消费者，需要到服务注册中心搜索服务</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span> <span class="comment">#服务注册中心集群</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>创建配置类,注入RestTemplate</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置类注解</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigBean</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//将 RestTemplate 注入到容器中</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">//在客户端使用 RestTemplate 请求服务端时，开启负载均衡（Ribbon）</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>调用服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptController_Consumer</span> &#123;</span><br><span class="line">    <span class="comment">//private static final String REST_URL_PROVIDER_PREFIX = &quot;http://localhost:8001/&quot;; 这种方式是直调用服务方的方法，根本没有用到 Spring Cloud</span></span><br><span class="line">    <span class="comment">//面向微服务编程，即通过微服务的名称来获取调用地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REST_URL_PROVIDER_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;http://MICROSERVICECLOUDPROVIDERDEPT&quot;</span>; <span class="comment">// 使用注册到 Spring Cloud Eureka 服务注册中心中的服务，即 application.name</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate; <span class="comment">//RestTemplate 是一种简单便捷的访问 restful 服务模板类，是 Spring 提供的用于访问 Rest 服务的客户端模板工具集，提供了多种便捷访问远程 HTTP 服务的方法</span></span><br><span class="line">    <span class="comment">//获取指定部门信息</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/consumer/dept/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(REST_URL_PROVIDER_PREFIX + <span class="string">&quot;/dept/get/&quot;</span> + id, Dept.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取部门列表</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/consumer/dept/list&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Dept&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(REST_URL_PROVIDER_PREFIX + <span class="string">&quot;/dept/list&quot;</span>, List.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>主启动类上加注解  @EnableEurekaClient 注解来开启 Eureka 客户端功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudConsumerDept80Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudConsumerDept80Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-Ribbon-实现负载均衡"><a href="#4-Ribbon-实现负载均衡" class="headerlink" title="4.Ribbon 实现负载均衡"></a>4.Ribbon 实现负载均衡</h3><p><strong>Ribbon 是一个客户端的负载均衡器，它可以与 Eureka 配合使用轻松地实现客户端的负载均衡。Ribbon 会先从 Eureka Server（服务注册中心）去获取服务端列表，然后通过负载均衡策略将请求分摊给多个服务端，从而达到负载均衡的目的。</strong></p>
<p>Spring Cloud Ribbon 提供了一个 <strong>IRule 接口</strong>，该接口主要用来定义负载均衡策略，它有 7 个默认实现类，每一个实现类都是一种负载均衡策略。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>实现类</th>
<th>负载均衡策略</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>RoundRobinRule</td>
<td>按照线性轮询策略，即按照一定的顺序依次选取服务实例</td>
</tr>
<tr>
<td>2</td>
<td>RandomRule</td>
<td>随机选取一个服务实例</td>
</tr>
<tr>
<td>3</td>
<td>RetryRule</td>
<td>按照 RoundRobinRule（轮询）的策略来获取服务，如果获取的服务实例为 null 或已经失效，则在指定的时间之内不断地进行重试（重试时获取服务的策略还是 RoundRobinRule 中定义的策略），如果超过指定时间依然没获取到服务实例则返回 null 。</td>
</tr>
<tr>
<td>4</td>
<td>WeightedResponseTimeRule</td>
<td>WeightedResponseTimeRule 是 RoundRobinRule 的一个子类，它对 RoundRobinRule 的功能进行了扩展。  根据平均响应时间，来计算所有服务实例的权重，响应时间越短的服务实例权重越高，被选中的概率越大。刚启动时，如果统计信息不足，则使用线性轮询策略，等信息足够时，再切换到 WeightedResponseTimeRule。</td>
</tr>
<tr>
<td>5</td>
<td>BestAvailableRule</td>
<td>继承自 ClientConfigEnabledRoundRobinRule。先过滤点故障或失效的服务实例，然后再选择并发量最小的服务实例。</td>
</tr>
<tr>
<td>6</td>
<td>AvailabilityFilteringRule</td>
<td>先过滤掉故障或失效的服务实例，然后再选择并发量较小的服务实例。</td>
</tr>
<tr>
<td>7</td>
<td>ZoneAvoidanceRule</td>
<td>默认的负载均衡策略，综合判断服务所在区域（zone）的性能和服务（server）的可用性，来选择服务实例。在没有区域的环境下，该策略与轮询（RandomRule）策略类似。</td>
</tr>
</tbody></table>
<p>其实可以分为三大类:</p>
<ul>
<li><p>轮询类:</p>
<ul>
<li>RoundRobinRule 线性轮询<ul>
<li>RetryRule 重试轮询,对null或已失效规定时间内多次重试,最后失败返回null</li>
<li>WeightedResponseTimeRule 权重轮询 根据平均响应时间来建立权重,时间短的权重大,被选中的几率也大. 刚启动的时候如果信息不足就会先使用轮询,等到信息足够就切换到权重轮询</li>
<li>ZoneAvoidanceRule 没有区域的时候与轮询策略类似 默认的策略 会根据区域进行性能分析,服务可用性分析结果来调用</li>
</ul>
</li>
</ul>
</li>
<li><p>随机类:</p>
<ul>
<li>RandomRule 随机选一个服务</li>
</ul>
</li>
<li><p>过滤并发类:</p>
<ul>
<li>BestAvailableRule 先过滤掉故障或失效的服务实例，然后再选择并发量最小的服务实例。继承自ClientConfigEnabledRoundRobinRule。</li>
<li>AvailabilityFilteringRule 先过滤掉故障或失效的服务实例，然后再选择并发量较小的服务实例。</li>
</ul>
</li>
</ul>
<h3 id="5-切换负载均衡策略"><a href="#5-切换负载均衡策略" class="headerlink" title="5.切换负载均衡策略"></a>5.切换负载均衡策略</h3><p>Spring Cloud Ribbon 默认使用轮询策略选取服务实例，我们也可以根据自身的需求切换负载均衡策略。</p>
<p>切换负载均衡策略的方法很简单，我们只需要在服务消费者（客户端）的配置类中，将 IRule 的其他实现类注入到容器中即可。</p>
<p>配置类 ConfigBean 中添加以下代码，将负载均衡策略切换为 RandomRule（随机）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">myRule</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// RandomRule 为随机策略</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-定制负载均衡策略"><a href="#6-定制负载均衡策略" class="headerlink" title="6.定制负载均衡策略"></a>6.定制负载均衡策略</h3><p>1.创建负载均衡策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定制 Ribbon 负载均衡策略</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRandomRule</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalancerRule</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;            <span class="comment">// 总共被调用的次数，目前要求每台被调用5次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentIndex</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 当前提供服务的机器号</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lb == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取所有有效的服务实例列表</span></span><br><span class="line">            List&lt;Server&gt; upList = lb.getReachableServers();</span><br><span class="line">            <span class="comment">//获取所有的服务实例的列表</span></span><br><span class="line">            List&lt;Server&gt; allList = lb.getAllServers();</span><br><span class="line">            <span class="comment">//如果没有任何的服务实例则返回 null</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">serverCount</span> <span class="operator">=</span> allList.size();</span><br><span class="line">            <span class="keyword">if</span> (serverCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//与随机策略相似，但每个服务实例只有在调用 3 次之后，才会调用其他的服务实例</span></span><br><span class="line">            <span class="keyword">if</span> (total &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                server = upList.get(currentIndex);</span><br><span class="line">                total++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                total = <span class="number">0</span>;</span><br><span class="line">                currentIndex++;</span><br><span class="line">                <span class="keyword">if</span> (currentIndex &gt;= upList.size()) &#123;</span><br><span class="line">                    currentIndex = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (server.isAlive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> (server);</span><br><span class="line">            &#125;</span><br><span class="line">            server = <span class="literal">null</span>;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> choose(getLoadBalancer(), key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建一个名为 MySelfRibbonRuleConfig 的配置类，将我们定制的负载均衡策略实现类注入到容器中，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定制 Ribbon 负载均衡策略的配置类</span></span><br><span class="line"><span class="comment">* 该自定义 Ribbon 负载均衡策略配置类 不能在 net.biancheng.c 包及其子包下</span></span><br><span class="line"><span class="comment">* 否则所有的 Ribbon 客户端都会采用该策略，无法达到特殊化定制的目的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySelfRibbonRuleConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">myRule</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//自定义 Ribbon 负载均衡策略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyRandomRule</span>(); <span class="comment">//自定义，随机选择某一个微服务，执行五次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.主启动类上加注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//自定义 Ribbon 负载均衡策略在主启动类上使用 RibbonClient 注解，在该微服务启动时，就能自动去加载我们自定义的 Ribbon 配置类，从而是配置生效</span></span><br><span class="line"><span class="comment">// name 为需要定制负载均衡策略的微服务名称（application name）</span></span><br><span class="line"><span class="comment">// configuration 为定制的负载均衡策略的配置类，</span></span><br><span class="line"><span class="comment">// 且官方文档中明确提出，该配置类不能在 ComponentScan 注解（SpringBootApplication 注解中包含了该注解）下的包或其子包中，即自定义负载均衡配置类不能在 net.biancheng.c 包及其子包下</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;MICROSERVICECLOUDPROVIDERDEPT&quot;, configuration = MySelfRibbonRuleConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudConsumerDept80Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudConsumerDept80Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OpenFeign：Spring-Cloud声明式服务调用组件"><a href="#OpenFeign：Spring-Cloud声明式服务调用组件" class="headerlink" title="OpenFeign：Spring Cloud声明式服务调用组件"></a>OpenFeign：Spring Cloud声明式服务调用组件</h2><h3 id="1-什么是OpenFeign"><a href="#1-什么是OpenFeign" class="headerlink" title="1.什么是OpenFeign"></a>1.什么是OpenFeign</h3><blockquote>
<p>Feign 对 <a target="_blank" rel="noopener" href="http://c.biancheng.net/springcloud/ribbon.html">Ribbon</a> 进行了集成，利用 Ribbon 维护了一份可用服务清单，并通过 Ribbon 实现了客户端的负载均衡。</p>
<p>Feign 是一种声明式服务调用组件，它在 RestTemplate 的基础上做了进一步的封装。通过 Feign，我们只需要声明一个接口并通过注解进行简单的配置（类似于 Dao 接口上面的 Mapper 注解一样）即可实现对 HTTP 接口的绑定。</p>
<p>通过 Feign，我们可以像调用本地方法一样来调用远程服务，而完全感觉不到这是在进行远程调用。</p>
<p>Feign 支持多种注解，例如 Feign 自带的注解以及 JAX-RS 注解等，但遗憾的是 Feign 本身并不支持 Spring MVC 注解，这无疑会给广大 Spring 用户带来不便。</p>
<p>OpenFeign 全称 Spring Cloud OpenFeign，它是 Spring 官方推出的一种声明式服务调用与负载均衡组件，它的出现就是为了替代进入停更维护状态的 Feign。</p>
<p>OpenFeign 是 Spring Cloud 对 Feign 的二次封装，它具有 Feign 的所有功能，并在 Feign 的基础上增加了对 Spring MVC 注解的支持，例如 @RequestMapping、@GetMapping 和 @PostMapping 等。</p>
</blockquote>
<h3 id="2-OpenFeign-常用注解"><a href="#2-OpenFeign-常用注解" class="headerlink" title="2.OpenFeign 常用注解"></a>2.OpenFeign 常用注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@FeignClient</td>
<td>该注解用于通知 OpenFeign 组件对 @RequestMapping 注解下的接口进行解析，并通过动态代理的方式产生实现类，实现负载均衡和服务调用。</td>
</tr>
<tr>
<td>@EnableFeignClients</td>
<td>该注解用于开启 OpenFeign 功能，当 Spring Cloud 应用启动时，OpenFeign 会扫描标有 @FeignClient 注解的接口，生成代理并注册到 Spring 容器中。</td>
</tr>
<tr>
<td>@RequestMapping</td>
<td>Spring MVC 注解，在 Spring MVC 中使用该注解映射请求，通过它来指定控制器（Controller）可以处理哪些 URL 请求，相当于 Servlet 中 web.xml 的配置。</td>
</tr>
<tr>
<td>@GetMapping</td>
<td>Spring MVC 注解，用来映射 GET 请求，它是一个组合注解，相当于 @RequestMapping(method &#x3D; RequestMethod.GET) 。</td>
</tr>
<tr>
<td>@PostMapping</td>
<td>Spring MVC 注解，用来映射 POST 请求，它是一个组合注解，相当于 @RequestMapping(method &#x3D; RequestMethod.POST) 。</td>
</tr>
</tbody></table>
<h3 id="3-Feign-VS-OpenFeign"><a href="#3-Feign-VS-OpenFeign" class="headerlink" title="3.Feign VS OpenFeign"></a>3.Feign VS OpenFeign</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>Feign 和 OpenFegin 具有以下相同点：</p>
<ul>
<li>Feign 和 OpenFeign 都是 Spring Cloud 下的远程调用和负载均衡组件。</li>
<li>Feign 和 OpenFeign 作用一样，都可以实现服务的远程调用和负载均衡。</li>
<li>Feign 和 OpenFeign 都对 Ribbon 进行了集成，都利用 Ribbon 维护了可用服务清单，并通过 Ribbon 实现了客户端的负载均衡。</li>
<li>Feign 和 OpenFeign 都是在服务消费者（客户端）定义服务绑定接口并通过注解的方式进行配置，以实现远程服务的调用。</li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>Feign 和 OpenFeign 具有以下不同：</p>
<ul>
<li>Feign 和 OpenFeign 的依赖项不同，Feign 的依赖为 spring-cloud-starter-feign，而 OpenFeign 的依赖为 spring-cloud-starter-openfeign。</li>
<li>Feign 和 OpenFeign 支持的注解不同，Feign 支持 Feign 注解和 JAX-RS 注解，但不支持 Spring MVC 注解；OpenFeign 除了支持 Feign 注解和 JAX-RS 注解外，还支持 Spring MVC 注解。</li>
</ul>
<h3 id="4-OpenFeign-实现远程服务调用"><a href="#4-OpenFeign-实现远程服务调用" class="headerlink" title="4.OpenFeign 实现远程服务调用"></a>4.OpenFeign 实现远程服务调用</h3><p>1.导包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Eureka Client 依赖--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Ribbon 依赖--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--添加 OpenFeign 依赖--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#服务消费者可以不向服务注册中心注册服务</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span>  <span class="comment">#服务消费者客户端需要去检索服务</span></span><br></pre></td></tr></table></figure>

<p>3.创建一个名为 DeptFeignService 的接口，并在该接口上使用 @FeignClient 注解实现对服务接口的绑定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加为容器内的一个组件</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 服务提供者提供的服务名称，即 application.name</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;MICROSERVICECLOUDPROVIDERDEPT&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptFeignService</span> &#123;</span><br><span class="line">    <span class="comment">//对应服务提供者（8001、8002、8003）Controller 中定义的方法</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/dept/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/dept/list&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Dept&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编写服务绑定接口时，需要注意以下 2 点：</p>
<ul>
<li>在 @FeignClient 注解中，value 属性的取值为：服务提供者的服务名，即服务提供者配置文件（application.yml）中 spring.application.name 的取值。</li>
<li>接口中定义的每个方法都与服务提供者（即 micro-service-cloud-provider-dept-8001 等）中 Controller 定义的服务方法对应。</li>
</ul>
<p>4.在主启动类上添加 @EnableFeignClients 注解开启 OpenFeign 功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">//开启 OpenFeign 功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudConsumerDeptFeignApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudConsumerDeptFeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pring Cloud 应用在启动时，OpenFeign 会扫描标有 @FeignClient 注解的接口生成代理，并注人到 Spring 容器中。</p>
<h3 id="5-OpenFeign-超时控制"><a href="#5-OpenFeign-超时控制" class="headerlink" title="5.OpenFeign 超时控制"></a>5.OpenFeign 超时控制</h3><p>OpenFeign 客户端的默认超时时间为 1 秒钟，如果服务端处理请求的时间超过 1 秒就会报错。为了避免这样的情况，我们需要对 OpenFeign 客户端的超时时间进行控制。</p>
<p><strong>application.yml 中添加以下配置，将超时时间设置为 6 秒。</strong></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">6000</span> <span class="comment">#建立连接所用的时间，适用于网络状况正常的情况下，两端两端连接所用的时间</span></span><br><span class="line">  <span class="attr">ConnectionTimeout:</span> <span class="number">6000</span> <span class="comment">#建立连接后，服务器读取到可用资源的时间</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：由于 OpenFeign 集成了 Ribbon ，其服务调用以及负载均衡在底层都是依靠 Ribbon 实现的，因此 OpenFeign 超时控制也是通过 Ribbon 来实现的。</p>
</blockquote>
<h3 id="6-OpenFeign-日志增强"><a href="#6-OpenFeign-日志增强" class="headerlink" title="6.OpenFeign 日志增强"></a>6.OpenFeign 日志增强</h3><p>OpenFeign 提供了日志打印功能，我们可以通过配置调整日志级别，来了解请求的细节。</p>
<p>Feign 为每一个 FeignClient 都提供了一个 feign.Logger 实例，通过它可以对 OpenFeign 服务绑定接口的调用情况进行监控。</p>
<p>application.yml 中配置以下内容。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment">#feign 日志以什么样的级别监控该接口</span></span><br><span class="line">    <span class="attr">net.biancheng.c.service.DeptFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<p>以上配置说明如下：</p>
<ul>
<li>net.biancheng.c.service.DeptFeignService 是开启 @FeignClient 注解的接口（即服务绑定接口）的完整类名。也可以只配置部分路径，表示监控该路径下的所有服务绑定接口</li>
<li>debug：表示监听该接口的日志级别。</li>
</ul>
<p>以上配置的含义就是，OpenFeign 以 debug 级别监控 net.biancheng.c.service.DeptFeignService 接口。</p>
<p>创建一个名为 ConfigBean 的配置类，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigBean</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * OpenFeign 日志增强</span></span><br><span class="line"><span class="comment">     * 配置 OpenFeign 记录哪些内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.Level <span class="title function_">feginLoggerLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该配置的作用是通过配置的 Logger.Level 对象告诉 OpenFeign 记录哪些日志内容。</p>
<p> Logger.Level 的具体级别如下：</p>
<ul>
<li>NONE：不记录任何信息。</li>
<li>BASIC：仅记录请求方法、URL 以及响应状态码和执行时间。</li>
<li>HEADERS：除了记录 BASIC 级别的信息外，还会记录请求和响应的头信息。</li>
<li>FULL：记录所有请求与响应的明细，包括头信息、请求体、元数据等等。</li>
</ul>
<h2 id="Hystrix：Spring-Cloud服务熔断与降级组件"><a href="#Hystrix：Spring-Cloud服务熔断与降级组件" class="headerlink" title="Hystrix：Spring Cloud服务熔断与降级组件"></a>Hystrix：Spring Cloud服务熔断与降级组件</h2><p>![image-20220912144222275](Spring Cloud 微服务.assets&#x2F;image-20220912144222275.png)</p>
<p>从以上过程可以看出，当微服务系统的一个服务出现故障时，故障会沿着服务的调用链路在系统中疯狂蔓延，最终导致整个微服务系统的瘫痪，这就是“雪崩效应”。为了防止此类事件的发生，微服务架构引入了“熔断器”的一系列服务容错和保护机制。</p>
<h3 id="1-熔断器"><a href="#1-熔断器" class="headerlink" title="1.熔断器"></a>1.熔断器</h3><p>熔断器（Circuit Breaker）一词来源物理学中的电路知识，它的作用是当线路出现故障时，迅速切断电源以保护电路的安全。</p>
<p>在微服务领域，熔断器最早是由 Martin Fowler 在他发表的 《<a target="_blank" rel="noopener" href="https://martinfowler.com/bliki/CircuitBreaker.html">Circuit Breake</a>r》一文中提出。与物理学中的熔断器作用相似，<strong>微服务架构中的熔断器能够在某个服务发生故障后，向服务调用方返回一个符合预期的、可处理的降级响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常。</strong>这样就保证了服务调用方的线程不会被长时间、不必要地占用，避免故障在微服务系统中的蔓延，防止系统雪崩效应的发生。</p>
<h3 id="2-Spring-Cloud-Hystrix"><a href="#2-Spring-Cloud-Hystrix" class="headerlink" title="2.Spring Cloud Hystrix"></a>2.Spring Cloud Hystrix</h3><p>Spring Cloud Hystrix 是基于 Netflix 公司的开源组件 Hystrix 实现的，它提供了熔断器功能，能够有效地阻止分布式微服务系统中出现联动故障，以提高微服务系统的弹性。<strong>Spring Cloud Hystrix 具有服务降级、服务熔断、线程隔离、请求缓存、请求合并以及实时故障监控</strong>等强大功能。</p>
<blockquote>
<p>Hystrix [hɪst’rɪks]，中文含义是豪猪，豪猪的背上长满了棘刺，使它拥有了强大的自我保护能力。而 Spring Cloud Hystrix 作为一个服务容错与保护组件，也可以让服务拥有自我保护的能力，因此也有人将其戏称为“豪猪哥”。</p>
</blockquote>
<p>在微服务系统中，Hystrix 能够帮助我们实现以下目标：</p>
<ul>
<li><strong>保护线程资源</strong>：防止单个服务的故障耗尽系统中的所有线程资源。</li>
<li><strong>快速失败机制</strong>：当某个服务发生了故障，不让服务调用方一直等待，而是直接返回请求失败。</li>
<li><strong>提供降级（FallBack）方案</strong>：在请求失败后，提供一个设计好的降级方案，通常是一个兜底方法，当请求失败后即调用该方法。</li>
<li><strong>防止故障扩散</strong>：使用熔断机制，防止故障扩散到其他服务。</li>
<li><strong>监控功能</strong>：提供熔断器故障监控组件 Hystrix Dashboard，随时监控熔断器的状态。</li>
</ul>
<h3 id="3-Hystrix-服务降级"><a href="#3-Hystrix-服务降级" class="headerlink" title="3.Hystrix 服务降级"></a>3.Hystrix 服务降级</h3><p>服务降级的使用场景有以下 2 种：</p>
<ul>
<li>在服务器压力剧增时，根据实际业务情况及流量，对一些不重要、不紧急的服务进行有策略地不处理或简单处理，从而释放服务器资源以保证核心服务正常运作。</li>
<li>当某些服务不可用时，为了避免长时间等待造成服务卡顿或雪崩效应，而主动执行备用的降级逻辑立刻返回一个友好的提示，以保障主体业务不受影响。</li>
</ul>
<p>我们可以通过重写 HystrixCommand 的 getFallBack() 方法或 HystrixObservableCommand 的 resumeWithFallback() 方法，使服务支持服务降级。</p>
<p>Hystrix 服务降级 FallBack 既可以放在服务端进行，也可以放在客户端进行。</p>
<p>Hystrix 会在以下场景下进行服务降级处理：</p>
<ul>
<li>程序运行异常</li>
<li>服务超时</li>
<li>熔断器处于打开状态</li>
<li>线程池资源耗尽</li>
</ul>
<h4 id="3-1服务端服务降级"><a href="#3-1服务端服务降级" class="headerlink" title="3.1服务端服务降级"></a>3.1服务端服务降级</h4><p>1.导包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加 Spring Boot 的监控模块--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- eureka 客户端--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--hystrix 依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.配置文件 application.yml，配置内容如下</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">microServiceCloudProviderDeptHystrix</span>  <span class="comment">#微服务名称，对外暴漏的微服务名称，十分重要</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8004</span></span><br><span class="line"><span class="comment">########################################### Spring cloud 自定义服务名称和 ip 地址###############################################</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span> <span class="comment">#将客户端注册到 eureka 服务列表内</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#defaultZone: http://eureka7001:7001/eureka  #这个地址是 7001注册中心在 application.yml 中暴露出来额注册地址 （单机版）</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span>  <span class="comment">#将服务注册到 Eureka 集群</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">spring-cloud-provider-8004</span> <span class="comment">#自定义服务名称信息</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span>  <span class="comment">#显示访问路径的 ip 地址</span></span><br><span class="line"><span class="comment">#####################spring cloud 使用 Spring Boot actuator 监控完善信息###########################################</span></span><br><span class="line"><span class="comment"># Spring Boot 2.50对 actuator 监控屏蔽了大多数的节点，只暴露了 heath 节点，本段配置（*）就是为了开启所有的节点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span>   <span class="comment"># * 在yaml 文件属于关键字，所以需要加引号</span></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line">  <span class="attr">app.name:</span> <span class="string">micro-service-cloud-provider-dept-hystrix</span></span><br><span class="line">  <span class="attr">company.name:</span> <span class="string">c.biancheng.net</span></span><br><span class="line">  <span class="attr">build.aetifactId:</span> <span class="string">@project.artifactId@</span></span><br><span class="line">  <span class="attr">build.version:</span> <span class="string">@project.version@</span></span><br></pre></td></tr></table></figure>

<p>3.实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;deptService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">DeptService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Ok</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;  deptInfo_Ok,id:   &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一旦该方法失败并抛出了异常信息后，会自动调用  @HystrixCommand 注解标注的 fallbackMethod 指定的方法</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;dept_TimeoutHandler&quot;,</span></span><br><span class="line"><span class="meta">            commandProperties =</span></span><br><span class="line"><span class="meta">                    //规定 5 秒钟以内就不报错，正常运行，超过 5 秒就报错，调用指定的方法</span></span><br><span class="line"><span class="meta">                    &#123;@HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;5000&quot;)&#125;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Timeout</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">outTime</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(outTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;  deptInfo_Timeout,id:   &quot;</span> + id + <span class="string">&quot;  耗时: &quot;</span> + outTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当服务出现故障后，调用该方法给出友好提示</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dept_TimeoutHandler</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span>  <span class="string">&quot;C语言中文网提醒您，系统繁忙请稍后再试！&quot;</span>+<span class="string">&quot;线程池：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;  deptInfo_Timeout,id:   &quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 deptInfo_Timeout() 方法上使用 @HystrixCommand 注解，该注解说明如下：</p>
<ul>
<li>参数 fallbackMethod 属性用于指定降级方法。</li>
<li>参数 execution.isolation.thread.timeoutInMilliseconds 用于设置自身调用超时时间的峰值，峰值内可以正常运行，否则执行降级方法</li>
</ul>
<p>4.启动类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">//开启 Eureka 客户端功能</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span> <span class="comment">//激活熔断器功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudProviderDeptHystrix8004Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudProviderDeptHystrix8004Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-2客户端服务降级"><a href="#3-2客户端服务降级" class="headerlink" title="3.2客户端服务降级"></a>3.2客户端服务降级</h4><p>通常情况下，我们都会在客户端进行服务降级，当客户端调用的服务端的服务不可用时，客户端直接进行服务降级处理，避免其线程被长时间、不必要地占用。</p>
<p>1.依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--hystrix 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.application.yml 中添加以下配置，开启客户端的 Hystrix 功能。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启客户端 hystrix</span></span><br></pre></td></tr></table></figure>

<p>3.服务接口进行绑定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;MICROSERVICECLOUDPROVIDERDEPTHYSTRIX&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptHystrixService</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/dept/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Ok</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/dept/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Timeout</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.降级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixController_Consumer</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> DeptHystrixService deptHystrixService;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/consumer/dept/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Ok</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deptHystrixService.deptInfo_Ok(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在客户端进行降级</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/consumer/dept/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;dept_TimeoutHandler&quot;)</span> <span class="comment">//为该请求指定专属的回退方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Timeout</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> deptHystrixService.deptInfo_Timeout(id);</span><br><span class="line">        log.info(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// deptInfo_Timeout方法的 专用 fallback 方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dept_TimeoutHandler</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;deptInfo_Timeout 出错，服务已被降级！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;C语言中文网提醒您：服务端系统繁忙，请稍后再试！（客户端 deptInfo_Timeout 专属的回退方法触发）&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.appliction.yml 中添加以下配置，在客户端配置请求超时的时间</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######################### Ribbon 客户端超时控制 ###################################</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">6000</span> <span class="comment">#建立连接所用的时间，适用于网络状况正常的情况下，两端两端连接所用的时间</span></span><br><span class="line">  <span class="attr">ConnectionTimeout:</span> <span class="number">6000</span> <span class="comment">#建立连接后，服务器读取到可用资源的时间</span></span><br><span class="line"><span class="comment">######################配置请求超时时间##########################</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">7000</span></span><br><span class="line"><span class="comment">####################配置具体方法超时时间 为 3 秒########################</span></span><br><span class="line">    <span class="string">DeptHystrixService#deptInfo_Timeout(Integer):</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>

<p>1）Hystrix 可以来为所有请求（方法）设置超时时间（单位为毫秒），若请求超时则触发全局的回退方法进行处理。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=mmm</span></span><br></pre></td></tr></table></figure>


<p>2）Hystrix 还可以为某个特定的服务请求（方法）设置超时时间，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hystrix.command.xxx#yyy(zzz).execution.isolation.thread.timeoutInMilliseconds=mmm</span><br></pre></td></tr></table></figure>

<p>格式说明如下：</p>
<ul>
<li>xxx：为包含该服务方法的类的名称（通常为服务绑定接口的名称），例如 DeptHystrixService 接口。</li>
<li>yyy：服务方法名，例如 deptInfo_Timeout() 方法。</li>
<li>zzz：方法内的参数类型，例如 Integer、String 等等</li>
<li>mmm：要设置的超时时间，单位为毫秒（1 秒 &#x3D;1000 毫秒）</li>
</ul>
<p>6.启动类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">//开启 OpenFeign 功能</span></span><br><span class="line"><span class="meta">@EnableHystrix</span> <span class="comment">//启用 Hystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudConsumerDeptFeignApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudConsumerDeptFeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-全局降级方法"><a href="#4-全局降级方法" class="headerlink" title="4.全局降级方法"></a>4.全局降级方法</h3><p>通过上面的方式实现服务降级时，需要针对所有业务方法都配置降级方法，这极有可能会造成代码的急剧膨胀。为了解决该问题，我们还可以为所有业务方法指定一个全局的回退方法，具体步骤如下。</p>
<p>1.通过其 defaultFallback 属性指定一个全局的降级方法，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@DefaultProperties(defaultFallback = &quot;dept_Global_FallbackMethod&quot;)</span> <span class="comment">//全局的服务降级方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixController_Consumer</span> &#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建一个名为 dept_Global_FallbackMethod 的全局回方法，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局的 fallback 方法，</span></span><br><span class="line"><span class="comment"> * 回退方法必须和 hystrix 的执行方法在相同类中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DefaultProperties</span>(defaultFallback = &quot;dept_Global_FallbackMethod&quot;) 类上注解，请求方法上使用 <span class="doctag">@HystrixCommand</span> 注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dept_Global_FallbackMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;C语言中文网提醒您，运行出错或服务端系统繁忙，请稍后再试！（客户端全局回退方法触发,）&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：降级（FallBack）方法必须与其对应的业务方法在同一个类中，否则无法生效。</p>
</blockquote>
<p>3.在所有的业务方法上都标注 @HystrixCommand 注解，这里我们将 deptInfo_Timeout() 方法上的 @HystrixCommand(fallbackMethod &#x3D; “dept_TimeoutHandler”) 修改为 @HystrixCommand 即可，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在客户端进行降级</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/consumer/dept/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deptInfo_Timeout</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> deptHystrixService.deptInfo_Timeout(id);</span><br><span class="line">    log.info(s);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：全局降级方法的优先级较低，只有业务方法没有指定其降级方法时，服务降级时才会触发全局回退方法。若业务方法指定它自己的回退方法，那么在服务降级时，就只会直接触发它自己的回退方法，而非全局回退方法。</p>
</blockquote>
<h3 id="5-解耦降级逻辑"><a href="#5-解耦降级逻辑" class="headerlink" title="5.解耦降级逻辑"></a>5.解耦降级逻辑</h3><p>不管是业务方法指定的降级方法还是全局降级方法，它们都必须和业务方法在同一个类中才能生效，业务逻辑与降级逻辑耦合度极高。</p>
<p>1.提供服务降级处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Hystrix 服务降级</span></span><br><span class="line"><span class="comment">* 解耦回退逻辑</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptHystrixFallBackService</span> <span class="keyword">implements</span> <span class="title class_">DeptHystrixService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Ok</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;--------------------C语言中文网提醒您，系统繁忙，请稍后重试！（解耦回退方法触发）-----------------------&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Timeout</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;--------------------C语言中文网提醒您，系统繁忙，请稍后重试！（解耦回退方法触发）-----------------------&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：该类必须以组件的形式添加 Spring 容器中才能生效，最常用的方式就是在类上标注 @Component 注解。</p>
</blockquote>
<p>2.在服务绑定接口 DeptHystrixService 标注的 @FeignClient 注解中添加 fallback 属性，属性值为 DeptHystrixFallBackService.class，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;MICROSERVICECLOUDPROVIDERDEPTHYSTRIX&quot;, fallback = DeptHystrixFallBackService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptHystrixService</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/dept/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Ok</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/dept/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Timeout</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-Hystrix-服务熔断"><a href="#6-Hystrix-服务熔断" class="headerlink" title="6.Hystrix 服务熔断"></a>6.Hystrix 服务熔断</h3><p>熔断机制是为了应对雪崩效应而出现的一种微服务链路保护机制。</p>
<p>当微服务系统中的某个微服务不可用或响应时间太长时，为了保护系统的整体可用性，熔断器会暂时切断请求对该服务的调用，并快速返回一个友好的错误响应。这种熔断状态不是永久的，在经历了一定的时间后，熔断器会再次检测该微服务是否恢复正常，若服务恢复正常则恢复其调用链路。</p>
<h4 id="熔断状态"><a href="#熔断状态" class="headerlink" title="熔断状态"></a>熔断状态</h4><p>在熔断机制中涉及了三种熔断状态：</p>
<ul>
<li>熔断关闭状态（Closed）：当服务访问正常时，熔断器处于关闭状态，服务调用方可以正常地对服务进行调用。</li>
<li>熔断开启状态（Open）：默认情况下，在固定时间内接口调用出错比率达到一个阈值（例如 50%），熔断器会进入熔断开启状态。进入熔断状态后，后续对该服务的调用都会被切断，熔断器会执行本地的降级（FallBack）方法。</li>
<li>半熔断状态（Half-Open）： 在熔断开启一段时间之后，熔断器会进入半熔断状态。在半熔断状态下，熔断器会尝试恢复服务调用方对服务的调用，允许部分请求调用该服务，并监控其调用成功率。如果成功率达到预期，则说明服务已恢复正常，熔断器进入关闭状态；如果成功率仍旧很低，则重新进入熔断开启状态。</li>
</ul>
<p>![image-20220912153121380](Spring Cloud 微服务.assets&#x2F;image-20220912153121380.png)</p>
<h4 id="Hystrix-实现熔断机制"><a href="#Hystrix-实现熔断机制" class="headerlink" title="Hystrix 实现熔断机制"></a>Hystrix 实现熔断机制</h4><p>在 Spring Cloud 中，熔断机制是通过 Hystrix 实现的。Hystrix 会监控微服务间调用的状况，当失败调用到一定比例时（例如 5 秒内失败 20 次），就会启动熔断机制。</p>
<p>Hystrix 实现服务熔断的步骤如下：</p>
<ol>
<li>当服务的调用出错率达到或超过 Hystix 规定的比率（默认为 50%）后，熔断器进入熔断开启状态。</li>
<li>熔断器进入熔断开启状态后，Hystrix 会启动一个休眠时间窗，在这个时间窗内，该服务的降级逻辑会临时充当业务主逻辑，而原来的业务主逻辑不可用。</li>
<li>当有请求再次调用该服务时，会直接调用降级逻辑快速地返回失败响应，以避免系统雪崩。</li>
<li>当休眠时间窗到期后，Hystrix 会进入半熔断转态，允许部分请求对服务原来的主业务逻辑进行调用，并监控其调用成功率。</li>
<li>如果调用成功率达到预期，则说明服务已恢复正常，Hystrix 进入熔断关闭状态，服务原来的主业务逻辑恢复；否则 Hystrix 重新进入熔断开启状态，休眠时间窗口重新计时，继续重复第 2 到第 5 步。</li>
</ol>
<p>1.方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptService</span> &#123;</span><br><span class="line">    <span class="comment">// hystrix 熔断器示例 ok</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Ok</span><span class="params">(Integer id)</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//hystrix 熔断器超时案例</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptInfo_Timeout</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="comment">// Hystrix 熔断机制案例</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">deptCircuitBreaker</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.实现及其回退</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hystrix 熔断案例</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;deptCircuitBreaker_fallback&quot;, commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        //以下参数在 HystrixCommandProperties 类中有默认配置</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;, value = &quot;true&quot;), //是否开启熔断器</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;metrics.rollingStats.timeInMilliseconds&quot;,value = &quot;1000&quot;), //统计时间窗</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;), //统计时间窗内请求次数</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value = &quot;10000&quot;), //休眠时间窗口期</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;60&quot;), //在统计时间窗口期以内，请求失败率达到 60% 时进入熔断状态</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deptCircuitBreaker</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//当传入的 id 为负数时，抛出异常，调用降级方法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;c语言中文网提醒您，id 不能是负数！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">serialNum</span> <span class="operator">=</span> IdUtil.simpleUUID();</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;调用成功，流水号为：&quot;</span> + serialNum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deptCircuitBreaker 的降级方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deptCircuitBreaker_fallback</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，id 不能是负数,请稍后重试!\t id:&quot;</span> + id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>metrics.rollingStats.timeInMilliseconds</td>
<td>统计时间窗。</td>
</tr>
<tr>
<td>circuitBreaker.sleepWindowInMilliseconds</td>
<td>休眠时间窗，熔断开启状态持续一段时间后，熔断器会自动进入半熔断状态，这段时间就被称为休眠窗口期。</td>
</tr>
<tr>
<td>circuitBreaker.requestVolumeThreshold</td>
<td>请求总数阀值。  在统计时间窗内，请求总数必须到达一定的数量级，Hystrix 才可能会将熔断器打开进入熔断开启转态，而这个请求数量级就是 请求总数阀值。Hystrix 请求总数阈值默认为 20，这就意味着在统计时间窗内，如果服务调用次数不足 20 次，即使所有的请求都调用出错，熔断器也不会打开。</td>
</tr>
<tr>
<td>circuitBreaker.errorThresholdPercentage</td>
<td>错误百分比阈值。  当请求总数在统计时间窗内超过了请求总数阀值，且请求调用出错率超过一定的比例，熔断器才会打开进入熔断开启转态，而这个比例就是错误百分比阈值。错误百分比阈值设置为 50，就表示错误百分比为 50%，如果服务发生了 30 次调用，其中有 15 次发生了错误，即超过了 50% 的错误百分比，这时候将熔断器就会打开。</td>
</tr>
</tbody></table>
<h3 id="7-Hystrix-故障监控"><a href="#7-Hystrix-故障监控" class="headerlink" title="7.Hystrix 故障监控"></a>7.Hystrix 故障监控</h3><p>Hystrix 还提供了准实时的调用监控（Hystrix Dashboard）功能，Hystrix 会持续地记录所有通过 Hystrix 发起的请求的执行信息，并以统计报表的形式展示给用户，包括每秒执行请求的数量、成功请求的数量和失败请求的数量等。</p>
<p>1.依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring Boot 测试依赖--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--hystrix-dashboard 监控的依赖--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--添加 Spring Boot 的监控模块--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9002</span>  <span class="comment">#端口号</span></span><br><span class="line"><span class="comment">#http://eureka7001.com:9002/hystrix 熔断器监控页面</span></span><br><span class="line"><span class="comment"># localhost:8004//actuator/hystrix.stream 监控地址</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">dashboard:</span></span><br><span class="line">    <span class="attr">proxy-stream-allow-list:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;localhost&quot;</span></span><br></pre></td></tr></table></figure>

<p>3.主启动类上添加 @EnableHystrixDashboard 注解，开启 Hystrix 监控功能，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudConsumerDeptHystrixDashboard9002Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudConsumerDeptHystrixDashboard9002Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HystrixDashboardConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Hystrix dashboard 监控界面必须配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean <span class="title function_">getServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HystrixMetricsStreamServlet</span> <span class="variable">streamServlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HystrixMetricsStreamServlet</span>();</span><br><span class="line">        <span class="type">ServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">&quot;/actuator/hystrix.stream&quot;</span>);<span class="comment">//访问路径</span></span><br><span class="line">        registrationBean.setName(<span class="string">&quot;hystrix.stream&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Gateway：Spring-Cloud-API网关组件"><a href="#Gateway：Spring-Cloud-API网关组件" class="headerlink" title="Gateway：Spring Cloud API网关组件"></a>Gateway：Spring Cloud API网关组件</h2><p>在微服务架构中，一个系统往往由多个微服务组成，而这些服务可能部署在不同机房、不同地区、不同域名下。这种情况下，客户端（例如浏览器、手机、软件工具等）想要直接请求这些服务，就需要知道它们具体的地址信息，例如 IP 地址、端口号等。</p>
<p>这种客户端直接请求服务的方式存在以下问题：</p>
<ul>
<li>当服务数量众多时，客户端需要维护大量的服务地址，这对于客户端来说，是非常繁琐复杂的。</li>
<li>在某些场景下可能会存在跨域请求的问题。</li>
<li>身份认证的难度大，每个微服务需要独立认证。</li>
</ul>
<h3 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h3><p>API 网关是一个搭建在客户端和微服务之间的服务，我们可以在 API 网关中处理一些非业务功能的逻辑，例如权限验证、监控、缓存、请求路由等。</p>
<p>![image-20220912172529634](Spring Cloud 微服务.assets&#x2F;image-20220912172529634.png)</p>
<p>对于服务数量众多、复杂度较高、规模比较大的系统来说，使用 API 网关具有以下好处：</p>
<ul>
<li>客户端通过 API 网关与微服务交互时，客户端只需要知道 API 网关地址即可，而不需要维护大量的服务地址，简化了客户端的开发。</li>
<li>客户端直接与 API 网关通信，能够减少客户端与各个服务的交互次数。</li>
<li>客户端与后端的服务耦合度降低。</li>
<li>节省流量，提高性能，提升用户体验。</li>
<li>API 网关还提供了安全、流控、过滤、缓存、计费以及监控等 API 管理功能。</li>
</ul>
<p>常见的 API 网关实现方案主要有以下 5 种：</p>
<ul>
<li><strong>Spring Cloud Gateway</strong></li>
<li><strong>Spring Cloud Netflix Zuul</strong></li>
<li>Kong</li>
<li>Nginx+Lua</li>
<li>Traefik</li>
</ul>
<h3 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h3><p>Spring Cloud Gateway 是 Spring Cloud 团队基于 Spring 5.0、Spring Boot 2.0 和 Project <strong>Reactor</strong> 等技术开发的<strong>高性能</strong> <strong>API</strong> <strong>网关组件</strong>。</p>
<p>Spring Cloud Gateway 旨在<strong>提供一种简单而有效的途径来发送 API</strong>，并为它们提供横切关注点，例如：安全性，监控&#x2F;指标和弹性。 </p>
<blockquote>
<p>Spring Cloud Gateway 是基于 WebFlux 框架实现的，而 WebFlux 框架底层则使用了高性能的 Reactor 模式通信框架 Netty。</p>
</blockquote>
<h4 id="Spring-Cloud-Gateway-核心概念"><a href="#Spring-Cloud-Gateway-核心概念" class="headerlink" title="Spring Cloud Gateway 核心概念"></a>Spring Cloud Gateway 核心概念</h4><p>Spring Cloud GateWay 最主要的功能就是路由转发，而在定义转发规则时主要涉及了以下三个核心概念，如下表。</p>
<table>
<thead>
<tr>
<th>核心概念</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Route（路由）</td>
<td>网关最基本的模块。它由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成。</td>
</tr>
<tr>
<td>Predicate（断言）</td>
<td>路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。</td>
</tr>
<tr>
<td>Filter（过滤器）</td>
<td>过滤器，我们可以使用它对请求进行拦截和修改，还可以使用它对上文的响应进行再处理。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：其中 Route 和 Predicate 必须同时声明。</p>
</blockquote>
<h4 id="Spring-Cloud-Gateway-的特征"><a href="#Spring-Cloud-Gateway-的特征" class="headerlink" title="Spring Cloud Gateway 的特征"></a>Spring Cloud Gateway 的特征</h4><p>Spring Cloud Gateway 具有以下特性：</p>
<ul>
<li>基于 Spring Framework 5、Project Reactor 和 Spring Boot 2.0 构建。</li>
<li>能够在任意请求属性上匹配路由。</li>
<li>predicates（断言） 和 filters（过滤器）是特定于路由的。</li>
<li>集成了 Hystrix 熔断器。</li>
<li>集成了 Spring Cloud DiscoveryClient（服务发现客户端）。</li>
<li>易于编写断言和过滤器。</li>
<li>能够限制请求频率。</li>
<li>能够重写请求路径。</li>
</ul>
<h3 id="Gateway-的工作流程"><a href="#Gateway-的工作流程" class="headerlink" title="Gateway 的工作流程"></a>Gateway 的工作流程</h3><img src="/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220912173002658.png" alt="image-20220912173002658" style="zoom:50%;">

<p>Spring Cloud Gateway 工作流程说明如下：</p>
<ol>
<li>客户端将请求发送到 Spring Cloud Gateway 上。</li>
<li>Spring Cloud Gateway 通过 Gateway Handler Mapping 找到与请求相匹配的路由，将其发送给 Gateway Web Handler。</li>
<li>Gateway Web Handler 通过指定的过滤器链（Filter Chain），将请求转发到实际的服务节点中，执行业务逻辑返回响应结果。</li>
<li>过滤器之间用虚线分开是因为过滤器可能会在转发请求之前（pre）或之后（post）执行业务逻辑。</li>
<li>过滤器（Filter）可以在请求被转发到服务端前，对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等。</li>
<li>过滤器可以在响应返回客户端之前，对响应进行拦截和再处理，例如修改响应内容或响应头、日志输出、流量监控等。</li>
<li>响应原路返回给客户端。</li>
</ol>
<p>总而言之，客户端发送到 Spring Cloud Gateway 的请求需要通过一定的匹配条件，才能定位到真正的服务节点。在将请求转发到服务进行处理的过程前后（pre 和 post），我们还可以对请求和响应进行一些精细化控制。</p>
<p>Predicate 就是路由的匹配条件，而 Filter 就是对请求和响应进行精细化控制的工具。有了这两个元素，再加上目标 URI，就可以实现一个具体的路由了。</p>
<h3 id="Predicate-断言"><a href="#Predicate-断言" class="headerlink" title="Predicate 断言"></a>Predicate 断言</h3><p>Spring Cloud Gateway 通过 Predicate 断言来实现 Route 路由的匹配规则。简单点说，<strong>Predicate 是路由转发的判断条件</strong>，请求只有满足了 Predicate 的条件，才会被转发到指定的服务上进行处理。</p>
<p>使用 Predicate 断言需要注意以下 3 点：</p>
<ul>
<li>Route 路由与 Predicate 断言的对应关系为“一对多”，<strong>一个路由可以包含多个不同断言</strong>。</li>
<li>一个请求想要转发到指定的路由上，<strong>就必须同时匹配路由上的所有断言</strong>。</li>
<li>当一个请求同时满足多个路由的断言条件时，请求只会被首个成功匹配的路由转发。</li>
</ul>
<img src="/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220912173236315.png" alt="image-20220912173236315" style="zoom:67%;">

<table>
<thead>
<tr>
<th>Path</th>
<th>- Path&#x3D;&#x2F;dept&#x2F;list&#x2F;**</th>
<th>当请求路径与 &#x2F;dept&#x2F;list&#x2F;** 匹配时，该请求才能被转发到 <a target="_blank" rel="noopener" href="http://localhost:8001/">http://localhost:8001</a> 上。</th>
</tr>
</thead>
<tbody><tr>
<td>Before</td>
<td>- Before&#x3D;2021-10-20T11:47:34.255+08:00[Asia&#x2F;Shanghai]</td>
<td>在 2021 年 10 月 20 日 11 时 47 分 34.255 秒之前的请求，才会被转发到 <a target="_blank" rel="noopener" href="http://localhost:8001/">http://localhost:8001</a> 上。</td>
</tr>
<tr>
<td>After</td>
<td>- After&#x3D;2021-10-20T11:47:34.255+08:00[Asia&#x2F;Shanghai]</td>
<td>在 2021 年 10 月 20 日 11 时 47 分 34.255 秒之后的请求，才会被转发到 <a target="_blank" rel="noopener" href="http://localhost:8001/">http://localhost:8001</a> 上。</td>
</tr>
<tr>
<td>Between</td>
<td>- Between&#x3D;2021-10-20T15:18:33.226+08:00[Asia&#x2F;Shanghai],2021-10-20T15:23:33.226+08:00[Asia&#x2F;Shanghai]</td>
<td>在 2021 年 10 月 20 日 15 时 18 分 33.226 秒 到 2021 年 10 月 20 日 15 时 23 分 33.226 秒之间的请求，才会被转发到 <a target="_blank" rel="noopener" href="http://localhost:8001/">http://localhost:8001</a> 服务器上。</td>
</tr>
<tr>
<td>Cookie</td>
<td>- Cookie&#x3D;name,c.biancheng.net</td>
<td>携带 Cookie 且 Cookie 的内容为 name&#x3D;c.biancheng.net 的请求，才会被转发到 <a target="_blank" rel="noopener" href="http://localhost:8001/">http://localhost:8001</a> 上。</td>
</tr>
<tr>
<td>Header</td>
<td>- Header&#x3D;X-Request-Id,\d+</td>
<td>请求头上携带属性 X-Request-Id 且属性值为整数的请求，才会被转发到 <a target="_blank" rel="noopener" href="http://localhost:8001/">http://localhost:8001</a> 上。</td>
</tr>
<tr>
<td>Method</td>
<td>- Method&#x3D;GET</td>
<td>只有 GET 请求才会被转发到 <a target="_blank" rel="noopener" href="http://localhost:8001/">http://localhost:8001</a> 上。</td>
</tr>
</tbody></table>
<p>1.导包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--特别注意：在 gateway 网关服务中不能引入 spring-boot-starter-web 的依赖，否则会报错--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Spring cloud gateway 网关依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Eureka 客户端--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.application.yml，配置内容如下。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span>  <span class="comment">#端口号</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">microServiceCloudGateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span> <span class="comment">#网关路由配置</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment">#将 micro-service-cloud-provider-dept-8001 提供的服务隐藏起来，不暴露给客户端，只给客户端暴露 API 网关的地址 9527</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">provider_dept_list_routh</span>   <span class="comment">#路由 id,没有固定规则，但唯一，建议与服务名对应</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span>          <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="comment">#以下是断言条件，必选全部符合条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/dept/list/**</span>               <span class="comment">#断言，路径匹配 注意：Path 中 P 为大写</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Method=GET</span> <span class="comment">#只能时 GET 请求时，才能访问</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">micro-service-cloud-gateway-9527</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">micro-service-cloud-gateway</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span></span><br></pre></td></tr></table></figure>

<p>以上配置中，我们在 spring.cloud.gateway.routes 下使用 predicates 属性，定义了以下两个断言条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- Path=/dept/list/**            </span><br><span class="line">- Method=GET </span><br></pre></td></tr></table></figure>

<p>3.主启动类上，使用 @EnableEurekaClient 注解开启 Eureka 客户端功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MicroServiceCloudGateway9527Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudGateway9527Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring-Cloud-Gateway-动态路由"><a href="#Spring-Cloud-Gateway-动态路由" class="headerlink" title="Spring Cloud Gateway 动态路由"></a>Spring Cloud Gateway 动态路由</h3><p>默认情况下，Spring Cloud Gateway 会根据服务注册中心（例如 Eureka Server）中维护的服务列表，以服务名（spring.application.name）作为路径创建动态路由进行转发，从而实现动态路由功能。</p>
<p>我们可以在配置文件中，将 Route 的 uri 地址修改为以下形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lb://service-name</span><br></pre></td></tr></table></figure>


<p>以上配置说明如下：</p>
<ul>
<li>lb：uri 的协议，表示开启 Spring Cloud Gateway 的负载均衡功能。</li>
<li>service-name：服务名，Spring Cloud Gateway 会根据它获取到具体的微服务地址。</li>
</ul>
<p>1.配置，使用注册中心中的微服务名创建动态路由进行转发</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span> <span class="comment">#端口号</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">microServiceCloudGateway</span>  <span class="comment">#服务注册中心注册的服务名</span></span><br><span class="line">   </span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span> <span class="comment">#网关路由配置</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#默认值为 true，即默认开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment">#将 micro-service-cloud-provider-dept-8001 提供的服务隐藏起来，不暴露给客户端，只给客户端暴露 API 网关的地址 9527</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">provider_dept_list_routh</span>   <span class="comment">#路由 id,没有固定规则，但唯一，建议与服务名对应</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://MICROSERVICECLOUDPROVIDERDEPT</span> <span class="comment">#动态路由，使用服务名代替上面的具体带端口   http://eureka7001.com:9527/dept/list</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="comment">#以下是断言条件，必选全部符合条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/dept/list/**</span>    <span class="comment">#断言，路径匹配 注意：Path 中 P 为大写</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Method=GET</span> <span class="comment">#只能时 GET 请求时，才能访问</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">micro-service-cloud-gateway-9527</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">micro-service-cloud-gateway</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span></span><br></pre></td></tr></table></figure>

<h3 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter 过滤器"></a>Filter 过滤器</h3><p>通常情况下，出于安全方面的考虑，服务端提供的服务往往都会有一定的校验逻辑，例如用户登陆状态校验、签名校验等。</p>
<p>在微服务架构中，系统由多个微服务组成，所有这些服务都需要这些校验逻辑，此时我们就可以将这些校验逻辑写到 Spring Cloud Gateway 的 Filter 过滤器中。</p>
<h4 id="Filter-的分类"><a href="#Filter-的分类" class="headerlink" title="Filter 的分类"></a>Filter 的分类</h4><p>Spring Cloud Gateway 提供了以下两种类型的过滤器，可以对请求和响应进行精细化控制。</p>
<table>
<thead>
<tr>
<th>过滤器类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Pre 类型</td>
<td>这种过滤器在请求被转发到微服务之前可以对请求进行拦截和修改，例如参数校验、权限校验、流量监控、日志输出以及协议转换等操作。</td>
</tr>
<tr>
<td>Post 类型</td>
<td>这种过滤器在微服务对请求做出响应后可以对响应进行拦截和再处理，例如修改响应内容或响应头、日志输出、流量监控等。</td>
</tr>
</tbody></table>
<p>按照作用范围划分，Spring Cloud gateway 的 Filter 可以分为 2 类：</p>
<ul>
<li>GatewayFilter：应用在单个路由或者一组路由上的过滤器。</li>
<li>GlobalFilter：应用在所有的路由上的过滤器。</li>
</ul>
<h4 id="GatewayFilter-网关过滤器"><a href="#GatewayFilter-网关过滤器" class="headerlink" title="GatewayFilter 网关过滤器"></a>GatewayFilter 网关过滤器</h4><p>GatewayFilter 是 Spring Cloud Gateway 网关中提供的一种应用在单个或一组路由上的过滤器。它可以对单个路由或者一组路由上传入的请求和传出响应进行拦截，并实现一些与业务无关的功能，比如登陆状态校验、签名校验、权限校验、日志输出、流量监控等。</p>
<p>1.配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span> </span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">xxxx</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">xxxx</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=xxxx</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestParameter=X-Request-Id,1024</span> <span class="comment">#过滤器工厂会在匹配的请求头加上一对请求头，名称为 X-Request-Id 值为 1024</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrefixPath=/dept</span> <span class="comment">#在请求路径前面加上 /dept</span></span><br><span class="line">            <span class="string">……</span></span><br></pre></td></tr></table></figure>

<p>Spring Cloud Gateway 内置了多达 31 种 GatewayFilter，下表中列举了几种常用的网关过滤器及其使用示例。</p>
<table>
<thead>
<tr>
<th>路由过滤器</th>
<th>描述</th>
<th>参数</th>
<th>使用示例</th>
</tr>
</thead>
<tbody><tr>
<td>AddRequestHeader</td>
<td>拦截传入的请求，并在请求上添加一个指定的请求头参数。</td>
<td>name：需要添加的请求头参数的 key； value：需要添加的请求头参数的 value。</td>
<td>- AddRequestHeader&#x3D;my-request-header,1024</td>
</tr>
<tr>
<td>AddRequestParameter</td>
<td>拦截传入的请求，并在请求上添加一个指定的请求参数。</td>
<td>name：需要添加的请求参数的 key； value：需要添加的请求参数的 value。</td>
<td>- AddRequestParameter&#x3D;my-request-param,c.biancheng.net</td>
</tr>
<tr>
<td>AddResponseHeader</td>
<td>拦截响应，并在响应上添加一个指定的响应头参数。</td>
<td>name：需要添加的响应头的 key； value：需要添加的响应头的 value。</td>
<td>- AddResponseHeader&#x3D;my-response-header,c.biancheng.net</td>
</tr>
<tr>
<td>PrefixPath</td>
<td>拦截传入的请求，并在请求路径增加一个指定的前缀。</td>
<td>prefix：需要增加的路径前缀。</td>
<td>- PrefixPath&#x3D;&#x2F;consumer</td>
</tr>
<tr>
<td>PreserveHostHeader</td>
<td>转发请求时，保持客户端的 Host 信息不变，然后将它传递到提供具体服务的微服务中。</td>
<td>无</td>
<td>- PreserveHostHeader</td>
</tr>
<tr>
<td>RemoveRequestHeader</td>
<td>移除请求头中指定的参数。</td>
<td>name：需要移除的请求头的 key。</td>
<td>- RemoveRequestHeader&#x3D;my-request-header</td>
</tr>
<tr>
<td>RemoveResponseHeader</td>
<td>移除响应头中指定的参数。</td>
<td>name：需要移除的响应头。</td>
<td>- RemoveResponseHeader&#x3D;my-response-header</td>
</tr>
<tr>
<td>RemoveRequestParameter</td>
<td>移除指定的请求参数。</td>
<td>name：需要移除的请求参数。</td>
<td>- RemoveRequestParameter&#x3D;my-request-param</td>
</tr>
<tr>
<td>RequestSize</td>
<td>配置请求体的大小，当请求体过大时，将会返回 413 Payload Too Large。</td>
<td>maxSize：请求体的大小。</td>
<td>- name: RequestSize   args:    maxSize: 5000000</td>
</tr>
</tbody></table>
<p>1.application.yml 中在添加一个动态路由，配置内容如下。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">provider_dept_get_routh</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://MICROSERVICECLOUDPROVIDERDEPT</span> <span class="comment">#使用服务名代替上面的具体带端口</span></span><br><span class="line">  <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/get/**</span></span><br><span class="line">  <span class="attr">filters:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PrefixPath=/dept</span> <span class="comment">#在请求路径上增加一个前缀 /dept</span></span><br></pre></td></tr></table></figure>

<h4 id="GlobalFilter-全局过滤器"><a href="#GlobalFilter-全局过滤器" class="headerlink" title="GlobalFilter 全局过滤器"></a>GlobalFilter 全局过滤器</h4><p>GlobalFilter 是一种作用于所有的路由上的全局过滤器，通过它，我们可以实现一些统一化的业务功能，例如权限认证、IP 访问限制等。当某个请求被路由匹配时，那么所有的 GlobalFilter 会和该路由自身配置的 GatewayFilter 组合成一个过滤器链。</p>
<p>Spring Cloud Gateway 为我们提供了多种默认的 GlobalFilter，例如与转发、路由、负载均衡等相关的全局过滤器。但在实际的项目开发中，通常我们都会自定义一些自己的 GlobalFilter 全局过滤器以满足我们自身的业务需求，而很少直接使用 Spring Cloud Config 提供这些默认的 GlobalFilter。</p>
<p>1.新建一个名为 MyGlobalFilter 全局过滤器配置类，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自定义全局网关过滤器（GlobalFilter）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;进入自定义的全局过滤器 MyGlobalFilter&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">uname</span> <span class="operator">=</span> exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (uname == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;参数 uname 不能为 null！&quot;</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//过滤器的顺序，0 表示第一个</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Sentinel：Spring-Cloud-Alibaba高可用流量控制组件"><a href="#Sentinel：Spring-Cloud-Alibaba高可用流量控制组件" class="headerlink" title="Sentinel：Spring Cloud Alibaba高可用流量控制组件"></a>Sentinel：Spring Cloud Alibaba高可用流量控制组件</h2><p>从功能上来说，Sentinel 与 Spring Cloud Netfilx Hystrix 类似，但 Sentinel 要比 Hystrix 更加强大，例如 Sentinel 提供了流量控制功能、比 Hystrix 更加完善的实时监控功能等等。</p>
<h3 id="Sentinel-的组成"><a href="#Sentinel-的组成" class="headerlink" title="Sentinel 的组成"></a>Sentinel 的组成</h3><p>Sentinel 主要由以下两个部分组成：</p>
<ul>
<li>Sentinel 核心库：Sentinel 的核心库不依赖任何框架或库，能够运行于 Java 8 及以上的版本的运行时环境中，同时对 Spring Cloud、Dubbo 等微服务框架提供了很好的支持。</li>
<li>Sentinel 控制台（Dashboard）：Sentinel 提供的一个轻量级的开源控制台，它为用户提供了机器自发现、簇点链路自发现、监控、规则配置等功能。</li>
</ul>
<p>Sentinel 核心库不依赖 Sentinel Dashboard，但两者结合使用可以有效的提高效率，让 Sentinel 发挥它最大的作用。</p>
<h3 id="Sentinel-的基本概念"><a href="#Sentinel-的基本概念" class="headerlink" title="Sentinel 的基本概念"></a>Sentinel 的基本概念</h3><table>
<thead>
<tr>
<th>基本概念</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>资源</td>
<td>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如由应用程序提供的服务或者是服务里的方法，甚至可以是一段代码。  我们可以通过 Sentinel 提供的 API 来定义一个资源，使其能够被 Sentinel 保护起来。通常情况下，我们可以使用方法名、URL 甚至是服务名来作为资源名来描述某个资源。</td>
</tr>
<tr>
<td>规则</td>
<td>围绕资源而设定的规则。Sentinel 支持流量控制、熔断降级、系统保护、来源访问控制和热点参数等多种规则，所有这些规则都可以动态实时调整。</td>
</tr>
</tbody></table>
<h3 id="SentinelResource-注解"><a href="#SentinelResource-注解" class="headerlink" title="@SentinelResource 注解"></a>@SentinelResource 注解</h3><table>
<thead>
<tr>
<th>value</th>
<th>用于指定资源的名称</th>
<th>必填</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>entryType</td>
<td>entry 类型</td>
<td>可选项（默认为 EntryType.OUT）</td>
<td>-</td>
</tr>
<tr>
<td>blockHandler</td>
<td>服务限流后会抛出 BlockException 异常，而 blockHandler 则是用来指定一个函数来处理 BlockException 异常的。  简单点说，该属性用于指定服务限流后的后续处理逻辑。</td>
<td>可选项</td>
<td>blockHandler 函数访问范围需要是 public；返回类型需要与原方法相匹配；参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException；blockHandler 函数默认需要和原方法在同一个类中，若希望使用其他类的函数，则可以指定 blockHandler 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</td>
</tr>
<tr>
<td>blockHandlerClass</td>
<td>若 blockHandler 函数与原方法不在同一个类中，则需要使用该属性指定 blockHandler 函数所在的类。</td>
<td>可选项</td>
<td>不能单独使用，必须与 blockHandler 属性配合使用；该属性指定的类中的 blockHandler 函数必须为 static 函数，否则无法解析。</td>
</tr>
<tr>
<td>fallback</td>
<td>用于在抛出异常（包括 BlockException）时，提供 fallback 处理逻辑。  fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。</td>
<td>可选项</td>
<td>返回值类型必须与原函数返回值类型一致；方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常；fallback 函数默认需要和原方法在同一个类中，若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</td>
</tr>
<tr>
<td>fallbackClass</td>
<td>若 fallback 函数与原方法不在同一个类中，则需要使用该属性指定 blockHandler 函数所在的类。</td>
<td>可选项</td>
<td>不能单独使用，必须与 fallback 或 defaultFallback 属性配合使用；该属性指定的类中的 fallback 函数必须为 static 函数，否则无法解析。</td>
</tr>
<tr>
<td>defaultFallback</td>
<td>默认的 fallback 函数名称，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。  默认 fallback 函数可以针对所以类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。</td>
<td>可选项</td>
<td>返回值类型必须与原函数返回值类型一致；方法参数列表需要为空，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常；defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</td>
</tr>
<tr>
<td>exceptionsToIgnore</td>
<td>用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。</td>
<td>可选项</td>
<td></td>
</tr>
</tbody></table>
<h3 id="Sentinel-控制台"><a href="#Sentinel-控制台" class="headerlink" title="Sentinel 控制台"></a>Sentinel 控制台</h3><p>Sentinel 控制台提供的功能如下:</p>
<ul>
<li><strong>查看机器列表以及健康情况</strong>：Sentinel 控制台能够收集 Sentinel 客户端发送的心跳包，判断机器是否在线。</li>
<li><strong>监控（单机和集群聚合）</strong>：Sentinel 控制台通过 Sentinel 客户端暴露的监控 API，可以实现秒级的实时监控。</li>
<li><strong>规则管理和推送</strong>：通过 Sentinel 控制台，我们还能够针对资源定义和推送规则。</li>
<li><strong>鉴权</strong>：从 Sentinel 1.6.0 起，Sentinel 控制台引入基本的登录功能，默认用户名和密码都是 sentinel。</li>
</ul>
<h3 id="Sentinel-的开发流程"><a href="#Sentinel-的开发流程" class="headerlink" title="Sentinel 的开发流程"></a>Sentinel 的开发流程</h3><p>Sentinel 的开发流程如下：</p>
<ol>
<li><strong>引入 Sentinel 依赖</strong>：在项目中引入 Sentinel 的依赖，将 Sentinel 整合到项目中；</li>
<li><strong>定义资源</strong>：通过对主流框架提供适配或 Sentinel 提供的显式 API 和注解，可以定义需要保护的资源，此外 Sentinel 还提供了资源的实时统计和调用链路分析；</li>
<li><strong>定义规则</strong>：根据实时统计信息，对资源定义规则，例如流控规则、熔断规则、热点规则、系统规则以及授权规则等。</li>
<li><strong>检验规则是否在生效</strong>：运行程序，检验规则是否生效，查看效果。</li>
</ol>
<h3 id="引入-Sentinel-依赖"><a href="#引入-Sentinel-依赖" class="headerlink" title="引入 Sentinel 依赖"></a>引入 Sentinel 依赖</h3><p>以 Spring Cloud 为例，我们只需要引入 spring-cloud-starter-alibaba-sentinel 的依赖，就可以方便地将 Sentinel 整合到项目中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Nacos 服务发现依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Snetinel 依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span> <span class="comment">#端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sentinel-service</span> <span class="comment">#服务名</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#Nacos服务注册中心(集群)地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:1111</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="comment">#配置 Sentinel dashboard 地址</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment">#默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="定义资源"><a href="#定义资源" class="headerlink" title="定义资源"></a>定义资源</h3><p>资源是 Sentinel 中的核心概念之一。在项目开发时，我们只需要考虑这个服务、方法或代码是否需要保护，如果需要保护，就可以将它定义为一个资源。</p>
<p>Sentinel 为我们提供了多种定义资源的方式：</p>
<ul>
<li>适配主流框架自动定义资源</li>
<li>通过 SphU 手动定义资源</li>
<li>通过 SphO 手动定义资源</li>
<li>注解方式定义资源</li>
</ul>
<h4 id="适配主流框架自动定义资源"><a href="#适配主流框架自动定义资源" class="headerlink" title="适配主流框架自动定义资源"></a>适配主流框架自动定义资源</h4><p>Sentinel 对大部分的主流框架都进行了适配，我们只要引入相关的适配模块（例如 spring-cloud-starter-alibaba-sentinel），Snetinel 就会自动将项目中的服务（包括调用端和服务端）定义为资源，资源名就是服务的请求路径。此时，我们只要再定义一些规则，这些资源就可以享受到 Sentinel 的保护。</p>
<h4 id="通过-SphU-手动定义资源"><a href="#通过-SphU-手动定义资源" class="headerlink" title="通过 SphU 手动定义资源"></a>通过 SphU 手动定义资源</h4><p>Sentinel 提供了一个名为 SphU 的类，它包含的 try-catch 风格的 API ，可以帮助我们手动定义资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 SphU 手动定义资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testAbySphU</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            entry = SphU.entry(<span class="string">&quot;testAbySphU&quot;</span>);</span><br><span class="line">            <span class="comment">//您的业务逻辑 - 开始</span></span><br><span class="line">            log.info(<span class="string">&quot;c语言中文网提醒您，服务访问成功------testA：&quot;</span>+serverPort);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，服务访问成功------testA：&quot;</span>+serverPort;</span><br><span class="line">            <span class="comment">//您的业务逻辑 - 结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException e1) &#123;</span><br><span class="line">            <span class="comment">//流控逻辑处理 - 开始</span></span><br><span class="line">            log.info(<span class="string">&quot;c语言中文网提醒您，testA 服务被限流&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，testA 服务被限流&quot;</span>;</span><br><span class="line">            <span class="comment">//流控逻辑处理 - 结束</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                entry.exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过-SphO-手动定义资源"><a href="#通过-SphO-手动定义资源" class="headerlink" title="通过 SphO 手动定义资源"></a>通过 SphO 手动定义资源</h4><p>Sentinel 还提供了一个名为 SphO 的类，它包含了 if-else 风格的 API，能帮助我们手动定义资源。通过这种方式定义的资源，发生了限流之后会返回 false，此时我们可以根据返回值，进行限流之后的逻辑处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过 SphO 手动定义资源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testBbySphO</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (SphO.entry(<span class="string">&quot;testBbySphO&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 务必保证finally会被执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;c语言中文网提醒您，服务访问成功------testB：&quot;</span> + serverPort);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，服务访问成功------testB：&quot;</span> + serverPort;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                SphO.exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 资源访问阻止，被限流或被降级</span></span><br><span class="line">            <span class="comment">//流控逻辑处理 - 开始</span></span><br><span class="line">            log.info(<span class="string">&quot;c语言中文网提醒您，testB 服务被限流&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，testB 服务被限流&quot;</span>;</span><br><span class="line">            <span class="comment">//流控逻辑处理 - 结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="注解方式定义资源（推荐）"><a href="#注解方式定义资源（推荐）" class="headerlink" title="注解方式定义资源（推荐）"></a>注解方式定义资源（推荐）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testC&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testCbyAnnotation&quot;)</span> <span class="comment">//通过注解定义资源</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testC</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;c语言中文网提醒您，服务访问成功------testC：&quot;</span> + serverPort);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，服务访问成功------testC：&quot;</span> + serverPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sentinel-流量控制"><a href="#Sentinel-流量控制" class="headerlink" title="Sentinel 流量控制"></a>Sentinel 流量控制</h3><p>任何系统处理请求的能力都是有限的，但任意时间内到达系统的请求量往往是随机且不可控的，如果在某一个瞬时时刻请求量急剧增，那么系统就很有可能被瞬时的流量高峰冲垮。为了避免此类情况发生，我们都需要根据系统的处理能力对请求流量进行控制，这就是我们常说的“流量控制”，简称“流控”。</p>
<p>Sentinel 作为一种轻量级高可用流量控制组件，流量控制是它最主要的工作之一。</p>
<p>我们可以针对资源定义流控规则，Sentinel 会根据这些规则对流量相关的各项指标进行监控。当这些指标当达到或超过流控规则规定的阈值时，Sentinel 会对请求的流量进行限制（即“限流”），以避免系统被瞬时的流量高峰冲垮，保障系统的高可用性。</p>
<p>一条流量规则主要由下表中的属性组成，我们可以通过组合这些属性来实现不同的限流效果。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>资源名</td>
<td>流控规则的作用对象。</td>
<td>-</td>
</tr>
<tr>
<td>阈值</td>
<td>流控的阈值。</td>
<td>-</td>
</tr>
<tr>
<td>阈值类型</td>
<td>流控阈值的类型，包括 QPS 或并发线程数。</td>
<td>QPS</td>
</tr>
<tr>
<td>针对来源</td>
<td>流控针对的调用来源。</td>
<td>default，表示不区分调用来源</td>
</tr>
<tr>
<td>流控模式</td>
<td>调用关系限流策略，包括直接、链路和关联。</td>
<td>直接</td>
</tr>
<tr>
<td>流控效果</td>
<td>流控效果（直接拒绝、Warm Up、匀速排队），不支持按调用关系限流。</td>
<td>直接拒绝</td>
</tr>
</tbody></table>
<blockquote>
<p>注：QPS 表示并发请求数，换句话说就是，每秒钟最多通过的请求数。</p>
</blockquote>
<p>同一个资源可以创建多条流控规则，Sentinel 会遍历这些规则，直到有规则触发限流或者所有规则遍历完毕为止。</p>
<p>Sentinel 触发限流时，资源会抛出 BlockException 异常，此时我们可以捕捉 BlockException 来自定义被限流之后的处理逻辑。</p>
<h4 id="通过-Sentinel-控制台定义流控规则"><a href="#通过-Sentinel-控制台定义流控规则" class="headerlink" title="通过 Sentinel 控制台定义流控规则"></a>通过 Sentinel 控制台定义流控规则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过 Sentinel 控制台定义流控规则</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/testD&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testD</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;c语言中文网提醒您，服务访问成功------testD：&quot;</span> + serverPort);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，服务访问成功------testD：&quot;</span> + serverPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用浏览器访问“<a href="http://localhost:8080”，登陆">http://localhost:8080”，登陆</a> Sentinel 控制台主页，点击 sentinel-sevice 下的“簇点链路”，</p>
<p>若页面中出现以上信息，则说明该服务已被限流，但这种提示是 Sentinel 系统自动生成的，用户体验不好。</p>
<p>在服务代码中使用 @SentinelResource 注解定义资源名称，并在 blockHandler 属性指定一个限流函数，自定义服务限流信息，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过 Sentinel 控制台定义流控规则</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/testD&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testD-resource&quot;, blockHandler = &quot;blockHandlerTestD&quot;)</span> <span class="comment">//通过注解定义资源</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testD</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;c语言中文网提醒您，服务访问成功------testD：&quot;</span> + serverPort);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，服务访问成功------testD：&quot;</span> + serverPort;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 限流之后的逻辑</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">blockHandlerTestD</span><span class="params">(BlockException exception)</span> &#123;</span><br><span class="line">    log.info(Thread.currentThread().getName() + <span class="string">&quot;c语言中文网提醒您，TestD服务访问失败! 您已被限流，请稍后重试&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，TestD服务访问失败! 您已被限流，请稍后重试&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，我们通过 @SentinelResource 注解的 blockHandler 属性指定了一个 blockHandler 函数，进行限流之后的后续处理。</p>
<p> 使用 @SentinelResource 注解的 blockHandler 属性时，需要注意以下事项：</p>
<ul>
<li>blockHandler 函数访问范围需要是 public；</li>
<li>返回类型需要与原方法相匹配；</li>
<li>参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException；</li>
<li>blockHandler 函数默认需要和原方法在同一个类中，若希望使用其他类的函数，则可以指定 blockHandler 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</li>
<li>请务必添加 blockHandler 属性来指定自定义的限流处理方法，若不指定，则会跳转到错误页（用户体验不好）。</li>
</ul>
<h4 id="通过代码定义流控规则"><a href="#通过代码定义流控规则" class="headerlink" title="通过代码定义流控规则"></a>通过代码定义流控规则</h4><p>我们还可以在服务代码中，调用 <strong>FlowRuleManager 类的 loadRules() 方法来定义流控规则</strong>，该方法需要一个 FlowRule 类型的 List 集合作为其参数，示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadRules</span><span class="params">(List&lt;FlowRule&gt; rules)</span> &#123;</span><br><span class="line">    currentProperty.updateValue(rules); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FlowRule 可以通过以下属性定义流控规则，如下表。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>resource</td>
<td>资源名，即流控规则的作用对象</td>
<td>-</td>
</tr>
<tr>
<td>count</td>
<td>限流的阈值。</td>
<td>-</td>
</tr>
<tr>
<td>grade</td>
<td>流控阈值的类型，包括 QPS 或并发线程数</td>
<td>QPS</td>
</tr>
<tr>
<td>limitApp</td>
<td>流控针对的调用来源</td>
<td>default，表示不区分调用来源</td>
</tr>
<tr>
<td>strategy</td>
<td>调用关系限流策略，包括直接、链路和关联</td>
<td>直接</td>
</tr>
<tr>
<td>controlBehavior</td>
<td>流控效果（直接拒绝、Warm Up、匀速排队），不支持按调用关系限流</td>
<td>直接拒绝</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过代码定义流量控制规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initFlowRules</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;FlowRule&gt; rules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//定义一个限流规则对象</span></span><br><span class="line">    <span class="type">FlowRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlowRule</span>();</span><br><span class="line">    <span class="comment">//资源名称</span></span><br><span class="line">    rule.setResource(<span class="string">&quot;testD-resource&quot;</span>);</span><br><span class="line">     <span class="comment">//限流阈值的类型</span></span><br><span class="line">    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    <span class="comment">// 设置 QPS 的阈值为 2</span></span><br><span class="line">    rule.setCount(<span class="number">2</span>);</span><br><span class="line">    rules.add(rule);</span><br><span class="line">    <span class="comment">//定义限流规则</span></span><br><span class="line">    FlowRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/testD&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testD-resource&quot;, blockHandler = &quot;blockHandlerTestD&quot;)</span> <span class="comment">//通过注解定义资源</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testD</span><span class="params">()</span> &#123;</span><br><span class="line">    initFlowRules(); <span class="comment">//调用初始化流控规则的方法</span></span><br><span class="line">    log.info(<span class="string">&quot;c语言中文网提醒您，服务访问成功------testD：&quot;</span> + serverPort);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;c语言中文网提醒您，服务访问成功------testD：&quot;</span> + serverPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="熔断降级规则"><a href="#熔断降级规则" class="headerlink" title="熔断降级规则"></a>熔断降级规则</h3><p>Sentinel 的熔断将机制会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），暂时切断对这个资源的调用，以避免局部不稳定因素导致整个系统的雪崩。</p>
<p>熔断降级作为服务保护自身的手段，通常在客户端（调用端）进行配置，资源被熔断降级最直接的表现就是抛出 DegradeException 异常。</p>
<h4 id="Sentinel-熔断策略"><a href="#Sentinel-熔断策略" class="headerlink" title="Sentinel 熔断策略"></a>Sentinel 熔断策略</h4><table>
<thead>
<tr>
<th>熔断策略</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>慢调用比例 (SLOW_REQUEST_RATIO）</td>
<td>选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大响应时间），若请求的响应时间大于该值则统计为慢调用。  当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。  经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则再次被熔断。</td>
</tr>
<tr>
<td>异常比例 (ERROR_RATIO)</td>
<td>当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目且异常的比例大于阈值，则在接下来的熔断时长内请求会自动被熔断。  经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</td>
</tr>
<tr>
<td>异常数 (ERROR_COUNT)</td>
<td>当单位统计时长内的异常数目超过阈值之后会自动进行熔断。  经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</td>
</tr>
</tbody></table>
<h4 id="Sentinel-熔断状态"><a href="#Sentinel-熔断状态" class="headerlink" title="Sentinel 熔断状态"></a>Sentinel 熔断状态</h4><p>![image-20220913112004206](Spring Cloud 微服务.assets&#x2F;image-20220913112004206.png)</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>熔断关闭状态 （CLOSED）</td>
<td>处于关闭状态时，请求可以正常调用资源。</td>
<td>满足以下任意条件，Sentinel 熔断器进入熔断关闭状态：全部请求访问成功。单位统计时长（statIntervalMs）内请求数目小于设置的最小请求数目。未达到熔断标准，例如服务超时比例、异常数、异常比例未达到阈值。处于探测恢复状态时，下一个请求访问成功。</td>
</tr>
<tr>
<td>熔断开启状态 （OPEN）</td>
<td>处于熔断开启状态时，熔断器会一定的时间（规定的熔断时长）内，暂时切断所有请求对该资源的调用，并调用相应的降级逻辑使请求快速失败避免系统崩溃。</td>
<td>满足以下任意条件，Sentinel 熔断器进入熔断开启状态：单位统计时长内请求数目大于设置的最小请求数目，且已达到熔断标准，例如请求超时比例、异常数、异常比例达到阈值。处于探测恢复状态时，下一个请求访问失败。</td>
</tr>
<tr>
<td>探测恢复状态 （HALF-OPEN）</td>
<td>处于探测恢复状态时，Sentinel 熔断器会允许一个请求调用资源。则若接下来的一个请求成功完成（没有错误）则结束熔断，熔断器进入熔断关闭（CLOSED）状态；否则会再次被熔断，熔断器进入熔断开启（OPEN）状态。</td>
<td>在熔断开启一段时间（降级窗口时间或熔断时长，单位为 s）后，Sentinel 熔断器自动会进入探测恢复状态。</td>
</tr>
</tbody></table>
<h4 id="Sentinel-熔断规则属性"><a href="#Sentinel-熔断规则属性" class="headerlink" title="Sentinel 熔断规则属性"></a>Sentinel 熔断规则属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>默认值</th>
<th>使用范围</th>
</tr>
</thead>
<tbody><tr>
<td>资源名</td>
<td>规则的作用对象。</td>
<td>-</td>
<td>所有熔断策略</td>
</tr>
<tr>
<td>熔断策略</td>
<td>Sentinel 支持3 中熔断策略：慢调用比例、异常比例、异常数策略。</td>
<td>慢调用比例</td>
<td>所有熔断策略</td>
</tr>
<tr>
<td>最大 RT</td>
<td>请求的最大相应时间，请求的响应时间大于该值则统计为慢调用。</td>
<td>-</td>
<td>慢调用比例</td>
</tr>
<tr>
<td>熔断时长</td>
<td>熔断开启状态持续的时间，超过该时间熔断器会切换为探测恢复状态（HALF-OPEN），单位为 s。</td>
<td>-</td>
<td>所有熔断策略</td>
</tr>
<tr>
<td>最小请求数</td>
<td>熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入）。</td>
<td>5</td>
<td>所有熔断策略</td>
</tr>
<tr>
<td>统计时长</td>
<td>熔断触发需要统计的时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）。</td>
<td>1000 ms</td>
<td>所有熔断策略</td>
</tr>
<tr>
<td>比例阈值</td>
<td>分为慢调用比例阈值和异常比例阈值，即慢调用或异常调用占所有请求的百分比，取值范围 [0.0,1.0]。</td>
<td>-</td>
<td>慢调用比例 、异常比例</td>
</tr>
<tr>
<td>异常数</td>
<td>请求或调用发生的异常的数量。</td>
<td>-</td>
<td>异常数</td>
</tr>
</tbody></table>
<h4 id="Sentinel-实现熔断降级过程"><a href="#Sentinel-实现熔断降级过程" class="headerlink" title="Sentinel 实现熔断降级过程"></a>Sentinel 实现熔断降级过程</h4><p>Sentinel 实现熔断降级的步骤如下：</p>
<ol>
<li>在项目中，使用 @SentinelResource 注解的 fallback 属性可以为资源指定熔断降级逻辑（方法）。</li>
<li>通过 Sentinel 控制台或代码定义熔断规则，包括熔断策略、最小请求数、阈值、熔断时长以及统计时长等。</li>
<li>若单位统计时长（statIntervalMs）内，请求数目大于设置的最小请求数目且达到熔断标准（例如请求超时比例、异常数、异常比例达到阈值），Sentinel 熔断器进入熔断开启状态（OPEN）。</li>
<li>处于熔断开启状态时， @SentinelResource 注解的 fallback 属性指定的降级逻辑会临时充当主业务逻辑，而原来的主逻辑则暂时不可用。当有请求访问该资源时，会直接调用降级逻辑使请求快速失败，而不会调用原来的主业务逻辑。</li>
<li>在经过一段时间（在熔断规则中设置的熔断时长）后，熔断器会进入探测恢复状态（HALF-OPEN），此时 Sentinel 会允许一个请求对原来的主业务逻辑进行调用，并监控其调用结果。</li>
<li>若请求调用成功，则熔断器进入熔断关闭状态（CLOSED ），服务原来的主业务逻辑恢复，否则重新进入熔断开启状态（OPEN）。</li>
</ol>
<h4 id="通过-Sentinel-控制台定义熔断降级规则"><a href="#通过-Sentinel-控制台定义熔断降级规则" class="headerlink" title="通过 Sentinel 控制台定义熔断降级规则"></a>通过 Sentinel 控制台定义熔断降级规则</h4><p>我们可以通过 Sentinel 控制台直接对资源定义熔断降级规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeptFeignController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    DeptFeignService deptFeignService;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;consumer/feign/dept/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;fallback&quot;, fallback = &quot;handlerFallback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Dept&gt; <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        monitor();</span><br><span class="line">        System.out.println(<span class="string">&quot;---------&gt;&gt;&gt;&gt;主业务逻辑&quot;</span>);</span><br><span class="line">        CommonResult&lt;Dept&gt; result = deptFeignService.get(id);</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">6</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;---------&gt;&gt;&gt;&gt;主业务逻辑，抛出非法参数异常&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;IllegalArgumentException，非法参数异常....&quot;</span>);</span><br><span class="line">            <span class="comment">//如果查到的记录也是 null 也控制正异常</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;---------&gt;&gt;&gt;&gt;主业务逻辑，抛出空指针异常&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;NullPointerException，该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;consumer/feign/dept/list&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;List&lt;Dept&gt;&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deptFeignService.list();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理异常的回退方法（服务降级）</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">handlerFallback</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id, Throwable e)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;---------&gt;&gt;&gt;&gt;服务降级逻辑&quot;</span>);</span><br><span class="line">        <span class="type">Dept</span> <span class="variable">dept</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dept</span>(id, <span class="string">&quot;null&quot;</span>, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">444</span>, <span class="string">&quot;C语言中文网提醒您，服务被降级！异常信息为：&quot;</span> + e.getMessage(), dept);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义事件监听器，监听熔断器状态转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">monitor</span><span class="params">()</span> &#123;</span><br><span class="line">        EventObserverRegistry.getInstance().addStateChangeObserver(<span class="string">&quot;logging&quot;</span>,</span><br><span class="line">                (prevState, newState, rule, snapshotValue) -&gt; &#123;</span><br><span class="line">                    <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (newState == CircuitBreaker.State.OPEN) &#123;</span><br><span class="line">                        <span class="comment">// 变换至 OPEN state 时会携带触发时的值</span></span><br><span class="line">                        System.err.println(String.format(<span class="string">&quot;%s -&gt; OPEN at %s, 发送请求次数=%.2f&quot;</span>, prevState.name(),</span><br><span class="line">                                format.format(<span class="keyword">new</span> <span class="title class_">Date</span>(TimeUtil.currentTimeMillis())), snapshotValue));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.err.println(String.format(<span class="string">&quot;%s -&gt; %s at %s&quot;</span>, prevState.name(), newState.name(),</span><br><span class="line">                                format.format(<span class="keyword">new</span> <span class="title class_">Date</span>(TimeUtil.currentTimeMillis()))));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 @SentinelResource 注解的 blockHandler 属性时，需要注意以下事项：</p>
<ul>
<li>返回值类型必须与原函数返回值类型一致；</li>
<li>方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常；</li>
<li>fallback 函数默认需要和原方法在同一个类中，若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。</li>
</ul>
<p>使用浏览器访问 Sentinel 控制台，在“簇点链路”列表中，点击 fallback 资源的 “**+**熔断”按钮，</p>
<h4 id="通过代码定义熔断规则"><a href="#通过代码定义熔断规则" class="headerlink" title="通过代码定义熔断规则"></a>通过代码定义熔断规则</h4><p>Sentinel 核心库中提供了的一个名为 DegradeRuleManager 类，我们可以通过调用它的 loadRules() 方法来定义熔断降级规则，该方法需要一个 DegradeRule 类型的 List 参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadRules</span><span class="params">(List&lt;DegradeRule&gt; rules)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        currentProperty.updateValue(rules);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var2) &#123;</span><br><span class="line">        RecordLog.error(<span class="string">&quot;[DegradeRuleManager] Unexpected error when loading degrade rules&quot;</span>, var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DegradeRule 类可以用来定义一条熔断规则，它包含多个与熔断规则相关的属性，如下表。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>resource</td>
<td>资源名，即规则的作用对象</td>
<td></td>
</tr>
<tr>
<td>grade</td>
<td>熔断策略，支持慢调用比例&#x2F;异常比例&#x2F;异常数策略</td>
<td>慢调用比例</td>
</tr>
<tr>
<td>count</td>
<td>慢调用比例模式下为慢调用临界 RT（超出该值计为慢调用）；异常比例&#x2F;异常数模式下为对应的阈值</td>
<td></td>
</tr>
<tr>
<td>timeWindow</td>
<td>熔断时长，单位为 s</td>
<td></td>
</tr>
<tr>
<td>minRequestAmount</td>
<td>熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入）</td>
<td>5</td>
</tr>
<tr>
<td>statIntervalMs</td>
<td>统计时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）</td>
<td>1000 ms</td>
</tr>
<tr>
<td>slowRatioThreshold</td>
<td>慢调用比例阈值，仅慢调用比例模式有效（1.8.0 引入）</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化熔断策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initDegradeRule</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;DegradeRule&gt; rules = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">DegradeRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DegradeRule</span>(<span class="string">&quot;fallback&quot;</span>);</span><br><span class="line">    <span class="comment">//熔断策略为异常比例</span></span><br><span class="line">    rule.setGrade(CircuitBreakerStrategy.ERROR_RATIO.getType());</span><br><span class="line">    <span class="comment">//异常比例阈值</span></span><br><span class="line">    rule.setCount(<span class="number">0.7</span>);</span><br><span class="line">    <span class="comment">//最小请求数</span></span><br><span class="line">    rule.setMinRequestAmount(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">//统计市场，单位毫秒</span></span><br><span class="line">    rule.setStatIntervalMs(<span class="number">30000</span>);</span><br><span class="line">    <span class="comment">//熔断市场，单位秒</span></span><br><span class="line">    rule.setTimeWindow(<span class="number">10</span>);</span><br><span class="line">    rules.add(rule);</span><br><span class="line">    DegradeRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;consumer/feign/dept/get/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;fallback&quot;, fallback = &quot;handlerFallback&quot;)</span></span><br><span class="line"><span class="keyword">public</span> CommonResult&lt;Dept&gt; <span class="title function_">get</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">    initDegradeRule();</span><br><span class="line">    monitor();</span><br><span class="line">    System.out.println(<span class="string">&quot;---------&gt;&gt;&gt;&gt;主业务逻辑&quot;</span>);</span><br><span class="line">    CommonResult&lt;Dept&gt; result = deptFeignService.get(id);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">6</span>) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;---------&gt;&gt;&gt;&gt;主业务逻辑，抛出非法参数异常&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;IllegalArgumentException，非法参数异常....&quot;</span>);</span><br><span class="line">        <span class="comment">//如果查到的记录也是 null 也控制正异常</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.getData() == <span class="literal">null</span>) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;---------&gt;&gt;&gt;&gt;主业务逻辑，抛出空指针异常&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;NullPointerException，该ID没有对应记录,空指针异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Nacos：Spring-Cloud-Alibaba服务注册与配置中心"><a href="#Nacos：Spring-Cloud-Alibaba服务注册与配置中心" class="headerlink" title="Nacos：Spring Cloud Alibaba服务注册与配置中心"></a>Nacos：Spring Cloud Alibaba服务注册与配置中心</h2><p>Nacos 是一个更易于帮助构建云原生应用的动态服务发现、配置和服务管理平台</p>
<p>Nacos 英文全称为 Dynamic Naming and Configuration Service，是一个由阿里巴巴团队使用 Java 语言开发的开源项目</p>
<table>
<thead>
<tr>
<th>组成部分</th>
<th>全称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Na</td>
<td>naming&#x2F;nameServer</td>
<td>即服务注册中心，与 Spring Cloud Eureka 的功能类似。</td>
</tr>
<tr>
<td>co</td>
<td>configuration</td>
<td>即配置中心，与 Spring Cloud Config+Spring Cloud Bus 的功能类似。</td>
</tr>
<tr>
<td>s</td>
<td>service</td>
<td>即服务，表示 Nacos 实现的服务注册中心和配置中心都是以服务为核心的。</td>
</tr>
</tbody></table>
<p>我们可以将 Nacos 理解成服务注册中心和配置中心的组合体，它可以替换 <a target="_blank" rel="noopener" href="http://c.biancheng.net/springcloud/eureka.html">Eureka</a> 作为服务注册中心，实现服务的注册与发现；还可以替换 <a target="_blank" rel="noopener" href="http://c.biancheng.net/springcloud/config.html">Spring Cloud Config</a> 作为配置中心，实现配置的动态刷新。</p>
<h3 id="Nacos-的特性"><a href="#Nacos-的特性" class="headerlink" title="Nacos 的特性"></a>Nacos 的特性</h3><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><h4 id="服务健康监测"><a href="#服务健康监测" class="headerlink" title="服务健康监测"></a>服务健康监测</h4><h4 id="动态配置服务"><a href="#动态配置服务" class="headerlink" title="动态配置服务"></a>动态配置服务</h4><h4 id="动态-DNS-服务"><a href="#动态-DNS-服务" class="headerlink" title="动态 DNS 服务"></a>动态 DNS 服务</h4><h4 id="服务及其元数据管理"><a href="#服务及其元数据管理" class="headerlink" title="服务及其元数据管理"></a>服务及其元数据管理</h4><h3 id="Nacos-两大组件"><a href="#Nacos-两大组件" class="headerlink" title="Nacos 两大组件"></a>Nacos 两大组件</h3><p>![image-20220913113350951](Spring Cloud 微服务.assets&#x2F;image-20220913113350951.png)</p>
<h3 id="Nacos-服务注册中心"><a href="#Nacos-服务注册中心" class="headerlink" title="Nacos 服务注册中心"></a>Nacos 服务注册中心</h3><img src="/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220913113408462.png" alt="image-20220913113408462" style="zoom:67%;">

<p>在图 1 中共涉及到以下 3 个角色：</p>
<ul>
<li>服务注册中心（Register Service）：它是一个 Nacos Server，可以为服务提供者和服务消费者提供服务注册和发现功能。</li>
<li>服务提供者（Provider Service）：它是一个 Nacos Client，用于对外服务。它将自己提供的服务注册到服务注册中心，以供服务消费者发现和调用。</li>
<li>服务消费者（Consumer Service）：它是一个 Nacos Client，用于消费服务。它可以从服务注册中心获取服务列表，调用所需的服务。</li>
</ul>
<p>Nacos 实现服务注册与发现的流程如下：</p>
<ol>
<li>从 Nacos 官方提供的下载页面中，下载 Nacos Server 并运行。</li>
<li>服务提供者 Nacos Client 启动时，会把服务以服务名（spring.application.name）的方式注册到服务注册中心（Nacos Server）；</li>
<li>服务消费者 Nacos Client 启动时，也会将自己的服务注册到服务注册中心；</li>
<li>服务消费者在注册服务的同时，它还会从服务注册中心获取一份服务注册列表信息，该列表中包含了所有注册到服务注册中心上的服务的信息（包括服务提供者和自身的信息）；</li>
<li>在获取了服务提供者的信息后，服务消费者通过 HTTP 或消息中间件远程调用服务提供者提供的服务。</li>
</ol>
<h4 id="搭建服务提供者"><a href="#搭建服务提供者" class="headerlink" title="搭建服务提供者"></a>搭建服务提供者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//开启服务发现功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringCloudAlibabaProvider8001Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringCloudAlibabaProvider8001Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="搭建服务消费者"><a href="#搭建服务消费者" class="headerlink" title="搭建服务消费者"></a>搭建服务消费者</h4><p> ApplicationContextBean 的配置类，并使用 @LoadBalanced 注解与 Ribbon 进行集成开启负载均衡功能，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextBean</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">//与 Ribbon 集成，并开启负载均衡功能</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">getRestTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Nacos-配置中心"><a href="#Nacos-配置中心" class="headerlink" title="Nacos 配置中心"></a>Nacos 配置中心</h3><p>Nacos Server 还可以作为配置中心，对 Spring Cloud 应用的外部配置进行统一地集中化管理。而我们只需要在应用的 POM 文件中引入 spring-cloud-starter-alibaba-nacos-config 即可实现配置的获取与动态刷新。</p>
<p>创建一个名为 ConfigClientController 的 Controller 类，并在该类上使用 @RefreshScope 注解实现配置的自动更新，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigClientController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;config.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ConfigInfo;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config/info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ConfigInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主启动类上，使用 @EnableDiscoveryClient 注解开启服务发现功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringCloudAlibabaNacosConfigClient3377Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SpringCloudAlibabaNacosConfigClient3377Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Nacos Server 中，配置的 dataId（即 Data ID）的完整格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</span><br></pre></td></tr></table></figure>

<p>dataId 格式中各参数说明如下：</p>
<ul>
<li>${prefix}：默认取值为微服务的服务名，即配置文件中 spring.application.name 的值，我们可以在配置文件中通过配置 spring.cloud.nacos.config.prefix 来指定。</li>
<li>${spring.profiles.active}：表示当前环境对应的 Profile，例如 dev、test、prod 等。当没有指定环境的 Profile 时，其对应的连接符也将不存在， dataId 的格式变成 ${prefix}.${file-extension}。</li>
<li>${file-extension}：表示配置内容的数据格式，我们可以在配置文件中通过配置项 spring.cloud.nacos.config.file-extension 来配置，例如 properties 和 yaml。</li>
</ul>
<h3 id="Nacos-Server-集群化部署"><a href="#Nacos-Server-集群化部署" class="headerlink" title="Nacos Server 集群化部署"></a>Nacos Server 集群化部署</h3><p>Nacos Server 的集群化部署有一个十分明显的优点，那就是可以保障系统的高可用性。在集群化部署中，只要不是所有的 Nacos Server 都停止工作，Nacos Client 就还可以从集群中正常的 Nacos Server 上获取服务信息及配置，而不会导致系统的整体瘫痪，这就是 Nacos Server 集群化部署的高可用性。</p>
<img src="/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220913113956551.png" alt="image-20220913113956551" style="zoom:67%;">

<h2 id="Seata：Spring-Cloud-Alibaba分布式事务组件"><a href="#Seata：Spring-Cloud-Alibaba分布式事务组件" class="headerlink" title="Seata：Spring Cloud Alibaba分布式事务组件"></a>Seata：Spring Cloud Alibaba分布式事务组件</h2><p>随着业务的不断发展，单体架构已经无法满足我们的需求，分布式微服务架构逐渐成为大型互联网平台的首选，但所有使用分布式微服务架构的应用都必须面临一个十分棘手的问题，那就是“分布式事务”问题。</p>
<p>在分布式微服务架构中，几乎所有业务操作都需要多个服务协作才能完成。对于其中的某个服务而言，它的数据一致性可以交由其自身数据库事务来保证，但从整个分布式微服务架构来看，其全局数据的一致性却是无法保证的。</p>
<p>Seata 就是这样一个分布式事务处理框架，它是由阿里巴巴和蚂蚁金服共同开源的分布式事务解决方案，能够在微服务架构下提供高性能且简单易用的分布式事务服务。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>原创技术分享，您的支持将鼓励我继续创作</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="wFei 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="wFei 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>wFei
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://holdustogether.github.io/2022/09/11/Spring%20Cloud%20%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="Spring Cloud">https://holdustogether.github.io/2022/09/11/Spring Cloud 微服务/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Spring-Cloud/" rel="tag"># Spring Cloud</a>
              <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag"># 微服务</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/01/JVM/" rel="prev" title="JVM随记">
      <i class="fa fa-chevron-left"></i> JVM随记
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/09/12/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/" rel="next" title="面试技巧">
      面试技巧 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">常见面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 什么是微服务？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">2.2 微服务与微服务架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.3.</span> <span class="nav-text">2.3 微服务优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Eureka-Spring-Cloud%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%E7%BB%84%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">Eureka Spring Cloud服务注册与发现组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Eureka-%E4%B8%A4%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="nav-number">2.1.</span> <span class="nav-text">1.Eureka 两大组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Eureka-Server-%E9%9B%86%E7%BE%A4"><span class="nav-number">2.2.</span> <span class="nav-text">2.Eureka Server 集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Eureka-%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-number">2.3.</span> <span class="nav-text">3.Eureka 自我保护机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ribbon%EF%BC%9ASpring-Cloud%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%8E%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E7%BB%84%E4%BB%B6"><span class="nav-number">3.</span> <span class="nav-text">Ribbon：Spring Cloud负载均衡与服务调用组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFRibbon"><span class="nav-number">3.1.</span> <span class="nav-text">1. 什么是Ribbon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">3.2.</span> <span class="nav-text">2.负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">3.2.1.</span> <span class="nav-text">服务端负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">3.2.2.</span> <span class="nav-text">客户端负载均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-VS-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">3.2.3.</span> <span class="nav-text">服务端负载均衡 VS 客户端负载均衡</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Ribbon-%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="nav-number">3.3.</span> <span class="nav-text">3.Ribbon 实现服务调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Ribbon-%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">3.4.</span> <span class="nav-text">4.Ribbon 实现负载均衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%88%87%E6%8D%A2%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="nav-number">3.5.</span> <span class="nav-text">5.切换负载均衡策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%AE%9A%E5%88%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="nav-number">3.6.</span> <span class="nav-text">6.定制负载均衡策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenFeign%EF%BC%9ASpring-Cloud%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E7%BB%84%E4%BB%B6"><span class="nav-number">4.</span> <span class="nav-text">OpenFeign：Spring Cloud声明式服务调用组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFOpenFeign"><span class="nav-number">4.1.</span> <span class="nav-text">1.什么是OpenFeign</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-OpenFeign-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="nav-number">4.2.</span> <span class="nav-text">2.OpenFeign 常用注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Feign-VS-OpenFeign"><span class="nav-number">4.3.</span> <span class="nav-text">3.Feign VS OpenFeign</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="nav-number">4.3.1.</span> <span class="nav-text">相同点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="nav-number">4.3.2.</span> <span class="nav-text">不同点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-OpenFeign-%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8"><span class="nav-number">4.4.</span> <span class="nav-text">4.OpenFeign 实现远程服务调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-OpenFeign-%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6"><span class="nav-number">4.5.</span> <span class="nav-text">5.OpenFeign 超时控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-OpenFeign-%E6%97%A5%E5%BF%97%E5%A2%9E%E5%BC%BA"><span class="nav-number">4.6.</span> <span class="nav-text">6.OpenFeign 日志增强</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hystrix%EF%BC%9ASpring-Cloud%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%8D%E7%BA%A7%E7%BB%84%E4%BB%B6"><span class="nav-number">5.</span> <span class="nav-text">Hystrix：Spring Cloud服务熔断与降级组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%86%94%E6%96%AD%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">1.熔断器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Spring-Cloud-Hystrix"><span class="nav-number">5.2.</span> <span class="nav-text">2.Spring Cloud Hystrix</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Hystrix-%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="nav-number">5.3.</span> <span class="nav-text">3.Hystrix 服务降级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="nav-number">5.3.1.</span> <span class="nav-text">3.1服务端服务降级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="nav-number">5.3.2.</span> <span class="nav-text">3.2客户端服务降级</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%85%A8%E5%B1%80%E9%99%8D%E7%BA%A7%E6%96%B9%E6%B3%95"><span class="nav-number">5.4.</span> <span class="nav-text">4.全局降级方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%A7%A3%E8%80%A6%E9%99%8D%E7%BA%A7%E9%80%BB%E8%BE%91"><span class="nav-number">5.5.</span> <span class="nav-text">5.解耦降级逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Hystrix-%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD"><span class="nav-number">5.6.</span> <span class="nav-text">6.Hystrix 服务熔断</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%86%94%E6%96%AD%E7%8A%B6%E6%80%81"><span class="nav-number">5.6.1.</span> <span class="nav-text">熔断状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hystrix-%E5%AE%9E%E7%8E%B0%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="nav-number">5.6.2.</span> <span class="nav-text">Hystrix 实现熔断机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Hystrix-%E6%95%85%E9%9A%9C%E7%9B%91%E6%8E%A7"><span class="nav-number">5.7.</span> <span class="nav-text">7.Hystrix 故障监控</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gateway%EF%BC%9ASpring-Cloud-API%E7%BD%91%E5%85%B3%E7%BB%84%E4%BB%B6"><span class="nav-number">6.</span> <span class="nav-text">Gateway：Spring Cloud API网关组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#API-%E7%BD%91%E5%85%B3"><span class="nav-number">6.1.</span> <span class="nav-text">API 网关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Cloud-Gateway"><span class="nav-number">6.2.</span> <span class="nav-text">Spring Cloud Gateway</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Cloud-Gateway-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">6.2.1.</span> <span class="nav-text">Spring Cloud Gateway 核心概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-Cloud-Gateway-%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-number">6.2.2.</span> <span class="nav-text">Spring Cloud Gateway 的特征</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gateway-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">6.3.</span> <span class="nav-text">Gateway 的工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Predicate-%E6%96%AD%E8%A8%80"><span class="nav-number">6.4.</span> <span class="nav-text">Predicate 断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Cloud-Gateway-%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1"><span class="nav-number">6.5.</span> <span class="nav-text">Spring Cloud Gateway 动态路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Filter-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">6.6.</span> <span class="nav-text">Filter 过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Filter-%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">6.6.1.</span> <span class="nav-text">Filter 的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GatewayFilter-%E7%BD%91%E5%85%B3%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">6.6.2.</span> <span class="nav-text">GatewayFilter 网关过滤器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GlobalFilter-%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">6.6.3.</span> <span class="nav-text">GlobalFilter 全局过滤器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sentinel%EF%BC%9ASpring-Cloud-Alibaba%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%BB%84%E4%BB%B6"><span class="nav-number">7.</span> <span class="nav-text">Sentinel：Spring Cloud Alibaba高可用流量控制组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel-%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">7.1.</span> <span class="nav-text">Sentinel 的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">7.2.</span> <span class="nav-text">Sentinel 的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SentinelResource-%E6%B3%A8%E8%A7%A3"><span class="nav-number">7.3.</span> <span class="nav-text">@SentinelResource 注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel-%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="nav-number">7.4.</span> <span class="nav-text">Sentinel 控制台</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel-%E7%9A%84%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="nav-number">7.5.</span> <span class="nav-text">Sentinel 的开发流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%85%A5-Sentinel-%E4%BE%9D%E8%B5%96"><span class="nav-number">7.6.</span> <span class="nav-text">引入 Sentinel 依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90"><span class="nav-number">7.7.</span> <span class="nav-text">定义资源</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E8%87%AA%E5%8A%A8%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90"><span class="nav-number">7.7.1.</span> <span class="nav-text">适配主流框架自动定义资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-SphU-%E6%89%8B%E5%8A%A8%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90"><span class="nav-number">7.7.2.</span> <span class="nav-text">通过 SphU 手动定义资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-SphO-%E6%89%8B%E5%8A%A8%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90"><span class="nav-number">7.7.3.</span> <span class="nav-text">通过 SphO 手动定义资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-number">7.7.4.</span> <span class="nav-text">注解方式定义资源（推荐）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">7.8.</span> <span class="nav-text">Sentinel 流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-Sentinel-%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%AE%9A%E4%B9%89%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99"><span class="nav-number">7.8.1.</span> <span class="nav-text">通过 Sentinel 控制台定义流控规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E5%AE%9A%E4%B9%89%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99"><span class="nav-number">7.8.2.</span> <span class="nav-text">通过代码定义流控规则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E8%A7%84%E5%88%99"><span class="nav-number">7.9.</span> <span class="nav-text">熔断降级规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Sentinel-%E7%86%94%E6%96%AD%E7%AD%96%E7%95%A5"><span class="nav-number">7.9.1.</span> <span class="nav-text">Sentinel 熔断策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sentinel-%E7%86%94%E6%96%AD%E7%8A%B6%E6%80%81"><span class="nav-number">7.9.2.</span> <span class="nav-text">Sentinel 熔断状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sentinel-%E7%86%94%E6%96%AD%E8%A7%84%E5%88%99%E5%B1%9E%E6%80%A7"><span class="nav-number">7.9.3.</span> <span class="nav-text">Sentinel 熔断规则属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sentinel-%E5%AE%9E%E7%8E%B0%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E8%BF%87%E7%A8%8B"><span class="nav-number">7.9.4.</span> <span class="nav-text">Sentinel 实现熔断降级过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-Sentinel-%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%AE%9A%E4%B9%89%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7%E8%A7%84%E5%88%99"><span class="nav-number">7.9.5.</span> <span class="nav-text">通过 Sentinel 控制台定义熔断降级规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E5%AE%9A%E4%B9%89%E7%86%94%E6%96%AD%E8%A7%84%E5%88%99"><span class="nav-number">7.9.6.</span> <span class="nav-text">通过代码定义熔断规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nacos%EF%BC%9ASpring-Cloud-Alibaba%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="nav-number">8.</span> <span class="nav-text">Nacos：Spring Cloud Alibaba服务注册与配置中心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Nacos-%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">8.1.</span> <span class="nav-text">Nacos 的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="nav-number">8.1.1.</span> <span class="nav-text">服务发现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%81%A5%E5%BA%B7%E7%9B%91%E6%B5%8B"><span class="nav-number">8.1.2.</span> <span class="nav-text">服务健康监测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1"><span class="nav-number">8.1.3.</span> <span class="nav-text">动态配置服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81-DNS-%E6%9C%8D%E5%8A%A1"><span class="nav-number">8.1.4.</span> <span class="nav-text">动态 DNS 服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%8A%E5%85%B6%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="nav-number">8.1.5.</span> <span class="nav-text">服务及其元数据管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nacos-%E4%B8%A4%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="nav-number">8.2.</span> <span class="nav-text">Nacos 两大组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nacos-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="nav-number">8.3.</span> <span class="nav-text">Nacos 服务注册中心</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85"><span class="nav-number">8.3.1.</span> <span class="nav-text">搭建服务提供者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">8.3.2.</span> <span class="nav-text">搭建服务消费者</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nacos-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="nav-number">8.4.</span> <span class="nav-text">Nacos 配置中心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nacos-Server-%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2"><span class="nav-number">8.5.</span> <span class="nav-text">Nacos Server 集群化部署</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Seata%EF%BC%9ASpring-Cloud-Alibaba%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%BB%84%E4%BB%B6"><span class="nav-number">9.</span> <span class="nav-text">Seata：Spring Cloud Alibaba分布式事务组件</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wFei"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">wFei</p>
  <div class="site-description" itemprop="description">不要停止成为更好的自己</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/holdustogether" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;holdustogether" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/wf1657885988@163.com" title="E-Mail → wf1657885988@163.com"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
	<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="//music.163.com/outchain/player?type=0&id=7614662893&auto=1&height=430"></iframe>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022.08 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wFei</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共65.1k字</span>
</div>

    <div>
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
    </div>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='128,136,147' opacity='0.8' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

  <!-- ҳ����С���� -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
