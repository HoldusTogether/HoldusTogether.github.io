<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最难不过坚持</title>
      <link href="/2022/08/30/%E6%9C%80%E9%9A%BE%E4%B8%8D%E8%BF%87%E5%9D%9A%E6%8C%81/"/>
      <url>/2022/08/30/%E6%9C%80%E9%9A%BE%E4%B8%8D%E8%BF%87%E5%9D%9A%E6%8C%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文字 </tag>
            
            <tag> 摘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM类加载与字节码技术</title>
      <link href="/2022/08/22/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/08/22/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="1-类的文件结构"><a href="#1-类的文件结构" class="headerlink" title="1. 类的文件结构"></a>1. 类的文件结构</h2><p><img src="/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF.assets/image-20220822145500913.png" alt="image-20220822145500913"></p><h3 id="1-1-魔数"><a href="#1-1-魔数" class="headerlink" title="1.1 魔数"></a>1.1 魔数</h3><hr><p>0~3 字节，表示它是否是【class】类型的文件 </p><p>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</p><span id="more"></span><h3 id="1-2-版本"><a href="#1-2-版本" class="headerlink" title="1.2 版本"></a>1.2 版本</h3><p>4~7 字节，表示类的版本 00 34（52） 表示是 Java 8</p><h3 id="1-3-常量池"><a href="#1-3-常量池" class="headerlink" title="1.3 常量池"></a>1.3 常量池</h3><h3 id="1-4-访问标识与继承信息"><a href="#1-4-访问标识与继承信息" class="headerlink" title="1.4 访问标识与继承信息"></a>1.4 访问标识与继承信息</h3><h3 id="1-5-Field-信息"><a href="#1-5-Field-信息" class="headerlink" title="1.5 Field 信息"></a>1.5 Field 信息</h3><h3 id="1-6-Method-信息"><a href="#1-6-Method-信息" class="headerlink" title="1.6 Method 信息"></a>1.6 Method 信息</h3><p>​表示方法数量，本类为 2</p><p>​0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</p><h3 id="1-7-附加属性"><a href="#1-7-附加属性" class="headerlink" title="1.7 附加属性"></a>1.7 附加属性</h3><p>参考文献</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><h2 id="2-字节码指令"><a href="#2-字节码指令" class="headerlink" title="2. 字节码指令"></a>2. 字节码指令</h2><h3 id="2-1-入门"><a href="#2-1-入门" class="headerlink" title="2.1 入门"></a>2.1 入门</h3><p>接着上一节，研究一下两组字节码指令，一个是</p><p>public cn.itcast.jvm.t5.HelloWorld（）;构造方法的字节码指令</p><ol><li><p>2a &#x3D;&gt; aload_0 加载 slot 0 的局部变量，即 this，做为下面的 invokespecial 构造方法调用的参数</p></li><li><p>b7 &#x3D;&gt; invokespecial 预备调用构造方法，哪个方法呢？</p></li><li><p>00 01 引用常量池中 #1 项，即【Method java&#x2F;lang&#x2F;Object.”“:(）五】</p></li><li><p>b1 表示返回</p></li></ol><p>另一个是 public static void main（java.lang.String[]）;主方法的字节码指令</p><ol><li><p>b2 &#x3D;&gt; getstatic 用来加载静态变量，哪个静态变量呢？</p></li><li><p>00 02 引用常量池中 #2 项，即【Field java&#x2F;lang&#x2F;System.out：Ljava&#x2F;io&#x2F;PrintStream;】</p></li><li><p>12 &#x3D;&gt; ldc 加载参数，哪个参数呢？</p></li><li><p>03 引用常量池中 #3 项，即 【String hello world】</p></li><li><p>b6 &#x3D;&gt; invokevirtual 预备调用成员方法，哪个方法呢？</p></li><li><p>00 04 引用常量池中 #4 项，即【Method java&#x2F;io&#x2F;PrintStream.println：（Ljava&#x2F;lang&#x2F;String;）V】</p></li><li><p>b1 表示返回</p></li></ol><p>请参考</p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6%E3%80%82">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6。</a></p><h3 id="2-2-javap-工具"><a href="#2-2-javap-工具" class="headerlink" title="2.2 javap 工具"></a>2.2 javap 工具</h3><p>自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译类 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">2a b7 00 01 b</span><br><span class="line">b2 00 02 12 03 b6 00 04 b</span><br><span class="line">[root@localhost ~]# javap -v HelloWorld.class</span><br><span class="line">Classfile /root/HelloWorld.class</span><br><span class="line">Last modified Jul 7, 2019; size 597 bytes</span><br><span class="line">MD5 checksum 361dca1c3f4ae38644a9cd5060ac6dbc</span><br><span class="line">Compiled from &quot;HelloWorld.java&quot;</span><br><span class="line">public class cn.itcast.jvm.t5.HelloWorld</span><br><span class="line">minor version: 0</span><br><span class="line">major version: 52</span><br><span class="line">flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">#1 = Methodref #6.#21 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#2 = Fieldref #22.#23 //</span><br><span class="line">java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">#3 = String #24 // hello world</span><br><span class="line">#4 = Methodref #25.#26 // java/io/PrintStream.println:</span><br><span class="line">(Ljava/lang/String;)V</span><br><span class="line">#5 = Class #27 // cn/itcast/jvm/t5/HelloWorld</span><br><span class="line">#6 = Class #28 // java/lang/Object</span><br><span class="line">#7 = Utf8 &lt;init&gt;</span><br><span class="line">#8 = Utf8 ()V</span><br><span class="line">#9 = Utf8 Code</span><br><span class="line">#10 = Utf8 LineNumberTable</span><br><span class="line">#11 = Utf8 LocalVariableTable</span><br><span class="line">#12 = Utf8 this</span><br><span class="line">#13 = Utf8 Lcn/itcast/jvm/t5/HelloWorld;</span><br></pre></td></tr></table></figure><p>#14 &#x3D; Utf8 main<br>#15 &#x3D; Utf8 （[Ljava&#x2F;lang&#x2F;String;）V<br>#16 &#x3D; Utf8 args<br>#17 &#x3D; Utf8 [Ljava&#x2F;lang&#x2F;String;<br>#18 &#x3D; Utf8 MethodParameters<br>#19 &#x3D; Utf8 SourceFile<br>#20 &#x3D; Utf8 HelloWorld.java<br>#21 &#x3D; NameAndType #7：#8 &#x2F;&#x2F; “”:(）V<br>#22 &#x3D; Class #29 &#x2F;&#x2F; java&#x2F;lang&#x2F;System<br>#23 &#x3D; NameAndType #30：#31 &#x2F;&#x2F; out：Ljava&#x2F;io&#x2F;PrintStream;<br>#24 &#x3D; Utf8 hello world<br>#25 &#x3D; Class #32 &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream<br>#26 &#x3D; NameAndType #33：#34 &#x2F;&#x2F; println：（Ljava&#x2F;lang&#x2F;String;）V<br>#27 &#x3D; Utf8 cn&#x2F;itcast&#x2F;jvm&#x2F;t5&#x2F;HelloWorld<br>#28 &#x3D; Utf8 java&#x2F;lang&#x2F;Object<br>#29 &#x3D; Utf8 java&#x2F;lang&#x2F;System<br>#30 &#x3D; Utf8 out<br>#31 &#x3D; Utf8 Ljava&#x2F;io&#x2F;PrintStream;<br>#32 &#x3D; Utf8 java&#x2F;io&#x2F;PrintStream<br>#33 &#x3D; Utf8 println<br>#34 &#x3D; Utf8 （Ljava&#x2F;lang&#x2F;String;）V<br>{<br>public cn.itcast.jvm.t5.HelloWorld（）;<br>descriptor： （）V<br>flags： ACC_PUBLIC<br>Code：<br>stack&#x3D;1， locals&#x3D;1， args_size&#x3D;<br>0： aload_<br>1： invokespecial #1 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.”<br>“:(）V<br>4： 返回<br>行号表：<br>行 4： 0<br>局部变量表：<br>起始长度 插槽名称 签名<br>0 5 0 this Lcn&#x2F;itcast&#x2F;jvm&#x2F;t5&#x2F;HelloWorld;</p><p>public static void main（java.lang.String[]）;<br>描述符： （[Ljava&#x2F;lang&#x2F;String;）V<br>标志： ACC_PUBLIC， ACC_STATIC<br>代码：<br>stack&#x3D;2， locals&#x3D;1， args_size&#x3D;<br>0： getstatic #2 &#x2F;&#x2F; Field<br>java&#x2F;lang&#x2F;System.out：Ljava&#x2F;io&#x2F;PrintStream;<br>3： ldc #3 &#x2F;&#x2F; String hello world<br>5： invokevirtual #4 &#x2F;&#x2F; Method<br>java&#x2F;io&#x2F;PrintStream.println：（Ljava&#x2F;lang&#x2F;String;）V<br>8： return<br>Number LineTable：<br>line 6： 0<br>line 7： 8<br>LocalVariableTable：<br>Start Length Slot Name Signature<br>0 9 0 args [Ljava&#x2F;lang&#x2F;String;<br>方法参数：<br>名称标志<br>参数<br>}</p><h3 id="2-3-图解方法执行流程"><a href="#2-3-图解方法执行流程" class="headerlink" title="2.3 图解方法执行流程"></a>2.3 图解方法执行流程</h3><h4 id="1-）原始-java-代码"><a href="#1-）原始-java-代码" class="headerlink" title="1 ）原始 java 代码"></a>1 ）原始 java 代码</h4><h4 id="2-）编译后的字节码文件"><a href="#2-）编译后的字节码文件" class="headerlink" title="2 ）编译后的字节码文件"></a>2 ）编译后的字节码文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.jvm.t3.bytecode;</span><br><span class="line">/**</span><br><span class="line">* 演示 字节码指令 和 操作数栈、常量池的关系</span><br><span class="line">*/</span><br><span class="line">public class Demo3_1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int a = 10 ;</span><br><span class="line">int b = Short.MAX_VALUE + 1 ;</span><br><span class="line">int c = a + b;</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@localhost ~]# javap -v Demo3_1.class</span><br><span class="line">Classfile /root/Demo3_1.class</span><br><span class="line">Last modified Jul 7, 2019; size 665 bytes</span><br><span class="line">MD5 checksum a2c29a22421e218d4924d31e6990cfc</span><br><span class="line">Compiled from &quot;Demo3_1.java&quot;</span><br><span class="line">public class cn.itcast.jvm.t3.bytecode.Demo3_</span><br><span class="line">minor version: 0</span><br><span class="line">major version: 52</span><br><span class="line">flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">#1 = Methodref #7.#26 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#2 = Class #27 // java/lang/Short</span><br><span class="line">#3 = Integer 32768</span><br><span class="line">#4 = Fieldref #28.#29 //</span><br><span class="line">java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">#5 = Methodref #30.#31 // java/io/PrintStream.println:(I)V</span><br><span class="line">#6 = Class #32 // cn/itcast/jvm/t3/bytecode/Demo3_</span><br><span class="line">#7 = Class #33 // java/lang/Object</span><br><span class="line">#8 = Utf8 &lt;init&gt;</span><br><span class="line">#9 = Utf8 ()V</span><br><span class="line">#10 = Utf8 Code</span><br><span class="line">#11 = Utf8 LineNumberTable</span><br><span class="line">#12 = Utf8 LocalVariableTable</span><br><span class="line">#13 = Utf8 this</span><br><span class="line">#14 = Utf8 Lcn/itcast/jvm/t3/bytecode/Demo3_1;</span><br><span class="line">#15 = Utf8 main</span><br><span class="line">#16 = Utf8 ([Ljava/lang/String;)V</span><br><span class="line">#17 = Utf8 args</span><br><span class="line">#18 = Utf8 [Ljava/lang/String;</span><br><span class="line">#19 = Utf8 a</span><br></pre></td></tr></table></figure><p>#20 &#x3D; Utf8 I<br>#21 &#x3D; Utf8 b<br>#22 &#x3D; Utf8 c<br>#23 &#x3D; Utf8 MethodParameters<br>#24 &#x3D; Utf8 SourceFile<br>#25 &#x3D; Utf8 Demo3_1.java<br>#26 &#x3D; NameAndType #8:#9 &#x2F;&#x2F; “”:()V<br>#27 &#x3D; Utf8 java&#x2F;lang&#x2F;Short<br>#28 &#x3D; Class #34 &#x2F;&#x2F; java&#x2F;lang&#x2F;System<br>#29 &#x3D; NameAndType #35:#36 &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;<br>#30 &#x3D; Class #37 &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream<br>#31 &#x3D; NameAndType #38:#39 &#x2F;&#x2F; println:(I)V<br>#32 &#x3D; Utf8 cn&#x2F;itcast&#x2F;jvm&#x2F;t3&#x2F;bytecode&#x2F;Demo3_<br>#33 &#x3D; Utf8 java&#x2F;lang&#x2F;Object<br>#34 &#x3D; Utf8 java&#x2F;lang&#x2F;System<br>#35 &#x3D; Utf8 out<br>#36 &#x3D; Utf8 Ljava&#x2F;io&#x2F;PrintStream;<br>#37 &#x3D; Utf8 java&#x2F;io&#x2F;PrintStream<br>#38 &#x3D; Utf8 println<br>#39 &#x3D; Utf8 (I)V<br>{<br>public cn.itcast.jvm.t3.bytecode.Demo3_1();<br>descriptor: ()V<br>flags: ACC_PUBLIC<br>Code:<br>stack&#x3D;1, locals&#x3D;1, args_size&#x3D;<br>0: aload_<br>1: invokespecial #1 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.”<br>“:()V<br>4: return<br>LineNumberTable:<br>line 6: 0<br>LocalVariableTable:<br>Start Length Slot Name Signature<br>0 5 0 this Lcn&#x2F;itcast&#x2F;jvm&#x2F;t3&#x2F;bytecode&#x2F;Demo3_1;</p><p>public static void main(java.lang.String[]);<br>descriptor: ([Ljava&#x2F;lang&#x2F;String;)V<br>flags: ACC_PUBLIC, ACC_STATIC<br>Code:<br>stack&#x3D;2, locals&#x3D;4, args_size&#x3D;<br>0: bipush 10<br>2: istore_<br>3: ldc #3 &#x2F;&#x2F; int 32768<br>5: istore_<br>6: iload_<br>7: iload_<br>8: iadd<br>9: istore_<br>10: getstatic #4 &#x2F;&#x2F; Field<br>java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;<br>13: iload_<br>14: invokevirtual #5 &#x2F;&#x2F; Method<br>java&#x2F;io&#x2F;PrintStream.println:(I)V<br>17: return<br>LineNumberTable:<br>line 8: 0<br>line 9: 3</p><h4 id="3-）常量池载入运行时常量池"><a href="#3-）常量池载入运行时常量池" class="headerlink" title="3 ）常量池载入运行时常量池"></a>3 ）常量池载入运行时常量池</h4><h4 id="4-）方法字节码载入方法区"><a href="#4-）方法字节码载入方法区" class="headerlink" title="4 ）方法字节码载入方法区"></a>4 ）方法字节码载入方法区</h4><h4 id="5-）main-线程开始运行，分配栈帧内存"><a href="#5-）main-线程开始运行，分配栈帧内存" class="headerlink" title="5 ）main 线程开始运行，分配栈帧内存"></a>5 ）main 线程开始运行，分配栈帧内存</h4><p>（stack&#x3D;2，locals&#x3D;4）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">line 10: 6</span><br><span class="line">line 11: 10</span><br><span class="line">line 12: 17</span><br><span class="line">LocalVariableTable:</span><br><span class="line">Start Length Slot Name Signature</span><br><span class="line">0 18 0 args [Ljava/lang/String;</span><br><span class="line">3 15 1 a I</span><br><span class="line">6 12 2 b I</span><br><span class="line">10 8 3 c I</span><br><span class="line">MethodParameters:</span><br><span class="line">Name Flags</span><br><span class="line">args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-）执行引擎开始执行字节码"><a href="#6-）执行引擎开始执行字节码" class="headerlink" title="6 ）执行引擎开始执行字节码"></a>6 ）执行引擎开始执行字节码</h4><p>bipush 10</p><p>将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有</p><p>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</p><p>ldc 将一个 int 压入操作数栈</p><p>ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）</p><p>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</p><p>istore_</p><p>将操作数栈顶数据弹出，存入局部变量表的 slot 1</p><p>ldc</p><p>从常量池加载 #3 数据到操作数栈</p><p>注意 Short.MAX_VALUE 是 32767 ，所以 32768 &#x3D; Short.MAX_VALUE + 1 实际是在编译期间计算</p><p>好的</p><p>istore_</p><p>iload_1</p><p>iload_2</p><p>iadd</p><p> istore_3</p><p> getstatic #4</p><p>iload_3</p><p> invokevirtual #5</p><p> 找到常量池 #5 项</p><p> 定位到方法区 java&#x2F;io&#x2F;PrintStream.println:(I)V 方法</p><p> 生成新的栈帧（分配 locals、stack等）</p><p> 传递参数，执行新栈帧中的字节码</p><p> 执行完毕，弹出栈帧</p><p> 清除 main 操作数栈内容</p><p> return</p><p> 完成 main 方法调用，弹出 main 栈帧</p><p> 程序结束</p><h3 id="2-4-练习-分析-i"><a href="#2-4-练习-分析-i" class="headerlink" title="2.4 练习 - 分析 i++"></a>2.4 练习 - 分析 i++</h3><p> 目的：从字节码角度分析 a++ 相关题目</p><p> 源码：</p><p> 字节码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.jvm.t3.bytecode;</span><br><span class="line">/**</span><br><span class="line">* 从字节码角度分析 a++ 相关题目</span><br><span class="line">*/</span><br><span class="line">public class Demo3_2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int a = 10 ;</span><br><span class="line">int b = a++ + ++a + a--;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">descriptor: ([Ljava/lang/String;)V</span><br><span class="line">flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">stack=2, locals=3, args_size=1</span><br><span class="line">0: bipush 10</span><br><span class="line">2: istore_1</span><br><span class="line">3: iload_1</span><br><span class="line">4: iinc 1, 1</span><br><span class="line">7: iinc 1, 1</span><br><span class="line">10: iload_1</span><br><span class="line">11: iadd</span><br><span class="line">12: iload_1</span><br><span class="line">13: iinc 1, -1</span><br><span class="line">16: iadd</span><br><span class="line">17: istore_2</span><br></pre></td></tr></table></figure><p> 分析：</p><p> 注意 iinc 指令是直接在局部变量 slot 上进行运算</p><p> a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">18: getstatic #2 // Field</span><br><span class="line">java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">21: iload_1</span><br><span class="line">22: invokevirtual #3 // Method</span><br><span class="line">java/io/PrintStream.println:(I)V</span><br><span class="line">25: getstatic #2 // Field</span><br><span class="line">java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">28: iload_2</span><br><span class="line">29: invokevirtual #3 // Method</span><br><span class="line">java/io/PrintStream.println:(I)V</span><br><span class="line">32: return</span><br><span class="line">LineNumberTable:</span><br><span class="line">line 8: 0</span><br><span class="line">line 9: 3</span><br><span class="line">line 10: 18</span><br><span class="line">line 11: 25</span><br><span class="line">line 12: 32</span><br><span class="line">LocalVariableTable:</span><br><span class="line">Start Length Slot Name Signature</span><br><span class="line">0 33 0 args [Ljava/lang/String;</span><br><span class="line">3 30 1 a I</span><br><span class="line">18 15 2 b I</span><br></pre></td></tr></table></figure><h3 id="2-5-条件判断指令"><a href="#2-5-条件判断指令" class="headerlink" title="2.5 条件判断指令"></a>2.5 条件判断指令</h3><p> 指令 助记符 含义</p><p> 0x99 ifeq 判断是否 &#x3D;&#x3D; 0</p><p>0x9a ifne 判断是否 ！&#x3D; 0</p><p>0x9b iflt 判断是否 &lt; 0</p><p>0x9c ifge 判断是否 &gt;&#x3D; 0</p><p>0x9d ifgt 判断是否 &gt; 0</p><p>0x9e ifle 判断是否 &lt;&#x3D; 0</p><p>0x9f if_icmpeq 两个int是否 &#x3D;&#x3D;</p><p>0xa0 if_icmpne 两个int是否 ！&#x3D;</p><p>0xa1 if_icmplt 两个int是否 &lt;</p><p>0xa2 if_icmpge 两个int是否&gt;&#x3D;</p><p>0xa3 if_icmpgt 两个int是否&gt;</p><p>0xa4 if_icmple 两个int是否&lt;&#x3D;</p><p>0xa5 if_acmpeq 两个引用是否 &#x3D;&#x3D;</p><p>0xa6 if_acmpne 两个引用是否 ！&#x3D;</p><p>0xc6 ifnull 判断是否 &#x3D;&#x3D; null</p><p>0xc7 ifnonnull 判断是否 ！&#x3D; null</p><p>几点说明：</p><p>byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节</p><p>goto 用来进行跳转到指定行号的字节码</p><p>源码：</p><p>字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3_3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span> ) &#123;</span><br><span class="line">a = <span class="number">10</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">a = <span class="number">20</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考</p><p>细心的同学应当注意到，以上比较指令中没有 long，float，double 的比较，那么它们要比较怎</p><p>么办？</p><p>参考 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 垃圾回收</title>
      <link href="/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1. 如何判断对象可以回收"></a>1. 如何判断对象可以回收</h2><h3 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h3><hr><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.assets/image-20220822104352038.png" alt="image-20220822104352038"></p><p>只要对象被引用，计数就+1。不再引用就-1。 为0被回收</p><p>循环引用问题。</p><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><hr><ul><li>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li><li>扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以 回收</li><li>哪些对象可以作为 GC Root ?<ul><li><p>MAT（memory analyzer）工具</p></li><li><p>栈引用的对象，被加锁的对象还有糸统核心的类对象 堆中的</p><span id="more"></span></li></ul></li></ul><h3 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h3><hr><ol><li>强引用</li></ol><ul><li>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li></ul><ol start="2"><li>软引用（SoftReference）</li></ol><ul><li>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用 对象</li><li>可以配合引用队列来释放软引用自身</li></ul><ol start="3"><li>弱引用（WeakReference）</li></ol><ul><li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li><li>可以配合引用队列来释放弱引用自身</li></ul><ol start="4"><li>虚引用（PhantomReference）</li></ol><ul><li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队， 由 Reference Handler 线程调用虚引用相关方法释放直接内存</li></ul><ol start="5"><li>终结器引用（FinalReference）</li></ol><ul><li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象 暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象</li></ul><h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2. 垃圾回收算法"></a>2. 垃圾回收算法</h2><h3 id="2-1-标记清除"><a href="#2-1-标记清除" class="headerlink" title="2.1 标记清除"></a>2.1 标记清除</h3><hr><p>定义： Mark Sweep</p><ul><li><p>速度较快</p></li><li><p>会造成内存碎片</p><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.assets/image-20220822105654824.png" alt="image-20220822105654824"></p></li></ul><h3 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2 标记整理"></a>2.2 标记整理</h3><hr><p>定义：Mark Compact</p><ul><li><p>速度慢</p></li><li><p>没有内存碎片</p><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.assets/image-20220822105727568.png" alt="image-20220822105727568"></p></li></ul><h3 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3 复制"></a>2.3 复制</h3><hr><p>定义：Copy</p><ul><li>不会有内存碎片</li><li>需要占用双倍内存空间</li></ul><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.assets/image-20220822105908299.png" alt="image-20220822105908299"></p><h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3. 分代垃圾回收"></a>3. 分代垃圾回收</h2><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.assets/image-20220822105931557.png" alt="image-20220822105931557"></p><ul><li>对象首先分配在伊甸园区域</li><li>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的 对象年龄加 1并且交换 from to</li><li>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li><li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</li><li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时 间更长</li><li>新生代存放朝生夕死的对象，老年代存放用的频繁的</li></ul><h3 id="3-1-相关-VM-参数"><a href="#3-1-相关-VM-参数" class="headerlink" title="3.1 相关 VM 参数"></a>3.1 相关 VM 参数</h3><hr><table><thead><tr><th>含义</th><th>参数</th></tr></thead><tbody><tr><td>堆初始大小</td><td>-Xms</td></tr><tr><td>堆最大大小</td><td>-Xmx 或 -XX:MaxHeapSize&#x3D;size</td></tr><tr><td>新生代大小</td><td>-Xmn 或 (-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size )</td></tr><tr><td>幸存区比例（动态）</td><td>-XX:InitialSurvivorRatio&#x3D;ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td>幸存区比例</td><td>-XX:SurvivorRatio&#x3D;ratio</td></tr><tr><td>晋升阈值</td><td>-XX:MaxTenuringThreshold&#x3D;threshold</td></tr><tr><td>晋升详情</td><td>-XX:+PrintTenuringDistribution</td></tr><tr><td>GC详情</td><td>-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td>FullGC 前 MinorGC</td><td>-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4. 垃圾回收器"></a>4. 垃圾回收器</h2><ol><li>串行<ul><li>单线程</li><li>堆内存较小，适合个人电脑</li></ul></li><li>吞吐量优先</li></ol><ul><li>多线程</li><li>堆内存较大，多核 cpu</li><li>让单位时间内，STW 的时间最短 0.2 0.2 &#x3D; 0.4，垃圾回收时间占比最低，这样就称吞吐量高</li></ul><ol start="3"><li>响应时间优先</li></ol><ul><li>多线程</li><li>堆内存较大，多核 cpu</li><li>尽可能让单次 STW 的时间最短 0.1 0.1 0.1 0.1 0.1 &#x3D; 0.5</li></ul><h3 id="4-1-串行"><a href="#4-1-串行" class="headerlink" title="4.1 串行"></a>4.1 串行</h3><hr><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.assets/image-20220822111327376.png" alt="image-20220822111327376"></p><p>复制算法 + 标记整理</p><p>新生代 + 老年代</p><h3 id="4-2-吞吐量优先"><a href="#4-2-吞吐量优先" class="headerlink" title="4.2 吞吐量优先"></a>4.2 吞吐量优先</h3><hr><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.assets/image-20220822111531389.png" alt="image-20220822111531389"></p><h3 id="4-3-响应时间优先-CMS"><a href="#4-3-响应时间优先-CMS" class="headerlink" title="4.3 响应时间优先 CMS"></a>4.3 响应时间优先 CMS</h3><hr><p><img src="/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.assets/image-20220822111550191.png" alt="image-20220822111550191"></p><h3 id="4-4-G1"><a href="#4-4-G1" class="headerlink" title="4.4 G1"></a>4.4 G1</h3><hr><p>定义：Garbage First</p><ul><li>2017 JDK 9 默认</li></ul><p>适用场景</p><ul><li>同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms</li><li>超大堆内存，会将堆划分为多个大小相等的 Region</li><li>整体上是 标记+整理 算法，两个区域之间是 复制 算法</li></ul><p>相关 JVM 参数</p><p>-XX:+UseG1GC</p><p>-XX:G1HeapRegionSize&#x3D;size </p><p>-XX:MaxGCPauseMillis&#x3D;time</p><p><strong>因为堆内存大，所以回收速度会变慢，涉及到标记复制等。化整为零，方便进行优化，标记。加快速度。每个区都有完整的新生代老年代</strong>。</p><h4 id="1-G1-垃圾回收阶段"><a href="#1-G1-垃圾回收阶段" class="headerlink" title="1) G1 垃圾回收阶段"></a>1) G1 垃圾回收阶段</h4><img src="/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220822112654594.png" alt="image-20220822112654594" style="zoom: 50%;"><h4 id="2-Young-Collection"><a href="#2-Young-Collection" class="headerlink" title="2) Young Collection"></a>2) Young Collection</h4><ul><li>会STW</li></ul><img src="/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220822113339234.png" alt="image-20220822113339234" style="zoom:33%;"><h4 id="3-Young-Collection-CM"><a href="#3-Young-Collection-CM" class="headerlink" title="3) Young Collection + CM"></a>3) Young Collection + CM</h4><ul><li>在 Young GC 时会进行 GC Root 的初始标记</li><li>老年代占用堆空间比例达到阈值时，进行并发标记（不会 STW），由下面的 JVM 参数决定</li></ul><p>老年代占用堆空间比例达到阈值时，进行并发标记（不会 STW），由下面的 JVM 参数决定</p><img src="/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220822113438244.png" alt="image-20220822113438244" style="zoom:33%;"><h4 id="4-Mixed-Collection"><a href="#4-Mixed-Collection" class="headerlink" title="4) Mixed Collection"></a>4) Mixed Collection</h4><p>会对 E、S、O 进行全面垃圾回收</p><ul><li>最终标记（Remark）会 STW</li><li>拷贝存活（Evacuation）会 STW</li></ul><p>-XX:MaxGCPauseMillis&#x3D;ms 暂停时间，为了达到这个暂停时间，去优秀标记有价值的</p><img src="/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220822114130477.png" alt="image-20220822114130477" style="zoom:33%;"><h4 id="5-Full-GC"><a href="#5-Full-GC" class="headerlink" title="5) Full GC"></a>5) Full GC</h4><ul><li><p>SerialGC 串行</p><ul><li>新生代内存不足发生的垃圾收集 - minor gc  新生代的垃圾回收一般都是复制算法 老年代是标记整理</li><li>老年代内存不足发生的垃圾收集 - full gc</li></ul></li><li><p>ParallelGC 并行</p><ul><li>新生代内存不足发生的垃圾收集 - minor gc</li><li>老年代内存不足发生的垃圾收集 - full gc</li></ul></li><li><p>CMS 并发</p><ul><li>新生代内存不足发生的垃圾收集 - minor gc</li><li>老年代内存不足</li></ul></li><li><p>G1 并发</p><ul><li>新生代内存不足发生的垃圾收集 - minor gc</li><li>老年代内存不足 有个阈值，老年代内存占比堆内存达到百分之45，就会触发并发标记和混合收集。如果回收速度大于新产生速度，还不是FullGC，当小于速度的时候，并发就失败了，就会退回串行，并FullGC</li></ul></li></ul><h4 id="6-Young-Collection-跨代引用"><a href="#6-Young-Collection-跨代引用" class="headerlink" title="6) Young Collection 跨代引用"></a>6) Young Collection 跨代引用</h4><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><img src="/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220822115242586.png" alt="image-20220822115242586" style="zoom:33%;"><p>新生代回收需要找到根对象，然后可达算法找到幸存的，有些根对象在老年代中</p><ul><li>卡表与 Remembered Set</li><li>在引用变更时通过 post-write barrier + dirty card queue</li><li>concurrent refinement threads 更新 Remembered Set</li></ul><img src="/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220822115450644.png" alt="image-20220822115450644" style="zoom:33%;"><h4 id="7-Remark"><a href="#7-Remark" class="headerlink" title="7) Remark"></a>7) Remark</h4><p>pre-write barrier + satb_mark_queue 在对象引用前加入一个队列，完了再检查队列中的元素</p><img src="/2022/08/22/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/image-20220822120017301.png" alt="image-20220822120017301" style="zoom:33%;"><h4 id="8-JDK-8u20-字符串去重"><a href="#8-JDK-8u20-字符串去重" class="headerlink" title="8) JDK 8u20 字符串去重"></a>8) JDK 8u20 字符串去重</h4><ul><li>优点：节省大量内存</li><li>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加</li></ul><p>-XX:+UseStringDeduplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>将所有新分配的字符串放入一个队列</li><li>当新生代回收时，G1并发检查是否有字符串重复</li><li>如果它们值一样，让它们引用同一个 char[]</li><li>注意，与 String.intern() 不一样<ul><li>String.intern() 关注的是字符串对象</li><li>而字符串去重关注的是 char[]</li><li>在 JVM 内部，使用了不同的字符串表</li></ul></li></ul><h4 id="9-JDK-8u40-并发标记类卸载"><a href="#9-JDK-8u40-并发标记类卸载" class="headerlink" title="9) JDK 8u40 并发标记类卸载"></a>9) JDK 8u40 并发标记类卸载</h4><p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸 载它所加载的所有类</p><p>-XX:+ClassUnloadingWithConcurrentMark 默认启用</p><h4 id="10-JDK-8u60-回收巨型对象"><a href="#10-JDK-8u60-回收巨型对象" class="headerlink" title="10) JDK 8u60 回收巨型对象"></a>10) JDK 8u60 回收巨型对象</h4><ul><li>一个对象大于 region 的一半时，称之为巨型对象</li><li>G1 不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生 代垃圾回收时处理掉</li></ul><h4 id="11-JDK-9-并发标记起始时间的调整"><a href="#11-JDK-9-并发标记起始时间的调整" class="headerlink" title="11) JDK 9 并发标记起始时间的调整"></a>11) JDK 9 并发标记起始时间的调整</h4><ul><li>并发标记必须在堆空间占满前完成，否则退化为 FullGC</li><li>JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent</li><li>JDK 9 可以动态调整<ul><li>JDK 9 可以动态调整</li><li>进行数据采样并动态调整</li><li>总会添加一个安全的空档空间</li></ul></li></ul><h4 id="12-JDK-9-更高效的回收"><a href="#12-JDK-9-更高效的回收" class="headerlink" title="12) JDK 9 更高效的回收"></a>12) JDK 9 更高效的回收</h4><ul><li>250+增强</li><li>180+bug修复</li></ul><h2 id="5-垃圾回收调优"><a href="#5-垃圾回收调优" class="headerlink" title="5. 垃圾回收调优"></a>5. 垃圾回收调优</h2><p>预备知识</p><ul><li>掌握 GC 相关的 VM 参数，会基本的空间调整</li><li>掌握相关工具</li><li>明白一点：调优跟应用、环境有关，没有放之四海而皆准的法则</li></ul><h3 id="5-1-调优领域"><a href="#5-1-调优领域" class="headerlink" title="5.1 调优领域"></a>5.1 调优领域</h3><hr><ul><li>内存</li><li>锁竞争</li><li>cpu 占用</li><li>io</li></ul><h3 id="5-2-确定目标"><a href="#5-2-确定目标" class="headerlink" title="5.2 确定目标"></a>5.2 确定目标</h3><hr><ul><li>【低延迟】还是【高吞吐量】，选择合适的回收器</li><li>CMS，G1，ZGC</li><li>ParallelGC</li><li>Zing</li></ul><h3 id="5-3-最快的-GC"><a href="#5-3-最快的-GC" class="headerlink" title="5.3 最快的 GC"></a>5.3 最快的 GC</h3><hr><p>答案是不发生 GC</p><ul><li>查看 FullGC 前后的内存占用，考虑下面几个问题<ul><li><p>数据是不是太多？</p><ul><li>resultSet &#x3D; statement.executeQuery(“select * from 大表 limit n”)</li></ul></li><li><p>数据表示是否太臃肿？</p><ul><li>对象图</li><li>对象大小 16 Integer 24 int 4  对象瘦身</li></ul></li><li><p>是否存在内存泄漏？</p><ul><li>static Map map &#x3D;  长期存在的对象 一直往里加会造成溢出， 通过下面的三个方法</li><li>软</li><li>弱</li><li>第三方缓存实现</li></ul></li></ul></li></ul><h3 id="5-4-新生代调优"><a href="#5-4-新生代调优" class="headerlink" title="5.4 新生代调优"></a>5.4 新生代调优</h3><hr><ul><li><p>新生代的特点（内存调优从新生代开始）</p><ul><li><p>所有的 new 操作的内存分配非常廉价</p><ul><li>TLAB thread-local allocation buffer  每个线程局部的私有的区域 进行伊甸园分配，线程安全</li></ul></li><li><p>死亡对象的回收代价是零  （新生代所有的垃圾回收器都是用的复制算法）</p></li><li><p>大部分对象用过即死 新生代中的</p></li><li><p>Minor GC 的时间远远低于 Full GC</p></li></ul></li></ul><p>策略：</p><ul><li>新生代调优加大容量 越大越好吗？</li></ul><p>-Xmn Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC is performed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</p><p>新生代小了会频繁mGC 引发暂停   太大了 老年代的空间就少了，空间少的触发垃圾回收FullGC就多了</p><ul><li>新生代能容纳所有【并发量 * (请求-响应)】的数据</li><li>幸存区大到能保留【当前活跃对象+需要晋升对象】</li><li>晋升阈值配置得当，让长时间存活对象尽快晋升</li></ul><p>晋升阈值配置得当，让长时间存活对象尽快晋升</p><p>-XX:MaxTenuringThreshold&#x3D;threshold</p><p>-XX:+PrintTenuringDistribution</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Desired survivor size <span class="number">48286924</span> bytes, <span class="keyword">new</span> <span class="title class_">threshold</span> <span class="number">10</span> (max <span class="number">10</span>)</span><br><span class="line">- age <span class="number">1</span>: <span class="number">28992024</span> bytes, <span class="number">28992024</span> total</span><br><span class="line">- age <span class="number">2</span>: <span class="number">1366864</span> bytes, <span class="number">30358888</span> total</span><br><span class="line">- age <span class="number">3</span>: <span class="number">1425912</span> bytes, <span class="number">31784800</span> total</span><br><span class="line">..</span><br></pre></td></tr></table></figure><h3 id="5-5-老年代调优"><a href="#5-5-老年代调优" class="headerlink" title="5.5 老年代调优"></a>5.5 老年代调优</h3><hr><p>以 CMS 为例</p><ul><li>以 CMS 为例</li><li>先尝试不做调优，如果没有 Full GC 那么已经…，否则先尝试调优新生代</li><li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1&#x2F;4 ~ 1&#x2F;3<ul><li>-XX:CMSInitiatingOccupancyFraction&#x3D;percent</li></ul></li></ul><h3 id="5-6-案例"><a href="#5-6-案例" class="headerlink" title="5.6 案例"></a>5.6 案例</h3><hr><ul><li>案例1 Full GC 和 Minor GC频繁<ul><li>增大新生代空间，提高晋升阈值</li></ul></li><li>案例2 请求高峰期发生 Full GC，单次暂停时间特别长 （CMS）<ul><li>CMS处理过程中，重新标记所耗费的时间最长。</li><li>因为重新标记要扫描整个内存。所以重新扫描前先对新生代做一次垃圾回收可以减少扫描数量，降低时间</li></ul></li><li>案例3 老年代充裕情况下，发生 Full GC （CMS jdk1.7）<ul><li>1.7 方法区在永久代，永久代空间不足也会发生FullGC</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存结构</title>
      <link href="/2022/08/22/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>/2022/08/22/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822091326221.png" alt="image-20220822091326221"></p><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h2><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822091419608.png" alt="image-20220822091419608"></p><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a><strong>1.1 定义</strong></h3><hr><p>Program Counter Register 程序计数器（寄存器）</p><ul><li>作用——是记住下一条jvm指令的执行地址</li><li>特点<ul><li><p>线程私有</p></li><li><p>不会存在内存溢出</p><span id="more"></span></li></ul></li></ul><h3 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h3><hr><p>记录下一跳在哪</p><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822091643388.png" alt="image-20220822091643388"></p><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h2><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822091746461.png" alt="image-20220822091746461"></p><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><hr><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><ul><li>每个线程运行时所需要的内存，称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><p>问题辨析：</p><ol><li><p>垃圾回收是否涉及栈内存？</p><p>不涉及，垃圾回收只是在堆内存</p></li><li><p>栈内存分配越大越好吗？</p><p>栈内存变大，会让线程数变少，因为物理内存大小一定</p></li><li><p>方法内的局部变量是否线程安全？</p><ul><li>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的。<strong>只被该方法改变</strong></li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li></ul></li></ol><h3 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h3><hr><ul><li>栈帧过多导致栈内存溢出</li><li>栈帧过大导致栈内存溢出</li></ul><h3 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h3><hr><p>案例1： cpu 占用过多</p><p>定位：</p><ul><li>用top定位哪个进程对cpu的占用过高</li><li>ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高）</li><li>jstack 进程id<ul><li>可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号</li></ul></li></ul><p>案例2：程序运行很长时间没有结果</p><ul><li>可能发生了线程死锁</li></ul><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h2><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822094040781.png" alt="image-20220822094040781"></p><p>一些底层的别的语言c语言等编写的方法</p><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h2><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822094149113.png" alt="image-20220822094149113"></p><h3 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h3><hr><p>Heap 堆</p><ul><li>通过 new 关键字，创建对象都会使用堆内存</li></ul><p>特点</p><ul><li>它是线程共享的，堆中对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul><h3 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2 堆内存溢出"></a>4.2 堆内存溢出</h3><hr><p>OutOfMemoryError： Java heap space</p><h3 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3 堆内存诊断"></a>4.3 堆内存诊断</h3><hr><ol><li><p>jps 工具</p><ul><li>查看当前系统中有哪些 java 进程</li></ul></li><li><p>jmap 工具</p><ul><li>查看堆内存占用情况 jmap - heap 进程id</li></ul></li><li><p>jconsole 工具</p></li></ol><ul><li>图形界面的，多功能的监测工具，可以连续监测</li></ul><p>案例：</p><ul><li>垃圾回收后，内存占用仍然很高<ul><li>强引用</li></ul></li></ul><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822095410619.png" alt="image-20220822095410619"></p><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><hr><p> Java虚拟机中有一个被所有jvm线程共享的方法区。方法区有点类似于传统编程语言中的编译代码块或者操作系统层面的代码段。它存储着每个类的构造信息，譬如运行时的常量池，字段，方法数据，以及方法和构造方法的代码，包括一些在类和实例初始化和接口初始化时候使用的特殊方法。</p><p>方法区在jvm启动时候被创建。虽然方法区在逻辑层面上是堆的一部分，但是就简单实现来说既不会被回收也不会被压缩。这个规范并不强制指定方法区存放的位置也不会对编译过的代码有管理策略的限制。方法区可能有一个固定的大小或者也可以通过计算大小去扩展也可以在不需要的时候被压缩。方法区的内存也不需要是连续的。</p><p>Jvm虚拟机实现可以提供给编程人员或者用户初始化方法区的大小，同时在方法区可变大小的情况下，控制这个方法区的最大值和最小值。</p><p>如果方法区满足不了构造所需要的内存，jvm就会抛出OutOfMemoryError。</p><h3 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成"></a>5.2 组成</h3><hr><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822095752859.png" alt="image-20220822095752859"></p><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822095801877.png" alt="image-20220822095801877"></p><h3 id="5-3-方法区内存溢出"><a href="#5-3-方法区内存溢出" class="headerlink" title="5.3 方法区内存溢出"></a>5.3 方法区内存溢出</h3><hr><ul><li><p>1.8 以前会导致永久代内存溢出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 演示永久代内存溢出 java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">* -XX:MaxPermSize=8m</span><br></pre></td></tr></table></figure></li><li><p>1.8 之后会导致元空间内存溢出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">* -XX:MaxMetaspaceSize=8m</span><br></pre></td></tr></table></figure></li></ul><p>场景：</p><ul><li>spring</li><li>mybatis</li></ul><h3 id="5-4-运行时常量池"><a href="#5-4-运行时常量池" class="headerlink" title="5.4 运行时常量池"></a>5.4 运行时常量池</h3><hr><ul><li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量 等信息</li><li>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量 池，并把里面的符号地址变为真实地址</li></ul><h3 id="5-5-StringTable"><a href="#5-5-StringTable" class="headerlink" title="5.5 StringTable"></a>5.5 StringTable</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s4.intern();</span><br><span class="line"><span class="comment">// 问</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s5); <span class="comment">// true</span></span><br><span class="line">System.out.println(s3 == s6); <span class="comment">// true</span></span><br><span class="line"><span class="type">String</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line">x2.intern();</span><br><span class="line"><span class="comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢</span></span><br><span class="line">System.out.println(x1 == x2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="5-5-StringTable-特性"><a href="#5-5-StringTable-特性" class="headerlink" title="5.5 StringTable 特性"></a>5.5 StringTable 特性</h3><hr><ul><li>常量池中的字符串仅是符号，第一次用到时才变为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是 StringBuilder （1.8）</li><li>字符串常量拼接的原理是编译期优化</li><li>可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池<ul><li>1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串 池中的对象返回</li><li>1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份， 放入串池， 会把串池中的对象返回</li></ul></li></ul><h3 id="5-6-StringTable-位置"><a href="#5-6-StringTable-位置" class="headerlink" title="5.6 StringTable 位置"></a>5.6 StringTable 位置</h3><hr><p>1.6在永久代 常量池里</p><p>1.7 1.8 在堆内存中</p><ul><li>为什么转移？<ul><li>永久代内存回收效率很低，需要Full GC的时候才会回收 也就是等到老年代空间不足的时候才会触发-间接导致串池回收效率不高-因为串池使用非常频繁，如果回收效率不高就占用大量永久代内存容易产生永久代内存不足。</li><li>到堆内存中后 只需要mGC就会触发回收，减轻了串池对内存的占用</li></ul></li></ul><h3 id="5-7-StringTable-垃圾回收"><a href="#5-7-StringTable-垃圾回收" class="headerlink" title="5.7 StringTable 垃圾回收"></a>5.7 StringTable 垃圾回收</h3><hr><ul><li>串池是用哈希表实现的。桶的个数决定效率</li><li>mGC</li></ul><h3 id="5-8-StringTable-性能调优"><a href="#5-8-StringTable-性能调优" class="headerlink" title="5.8 StringTable 性能调优"></a>5.8 StringTable 性能调优</h3><hr><ul><li>调整 -XX:StringTableSize&#x3D;桶个数</li><li>考虑将字符串对象是否入池,通过字符串入池去重节约内存</li></ul><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h2><h3 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h3><hr><p>Direct Memory</p><ul><li>常见于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受 JVM 内存回收管理</li></ul><p><img src="/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.assets/image-20220822103422838.png" alt="image-20220822103422838"></p><h3 id="6-2-分配和回收原理"><a href="#6-2-分配和回收原理" class="headerlink" title="6.2 分配和回收原理"></a>6.2 分配和回收原理</h3><hr><ul><li>使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法</li><li>ByteBuffer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuffer 对象，一旦 ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调 用 freeMemory 来释放直接内存</li><li>垃圾回收不会回收直接内存，直接内存建议手动管理。用unsafe的freeMemory</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有没有一分钟，我们认真地为自己活过</title>
      <link href="/2022/08/22/%E6%9C%89%E6%B2%A1%E6%9C%89%E4%B8%80%E5%88%86%E9%92%9F%EF%BC%8C%E6%88%91%E4%BB%AC%E8%AE%A4%E7%9C%9F%E5%9C%B0%E4%B8%BA%E8%87%AA%E5%B7%B1%E6%B4%BB%E8%BF%87/"/>
      <url>/2022/08/22/%E6%9C%89%E6%B2%A1%E6%9C%89%E4%B8%80%E5%88%86%E9%92%9F%EF%BC%8C%E6%88%91%E4%BB%AC%E8%AE%A4%E7%9C%9F%E5%9C%B0%E4%B8%BA%E8%87%AA%E5%B7%B1%E6%B4%BB%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<hr><center><b><font face="仿宋" size="5">苍山覆雪，明烛天南。</font></b></center><center><font face="仿宋" size="6">不带目的的生活，怀良辰以孤往。</font></center>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
          <category> 摘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文字 </tag>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM概述</title>
      <link href="/2022/08/21/JVM%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/08/21/JVM%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM ?"></a>什么是 JVM ?</h2><p><strong>定义：</strong></p><ul><li>Java Virtual Machine - java 程序的运行环境（java 二进制字节码的运行环境）</li></ul><p><strong>好处：</strong></p><ul><li>一次编写，到处运行·</li><li>自动内存管理，垃圾回收功能</li><li>数组下标越界检查</li><li>多态</li></ul><p><strong>比较：</strong></p><ul><li><p>jvm与jre、jdk</p></li><li><p>jvm是最底层，其次被jre包含，jre被jdkbaoh</p><span id="more"></span></li></ul><h2 id="学习-JVM-有什么用"><a href="#学习-JVM-有什么用" class="headerlink" title="学习 JVM 有什么用 ?"></a>学习 JVM 有什么用 ?</h2><ul><li>面试</li><li>理解底层的实现原理</li><li>程序员进阶技能</li></ul><h2 id="常见的-JVM"><a href="#常见的-JVM" class="headerlink" title="常见的 JVM"></a>常见的 JVM</h2><p><img src="/JVM%E6%A6%82%E8%BF%B0.assets/image-20220821214940771.png"></p><h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p><img src="/JVM%E6%A6%82%E8%BF%B0.assets/image-20220821215002328.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/20/hello-world/"/>
      <url>/2022/08/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><span id="more"></span><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
